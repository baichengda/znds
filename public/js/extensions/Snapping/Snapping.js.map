{"version":3,"file":"Snapping/Snapping.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapMath.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/Snapper.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapperIndicator.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/index.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js","webpack://Autodesk.Extensions.[name]/./src/compat.js","webpack://Autodesk.Extensions.[name]/./src/wgs/scene/VertexBufferReader.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Snapping/index.js\");\n","\n// Collection of static math functions used for snapping implementation\n\n// Find closest point to p on a circular arc. \n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nexport var nearestPointOnCircularArc = function nearestPointOnCircularArc(p, center, radius, startAngle, endAngle, outPoint) {\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  // get normalized direction from circle center to p.\n  // dir = (p-center).normalized()\n  var dir = outPoint.copy(p).sub(center).normalize();\n\n  // If the point is within the arc, we are done\n  var angle = Math.atan2(dir.y, dir.x);\n  var insideArc = Autodesk.Extensions.CompGeom.angleInsideArc(angle, startAngle, endAngle);\n  if (insideArc) {\n    // The ray from center towards p intersects the circle arc.\n    // So, we obtain the closest point by projecting p onto the circle.\n    //\n    // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n    //  onCircleArc = center + dir * radius\n    return dir.multiplyScalar(radius).add(center);\n  }\n\n  // The closest point on the circle is not on the arc.\n  // Then the closest point must be one of the arc ends. Note that this conclusion\n  // can only be made for circles, but not for ellipses with different radii.\n  var pStart = Autodesk.Extensions.CompGeom.getEllipsePoint(startAngle, center.x, center.y, radius, radius);\n  var pEnd = Autodesk.Extensions.CompGeom.getEllipsePoint(endAngle, center.x, center.y, radius, radius);\n\n  var d2Start = pStart.distanceToSquared(p);\n  var d2End = pEnd.distanceToSquared(p);\n  var startIsCloser = d2Start <= d2End;\n\n  outPoint.copy(startIsCloser ? pStart : pEnd);\n  return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nexport var intersectLines = function intersectLines(p1, p2, p3, p4, checkInsideSegment, outPoint) {var epsilon = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.00001;\n\n  var denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n\n  // Reject if lines are parallel or one of them has zero-length\n  if (Math.abs(denom) < epsilon) {\n    return null;\n  }\n\n  // ua denotes where to find the intersection point p along segment (p1, p2):\n  //   For ua = 0, we have p = p1\n  //   For ua = 1, we have p = p2\n  var ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n  ua /= denom;\n\n  // Apply segment check\n  if (checkInsideSegment) {\n\n    // ub denotes where to find the intersection point p along segment (p3, p4)\n    var ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n    ub /= denom;\n\n    // Intersection is within the segments if ua and ub are both in [0,1]\n    if (ua < 0.0 || ua > 1.0 ||\n    ub < 0.0 || ub > 1.0) {\n      return null;\n    }\n  }\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  outPoint.x = p1.x + ua * (p2.x - p1.x);\n  outPoint.y = p1.y + ua * (p2.y - p1.y);\n  return outPoint;\n};","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { SnapperIndicator } from \"./SnapperIndicator.js\";\nimport { isMobileDevice } from \"../../src/compat.js\";\nimport { VertexBufferReader } from \"../../src/wgs/scene/VertexBufferReader.js\";\nimport { nearestPointOnCircularArc, intersectLines } from \"./SnapMath.js\";\n\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\nvar EPSILON = MeasureCommon.EPSILON;\nvar SnapType = MeasureCommon.SnapType;\nvar SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nvar av = Autodesk.Viewing;\n\nfunction isEqualWithPrecision(a, b) {\n  return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\nfunction isEqualVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x - v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y - v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\nfunction isInverseVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x + v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y + v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n  var X0 = new THREE.Vector3();\n  var X1 = new THREE.Vector3();\n  var distance;\n  var param;\n\n  X0.subVectors(lineStart, point);\n  X1.subVectors(lineEnd, lineStart);\n  param = X0.dot(X1);\n  X0.subVectors(lineEnd, lineStart);\n  param = -param / X0.dot(X0);\n\n  if (param < 0) {\n    distance = point.distanceTo(lineStart);\n  } else\n  if (param > 1) {\n    distance = point.distanceTo(lineEnd);\n  } else\n  {\n    X0.subVectors(point, lineStart);\n    X1.subVectors(point, lineEnd);\n    X0.cross(X1);\n    X1.subVectors(lineEnd, lineStart);\n\n    distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n  }\n\n  return distance;\n};\n\nvar SnapCandidateType = {\n  Unknown: 0,\n  Line: 1,\n  CircularArc: 2,\n  EllipticalArc: 3 };\n\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nvar SnapCandidate = /*#__PURE__*/function () {\n  function SnapCandidate(viewportId, distance) {_classCallCheck(this, SnapCandidate);\n\n    this.type = SnapCandidateType.Unknown;\n    this.viewportId = viewportId;\n\n    // 2d distance between original (unsnapped) position and the geometry of this candidate.\n    this.distance = 0;\n\n    // {Vector2} Start/Endpoint - only for line segments\n    this.lineStart = null;\n    this.lineEnd = null;\n\n    // Fixed radius - only for CircularArcs\n    this.radius = 0;\n\n    // Separate radii - only for ellipse arcs\n    this.radiusX = 0; // = major radius - by convention\n    this.radiusY = 0;\n\n    // Center point as Vector2 (for arcs)\n    this.center = null;\n\n    // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n    this.startAngle = 0;\n    this.endAngle = 0;\n  }_createClass(SnapCandidate, [{ key: \"fromLine\", value: function fromLine(\n\n    p1, p2) {\n      this.type = SnapCandidateType.Line;\n      this.lineStart = p1.clone();\n      this.lineEnd = p2.clone();\n      return this;\n    } }, { key: \"fromCircularArc\", value: function fromCircularArc(\n\n    center, radius, start, end) {\n      this.type = SnapCandidateType.CircularArc;\n      this.center = center.clone();\n      this.radius = radius;\n      this.start = start;\n      this.end = end;\n      return this;\n    } }, { key: \"fromEllipticalArc\", value: function fromEllipticalArc(\n\n    center, radiusX, radiusY, start, end) {\n      this.type = SnapCandidateType.EllipticalArc;\n      this.center = center.clone();\n      this.radiusX = radiusX;\n      this.radiusY = radiusY;\n      this.start = start;\n      this.end = end;\n      return this;\n    } }, { key: \"isLine\", value: function isLine()\n\n    {return this.type === SnapCandidateType.Line;} }, { key: \"isCircularArc\", value: function isCircularArc()\n    {return this.type === SnapCandidateType.CirularArc;} }, { key: \"isEllipticalArc\", value: function isEllipticalArc()\n    {return this.type === SnapCandidateType.EllipticalArc;}\n\n    // Checks if the snapGeometry of this candidate intersects with another one.\n    //  @param {SnapCandidate} other\n    //  @param {Vector2} [optionalTarget]\n    //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n  }, { key: \"getIntersection\", value: function getIntersection(other, optionalTarget) {\n\n      if (this.isLine() && other.isLine()) {\n        // Note: We do the intersections on the whole line - not just the intersections.\n        // Reason is:\n        //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n        //  b) By definition, we get only very close segment candidates anyway\n        return intersectLines(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n      }\n\n      // TODO: Currently, we only support snapping to line-line intersections\n    } }]);return SnapCandidate;}();\n;\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nvar findIntersectionSnap = function findIntersectionSnap(candidates, intersectPoint, snapRadius) {\n\n  // Sort snapping candidates by increasing distance\n  // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n  // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n  // make the snapping smarter later.\n  var byDistance = function byDistance(ca, cb) {return ca.distance - cb.distance;};\n  candidates.sort(byDistance);\n\n  // Stop here if we don't have enough candidates for an intersection\n  if (candidates.length < 2) {\n    return null;\n  }\n\n  // Init result object\n  var result = {\n    // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n    viewportId: candidates[0].viewportId,\n\n    // Snapping happens in 2d - so we set z in advance and just keep the original value.\n    // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n    snapPoint: new THREE.Vector3(0, 0, intersectPoint.z) };\n\n\n  // Check for any candidate that intersects with the closest one we found\n  var first = candidates[0];\n  for (var i = 1; i < candidates.length; i++) {\n    var second = candidates[i];\n\n    // Do intersection test. If found, write it to result.snapPoint\n    var found = first.getIntersection(second, result.snapPoint);\n    if (!found) {\n      continue;\n    }\n\n    // We found an intersection. Although we assume all candidates to be within\n    // snap radius already, the intersection may still be somewhere else.\n    // => Check if intersection is still within the snapRadius.\n    var dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n    if (dist < snapRadius) {\n      // We found a valid intersection snap\n      return result;\n    }\n  }\n  return null;\n};\n\n\n/**\n    * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n    *\n    * @memberof Autodesk.Viewing.Extensions.Snapping\n    * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n    * @constructor\n    */\nexport function Snapper(viewer, options) {\n\n  var _snapResult = new SnapResult();\n\n  var _viewer = viewer;\n  this.setGlobalManager(viewer.globalManager);\n\n  var _options = options || {};\n  var _names;\n\n  if (_options.markupMode) {\n    _names = [\"snapper-markup\"];\n  } else {\n    _names = [\"snapper\"];\n  }\n\n  var _priority = 60;\n\n  var _active = false;\n\n  var _distanceToEdge = Number.MAX_VALUE;\n  var _distanceToVertex = null;\n\n  var _isDragging = false;\n  var _isPressing = false;\n  var _isSnapped = false;\n\n  var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n  var _snapToPixel = false;\n\n  this.indicator = new SnapperIndicator(viewer, this);\n\n  this.markupMode = _options.markupMode;\n  this.renderSnappedGeometry = _options.renderSnappedGeometry;\n  this.renderSnappedTopology = _options.renderSnappedTopology;\n\n  //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n  //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n  this.detectRadiusInPixels = isMobileDevice() ? 50 : 10;\n\n  /**\n                                                           * @returns {boolean} true when the tool is active\n                                                           *\n                                                           * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n                                                           */\n  this.isActive = function () {\n    return _active;\n  };\n\n  this.getNames = function () {\n    return _names;\n  };\n\n  this.getName = function () {\n    return _names[0];\n  };\n\n  this.getPriority = function () {\n    return _priority;\n  };\n\n  /**\n      * Starts intercepting pointer events.\n      * Invoked automatically by the {@link ToolController}.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n      */\n  this.activate = function () {\n    _active = true;\n\n    if (!this.indicator) {\n      this.indicator = new SnapperIndicator(viewer, this);\n    }\n  };\n\n\n  /**\n      * Stops intercepting pointer events.\n      * Invoked automatically by the {@link ToolController}.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n      */\n  this.deactivate = function () {\n    _active = false;\n\n    if (this.indicator) {\n      this.indicator.destroy();\n      this.indicator = null;\n    }\n  };\n\n  this.copyResults = function (destiny) {\n    _snapResult.copyTo(destiny);\n  };\n\n  this.getEdge = function () {\n    return _snapResult.geomEdge;\n  };\n\n  this.getVertex = function () {\n    return _snapResult.geomVertex;\n  };\n\n  this.getGeometry = function () {\n    return _snapResult.getGeometry();\n  };\n\n  this.getGeometryType = function () {\n    return _snapResult.geomType;\n  };\n\n  this.getIntersectPoint = function () {\n    return _snapResult.intersectPoint;\n  };\n\n\n  /**\n      * @returns {SnapResult} The snapping status of the last pointer event performed.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n      */\n  this.getSnapResult = function () {\n    return _snapResult;\n  };\n\n  /**\n      * Checks whether the tool's last update resulted on a snap.\n      *\n      * @returns {boolean} true when the last pointer event got snapped.\n      *\n      * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n      */\n  this.isSnapped = function () {\n    return _isSnapped;\n  };\n\n  this.clearSnapped = function () {\n    _snapResult.clear();\n    _isSnapped = false;\n  };\n\n  this.setViewportId = function (vpId) {\n    _forcedVpId = vpId;\n  };\n\n  this.setSnapToPixel = function (enable) {\n    _snapToPixel = enable;\n  };\n\n  this.getSnapToPixel = function () {\n    return _snapToPixel;\n  };\n\n  /**\n      * 3D Snapping\n      * @param result -Result of Hit Test.\n      */\n  this.snapping3D = function (result) {\n\n    _snapResult.snapNode = result.dbId;\n    _snapResult.intersectPoint = result.intersectPoint;\n    _snapResult.modelId = result.model ? result.model.id : null;\n\n    // Avoid crash if the hit test does not belong to a model. This may happen, if a 3D overlay was hit (see Viewer3DImpl.rayIntersect).\n    if (!result.model) {\n      return;\n    }\n\n    var face = result.face;\n    var fragIds;\n\n    if (!result.fragId || result.fragId.length === undefined) {\n      fragIds = [result.fragId];\n    } else {\n      fragIds = result.fragId;\n    }\n\n    // This is for Fusion model with topology data\n    _snapResult.hasTopology = result.model.hasTopology();\n    if (_snapResult.hasTopology) {\n      this.snapping3DwithTopology(face, fragIds, result.model);\n    } else {\n      this.snapping3DtoMesh(face, fragIds, result.model);\n    }\n  };\n\n  /**\n      * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n      */\n  this.snapping3DwithTopology = function (face, fragIds, model) {\n\n    // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n    if (_snapResult.snapNode) {\n      fragIds = [];\n\n      model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function (fragId) {\n        fragIds.push(fragId);\n      }, true);\n    }\n\n    _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n    _distanceToEdge = Number.MAX_VALUE;\n\n    for (var fi = 0; fi < fragIds.length; ++fi) {\n\n      var fragId = fragIds[fi];\n      var mesh = _viewer.impl.getRenderProxy(model, fragId);\n      var geometry = mesh.geometry;\n\n      var topoIndex = model.getTopoIndex(fragId);\n      var topology = model.getTopology(topoIndex);\n      var facesTopology = topology.faces;\n      var edgesTopology = topology.edges;\n\n      if (!_snapResult.geomFace) {\n        _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);\n\n        if (_snapResult.geomFace) {\n          _snapResult.geomFace.fragId = fragId;\n        }\n\n        var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n        _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      // Need to iterate all frags with same dbId, because when meshes are attached with each other, \n      // edge-topology data will only be on one mesh.\n      this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, mesh);\n\n    }\n\n    _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n    if (_snapResult.geomFace) {\n\n      // Determine which one should be drawn: face , edge or vertex\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n        var center = this.edgeIsCircle(_snapResult.geomEdge);\n        if (center) {\n          _snapResult.circularArcCenter = center;\n          _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n          _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n          _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n          _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n        } else\n        if (this.edgeIsCurved(_snapResult.geomEdge)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n      } else\n      {\n\n        if (this.faceIsCurved(_snapResult.geomFace)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_FACE;\n        }\n\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.snapping3DtoMesh = function (face, fragIds, model) {\n    for (var fi = 0; fi < fragIds.length; ++fi) {\n\n      var fragId = fragIds[fi];\n      var mesh = _viewer.impl.getRenderProxy(model, fragId);\n      var geometry = mesh.geometry;\n\n      // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n      if (face instanceof THREE.Face3) {\n        _snapResult.geomFace = this.faceSnapping(face, geometry);\n      }\n\n      if (!_snapResult.geomFace)\n      continue;\n\n      _snapResult.geomFace.applyMatrix(mesh.matrixWorld);\n      _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n      _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n      var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n      _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n      // Determine which one should be drawn: face , edge or vertex\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) {\n        _snapResult.geomType = SnapType.SNAP_EDGE;\n      } else\n      {\n        _snapResult.geomType = SnapType.SNAP_FACE;\n      }\n\n      _isSnapped = true;\n      break;\n    }\n  };\n\n  this.faceSnappingWithTopology = function (face, geometry, facesTopology, mesh) {\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    var geom = new THREE.Geometry();\n\n    var attributes = geometry.attributes;\n\n    if (attributes.index !== undefined) {\n\n      var positions = geometry.vb ? geometry.vb : attributes.position.array;\n      var stride = geometry.vb ? geometry.vbstride : 3;\n\n      // Find the index of face topology list which includes the intersect face(triangle)\n      for (var i = 0; i < facesTopology.length; i++) {\n\n        var indexList = facesTopology[i].indexList;\n        var faceId = facesTopology[i].id;\n        for (var j = 0; j < indexList.length; j += 3) {\n\n          if (face.a === indexList[j]) {\n            if (face.b === indexList[j + 1] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j + 1]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 1]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 2]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 1] || face.b === indexList[j + 1] && face.c === indexList[j]) {\n              break;\n            }\n          }\n        }\n\n        if (j < indexList.length) {\n          break;\n        }\n      }\n\n      if (i < facesTopology.length) {\n\n        for (var j = 0; j < indexList.length; j += 3) {\n          vA.set(\n          positions[indexList[j] * stride],\n          positions[indexList[j] * stride + 1],\n          positions[indexList[j] * stride + 2]);\n\n          vB.set(\n          positions[indexList[j + 1] * stride],\n          positions[indexList[j + 1] * stride + 1],\n          positions[indexList[j + 1] * stride + 2]);\n\n          vC.set(\n          positions[indexList[j + 2] * stride],\n          positions[indexList[j + 2] * stride + 1],\n          positions[indexList[j + 2] * stride + 2]);\n\n\n          var vIndex = geom.vertices.length;\n\n          geom.vertices.push(vA.clone());\n          geom.vertices.push(vB.clone());\n          geom.vertices.push(vC.clone());\n\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n        }\n      }\n    }\n\n    //console.log(face);\n\n    if (geom.vertices.length > 0) {\n\n      geom.faceId = faceId;\n      geom.applyMatrix(mesh.matrixWorld);\n      return geom;\n    } else\n    {\n\n      return null;\n    }\n\n  };\n\n  /**\n      * Find the closest face next to the cast ray\n      * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n      * @param geometry - the geometry of mesh\n      *\n      * @private\n      */\n  this.faceSnapping = function (face, geometry) {\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    var geom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n\n\n\n    var attributes = geometry.attributes;\n\n    var indices = attributes.index && (attributes.index.array || geometry.ib);\n    var positions = geometry.vb ? geometry.vb : attributes.position.array;\n    var stride = geometry.vb ? geometry.vbstride : 3;\n    var offsets = geometry.offsets;\n\n    if (!offsets || offsets.length === 0) {\n\n      offsets = [{ start: 0, count: indices ? indices.length : positions.length, index: 0 }];\n\n    }\n\n    for (var oi = 0; oi < offsets.length; ++oi) {\n\n      var start = offsets[oi].start;\n      var count = offsets[oi].count;\n      var index = offsets[oi].index;\n\n      for (var i = start; i < start + count; i += 3) {\n\n        var a = index + (indices ? indices[i] : i);\n        var b = index + (indices ? indices[i + 1] : i + 1);\n        var c = index + (indices ? indices[i + 2] : i + 2);\n\n        vA.set(\n        positions[a * stride],\n        positions[a * stride + 1],\n        positions[a * stride + 2]);\n\n        vB.set(\n        positions[b * stride],\n        positions[b * stride + 1],\n        positions[b * stride + 2]);\n\n        vC.set(\n        positions[c * stride],\n        positions[c * stride + 1],\n        positions[c * stride + 2]);\n\n\n        var faceNormal = THREE.Triangle.normal(vA, vB, vC);\n\n        var va = new THREE.Vector3();\n        va.set(\n        positions[face.a * stride],\n        positions[face.a * stride + 1],\n        positions[face.a * stride + 2]);\n\n\n        if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n        {\n\n          var vIndex = geom.vertices.length;\n\n          geom.vertices.push(vA.clone());\n          geom.vertices.push(vB.clone());\n          geom.vertices.push(vC.clone());\n\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n        }\n      }\n    }\n\n    if (geom.vertices.length > 0) {\n\n      return this.getTrianglesOnSameFace(geom, face, positions, stride);\n    } else\n    {\n\n      return null;\n    }\n  };\n\n  /**\n      * Find triangles on the same face with the triangle intersected with the cast ray\n      * @param geom -Geometry which includes all the triangles on the same plane.\n      * @param face -Triangle which intersects with the cast ray.\n      * @param positions -Positions of all vertices.\n      * @param stride -Stride for the interleaved buffer.\n      *\n      * @private\n      */\n  this.getTrianglesOnSameFace = function (geom, face, positions, stride) {\n\n    var isIncludeFace = false; // Check if the intersect face is in the mesh\n    var vertexIndices = geom.vertices.slice();\n\n    var va = new THREE.Vector3();\n    va.set(\n    positions[face.a * stride],\n    positions[face.a * stride + 1],\n    positions[face.a * stride + 2]);\n\n    var vb = new THREE.Vector3();\n    vb.set(\n    positions[face.b * stride],\n    positions[face.b * stride + 1],\n    positions[face.b * stride + 2]);\n\n    var vc = new THREE.Vector3();\n    vc.set(\n    positions[face.c * stride],\n    positions[face.c * stride + 1],\n    positions[face.c * stride + 2]);\n\n    var intersectFace = new THREE.Geometry();\n    intersectFace.vertices.push(va);\n    intersectFace.vertices.push(vb);\n    intersectFace.vertices.push(vc);\n    intersectFace.faces.push(new THREE.Face3(0, 1, 2));\n\n    var vCount = [];\n\n    do {\n\n      vCount = [];\n\n      for (var j = 0; j < vertexIndices.length; j += 3) {\n\n        // The triangle which is intersected with the ray\n        if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {\n\n          isIncludeFace = true;\n          vCount.push(j);\n          continue;\n        }\n\n        for (var k = 0; k < intersectFace.vertices.length; k += 3) {\n\n          // The triangles which are on the same face with the intersected triangle\n          if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],\n          intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {\n\n            var vIndex = intersectFace.vertices.length;\n            intersectFace.vertices.push(vertexIndices[j].clone());\n            intersectFace.vertices.push(vertexIndices[j + 1].clone());\n            intersectFace.vertices.push(vertexIndices[j + 2].clone());\n            intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n            vCount.push(j);\n            break;\n          }\n        }\n      }\n\n      for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n        vertexIndices.splice(vCount[ci], 3);\n\n      }\n\n    } while (vCount.length > 0);\n\n    if (isIncludeFace) {\n      return intersectFace;\n    } else\n    {\n      return null;\n    }\n\n  };\n\n  /**\n      * Check if the two triangle share edge, the inputs are their vertices\n      *\n      * @private\n      */\n  this.trianglesSharedEdge = function (a1, a2, a3, b1, b2, b3) {\n\n    var c1 = false;\n    var c2 = false;\n    var c3 = false;\n\n    if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {\n      c1 = true;\n    }\n    if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {\n      c2 = true;\n    }\n    if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {\n      c3 = true;\n    }\n\n    if (c1 & c2 || c1 & c3 || c2 & c3) {\n      return true;\n    }\n\n    return false;\n  };\n\n  this.edgeSnappingWithTopology = function (intersectPoint, geometry, edgesTopology, mesh) {\n\n    var edgeGeom = new THREE.Geometry();\n    var minDistTopoIndex;\n    var minDist = Number.MAX_VALUE;\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n\n    var attributes = geometry.attributes;\n\n    if (attributes.index !== undefined && edgesTopology != undefined) {\n\n      var positions = geometry.vb ? geometry.vb : attributes.position.array;\n      var stride = geometry.vb ? geometry.vbstride : 3;\n\n      // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n      for (var i = 0; i < edgesTopology.length; i++) {\n\n        var indexList = edgesTopology[i].indexList;\n        // In edges topology index list the type is LineStrip\n        for (var j = 0; j < indexList.length - 1; j++) {\n          vA.set(\n          positions[indexList[j] * stride],\n          positions[indexList[j] * stride + 1],\n          positions[indexList[j] * stride + 2]);\n\n          vB.set(\n          positions[indexList[j + 1] * stride],\n          positions[indexList[j + 1] * stride + 1],\n          positions[indexList[j + 1] * stride + 2]);\n\n\n          vA.applyMatrix4(mesh.matrixWorld);\n          vB.applyMatrix4(mesh.matrixWorld);\n\n          var dist = distancePointToLine(intersectPoint, vA, vB);\n          if (dist < minDist) {\n            minDist = dist;\n            minDistTopoIndex = i;\n          }\n        }\n      }\n\n      if (minDistTopoIndex) {\n        indexList = edgesTopology[minDistTopoIndex].indexList;\n        for (var k = 0; k < indexList.length - 1; k++) {\n          edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));\n          // To make the line's type to LinePieces which is used by drawLine function\n          edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));\n        }\n      }\n    }\n\n    if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n      _distanceToEdge = minDist;\n      edgeGeom.applyMatrix(mesh.matrixWorld);\n      _snapResult.geomEdge = edgeGeom;\n    }\n  };\n\n  /**\n      * Find the closest edge next to the intersect point\n      * @param face -Face which is found by faceSnapping.\n      * @param intersectPoint -IntersectPoint between cast ray and face.\n      * @param mesh -The whole mesh of one fragment.\n      *\n      * @private\n      */\n  this.edgeSnapping = function (face, intersectPoint) {\n\n    var lineGeom = new THREE.Geometry();\n    var isEdge_12 = true;\n    var isEdge_13 = true;\n    var isEdge_23 = true;\n\n    for (var i = 0; i < face.vertices.length; i += 3) {\n\n      for (var j = 0; j < face.vertices.length; j += 3) {\n\n        if (i !== j) {\n          // Check edge 12\n          if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1]) ||\n          face.vertices[i].equals(face.vertices[j + 2])) && (\n          face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 1].equals(face.vertices[j + 2]))) {\n\n            isEdge_12 = false;\n\n          }\n          // Check edge 13\n          if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1]) ||\n          face.vertices[i].equals(face.vertices[j + 2])) && (\n          face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n            isEdge_13 = false;\n\n          }\n          // Check edge 23\n          if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 1].equals(face.vertices[j + 2])) && (\n          face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1]) ||\n          face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n            isEdge_23 = false;\n\n          }\n        }\n      }\n\n      if (isEdge_12) {\n\n        lineGeom.vertices.push(face.vertices[i].clone());\n        lineGeom.vertices.push(face.vertices[i + 1].clone());\n\n      }\n      if (isEdge_13) {\n\n        lineGeom.vertices.push(face.vertices[i].clone());\n        lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n      }\n      if (isEdge_23) {\n\n        lineGeom.vertices.push(face.vertices[i + 1].clone());\n        lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n      }\n\n      isEdge_12 = true;\n      isEdge_13 = true;\n      isEdge_23 = true;\n\n    }\n\n    //return lineGeom;\n\n    var edgeGeom = new THREE.Geometry();\n    var minDistIndex;\n    var minDist = Number.MAX_VALUE;\n\n    for (var k = 0; k < lineGeom.vertices.length; k += 2) {\n\n      var dist = distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);\n\n      if (dist < minDist) {\n        minDist = dist;\n        minDistIndex = k;\n      }\n\n    }\n\n    edgeGeom.vertices.push(lineGeom.vertices[minDistIndex].clone());\n    edgeGeom.vertices.push(lineGeom.vertices[minDistIndex + 1].clone());\n\n    edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);\n\n    _distanceToEdge = minDist;\n\n    return edgeGeom;\n\n  };\n\n  this.getConnectedLineSegmentsOnSameLine = function (lineGeom, edgeVertices) {\n\n    var vertices = lineGeom.vertices.slice();\n    var va = edgeVertices[0];\n    var vb = edgeVertices[1];\n\n    var vCount = [];\n\n    do {\n\n      vCount = [];\n\n      for (var j = 0; j < vertices.length; j += 2) {\n\n        // The line which has min distance to intersection point\n        if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n          continue;\n        }\n\n        for (var k = 0; k < edgeVertices.length; k += 2) {\n\n          // The line segments which are connected on the same line\n          if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n          vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n            var V0 = new THREE.Vector3();\n            var V1 = new THREE.Vector3();\n\n            V0.subVectors(edgeVertices[k], edgeVertices[k + 1]);\n            V0.normalize();\n            V1.subVectors(vertices[j], vertices[j + 1]);\n            V1.normalize();\n\n            //if (V0.equals(V1) || V0.equals(V1.negate())) {\n            if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n            {\n\n              vCount.push(j);\n              break;\n\n            }\n          }\n        }\n      }\n\n      for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n        edgeVertices.push(vertices[vCount[ci]]);\n        edgeVertices.push(vertices[vCount[ci] + 1]);\n        vertices.splice(vCount[ci], 2);\n\n      }\n\n    } while (vCount.length > 0);\n\n    return edgeVertices;\n\n  };\n\n  this.vertexSnappingWithTopology = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n\n    if (edge && edge.vertices.length > 1) {\n      var dist1 = intersectPoint.distanceTo(edge.vertices[0]);\n      var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);\n\n      if (dist1 <= dist2) {\n        minDist = dist1;\n        point = edge.vertices[0].clone();\n      } else\n      {\n        minDist = dist2;\n        point = edge.vertices[edge.vertices.length - 1].clone();\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  /**\n      * Find the closest vertex next to the intersect point\n      * @param edge -Edge which is found by edgeSnapping.\n      * @param intersectPoint -IntersectPoint between cast ray and face.\n      *\n      * @private\n      */\n  this.vertexSnapping = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n\n    for (var i = 0; i < edge.vertices.length; ++i) {\n\n      var dist = intersectPoint.distanceTo(edge.vertices[i]);\n\n      if (dist < minDist - SNAP_PRECISION) {\n\n        minDist = dist;\n        point = edge.vertices[i].clone();\n\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  // This is only a workaround to detect if an edge is circle\n  this.edgeIsCircle = function (edge) {\n\n    var vertices = edge.vertices;\n\n    // Exclude squares and regular polygons\n    if (vertices.length < 8) {\n      return false;\n    }\n\n    if (vertices[0].equals(vertices[vertices.length - 1])) {\n\n      var center = new THREE.Vector3(0, 0, 0);\n      for (var i = 0; i < vertices.length; i += 2) {\n        center.add(vertices[i]);\n      }\n      center.divideScalar(vertices.length / 2.0);\n\n      var radius = center.distanceTo(vertices[0]);\n      for (var i = 0; i < vertices.length; i += 2) {\n        if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n          continue;\n        } else\n        {\n          return false;\n        }\n      }\n      return center;\n    } else\n    {\n      return false;\n    }\n  };\n\n  this.edgeIsCurved = function (edge) {\n\n    var vertices = edge.vertices;\n\n    if (vertices.length <= 2) {\n      return false;\n    } else\n    if (vertices[0].equals(vertices[vertices.length - 1])) {\n      return true;\n    } else\n    {\n      var V1 = new THREE.Vector3();\n      V1.subVectors(vertices[0], vertices[1]);\n\n      var V2 = new THREE.Vector3();\n      for (var i = 2; i < vertices.length; i += 2) {\n        V2.subVectors(vertices[i], vertices[i + 1]);\n        if (!isEqualVectorsWithPrecision(V1, V2)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  this.faceIsCurved = function (face) {\n\n    var vertices = face.vertices;\n    var faces = face.faces;\n\n    if (faces.length <= 1) {\n      return false;\n    } else\n    {\n      var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);\n      var vA1 = vertices[faces[0].a];\n\n      for (var i = 1; i < faces.length; i++) {\n        var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);\n        var vA2 = vertices[faces[i].a];\n\n        if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  this.angleVector2 = function (vector) {\n\n    if (vector.x > 0 && vector.y >= 0) {\n      return Math.atan(vector.y / vector.x);\n    } else\n    if (vector.x >= 0 && vector.y < 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI * 2;\n    } else\n    if (vector.x < 0 && vector.y <= 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    if (vector.x <= 0 && vector.y > 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    {// x = 0, y = 0\n      return null;\n    }\n  };\n\n  // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n  // Points are obtained by by uniform sampling of a given elliptical arc.\n  //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n  // See getEllipseArcPoint() for param details.\n  var createEllipticalArcGeometry = function createEllipticalArcGeometry(cx, cy, rx, ry, startAngle, endAngle, numPoints) {\n    var geometry = new THREE.Geometry();\n    for (var i = 0; i < numPoints; i++) {\n      var p = new THREE.Vector3(0, 0, 0);\n      var t = i / (numPoints - 1);\n      Autodesk.Extensions.CompGeom.getEllipseArcPoint(t, cx, cy, rx, ry, startAngle, endAngle, 0.0, p);\n      geometry.vertices.push(p);\n    }\n    return geometry;\n  };\n\n  function GeometryCallback(viewer, snapper, aDetectRadius) {\n    this.viewer = viewer;\n    this.snapper = snapper;\n\n    this.lineGeom = new THREE.Geometry();\n    this.circularArc = null;\n    this.circularArcCenter;\n    this.circularArcRadius;\n    this.ellipticalArc = null;\n    this.ellipticalArcCenter;\n\n    this.minDist = Number.MAX_VALUE;\n\n    this.vpIdLine = null;\n    this.vpIdCircular = null;\n    this.vpIdElliptical = null;\n\n    this.detectRadius = aDetectRadius;\n\n    // Collects candidate segments that we can snap to.\n    // This is used to allow snapping to segment intersections.\n    this.snapCandidates = []; // {SnappingCandidate[]}\n  }\n\n  GeometryCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var vertices = this.lineGeom.vertices;\n    var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n    var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n    // Skip segments outside detectRadius\n    var dist = distancePointToLine(intersectPoint, v1, v2);\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n    // Track minDist and lineGeometry for best hit so far\n    if (dist < this.minDist) {\n\n      vertices.splice(0, 2, v1, v2);\n      this.minDist = dist;\n\n      this.vpIdLine = vpId;\n    }\n  };\n\n  GeometryCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n\n    // Compute closest point on arc\n    var pointOnArc = nearestPointOnCircularArc(intersectPoint, center, radius, start, end);\n    var dist = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n    // Skip arcs outside detectRadius\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n    //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n    var angle = this.snapper.angleVector2(point);\n\n    if (end > start && angle >= start && angle <= end) {\n      var arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n    } else\n    if (end < start && (angle >= start || angle <= end)) {\n      var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n    } else\n    {\n      return;\n    }\n    arc.vertices.splice(0, 1);\n    arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n    this.circularArc = arc;\n    this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n    this.circularArcRadius = radius;\n\n    this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n    this.vpIdCircular = vpId;\n  };\n\n  GeometryCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var major1 = major - this.detectRadius;\n    var minor1 = minor - this.detectRadius;\n    var major2 = major + this.detectRadius;\n    var minor2 = minor + this.detectRadius;\n\n    var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n    var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n    point.x *= minor;\n    point.y *= major;\n    var angle = this.snapper.angleVector2(point);\n\n    if (end > Math.PI * 2) {\n      end = Math.PI * 2;\n    }\n\n    if (equation1 >= 1 && equation2 <= 1) {\n\n      if (end > start && angle >= start && angle <= end || end < start && (angle >= start || angle <= end)) {\n        var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n        if (!isEqualWithPrecision(end - start, Math.PI * 2))\n        {\n          arc.vertices.pop();\n        }\n        arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n        // Compute distance between geometry and snapped point. \n        // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n        var nearestPoint = nearestVertexInVertexToEdge(intersectPoint, arc);\n        var dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n        // Collect snap candidate\n        var _center = new THREE.Vector2(cx, cy);\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(_center, major, minor, start, end));\n\n        // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping. \n        //       We should consider the distance here as well.\n        this.ellipticalArc = arc;\n        this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n        this.vpIdElliptical = vpId;\n      }\n    }\n  };\n\n  this.snapping2D = function (result) {\n\n    if (!result) {\n      return;\n    }\n\n    var intersectPoint = result.intersectPoint;\n    var fragIds = result.fragId;\n\n    if (typeof fragIds === \"undefined\") {\n      return;\n    } else\n    if (!Array.isArray(fragIds)) {\n      fragIds = [fragIds];\n    }\n\n    _snapResult.modelId = result.model ? result.model.id : null;\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    _snapResult.radius = this.setDetectRadius(intersectPoint);\n\n    // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n    var supportsGeomSnapping = _viewer.model.getFragmentList() != null;\n    if (!supportsGeomSnapping) {\n\n      // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n      // distances between arbitrary points in rasters.\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.SNAP_VERTEX;\n      _snapResult.geomVertex = intersectPoint;\n\n      return;\n    }\n\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    for (var fi = 0; fi < fragIds.length; ++fi) {\n\n      var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragIds[fi]);\n\n      if (mesh && mesh.geometry) {\n        var vbr = new VertexBufferReader(mesh.geometry);\n        vbr.enumGeomsForObject(_viewer.model.reverseMapDbId(result.dbId), gc);\n      }\n    }\n\n    this.finishSnapping2D(gc, intersectPoint);\n\n    // Snap the unsnapped point only if the snapping fails\n    if (!_isSnapped && _snapToPixel) {\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.RASTER_PIXEL;\n      _snapResult.geomVertex = intersectPoint;\n    }\n  };\n\n  // By default, snapper only considers model geometry that is written to ID buffer.\n  // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but \n  // enumerates the given meshes instead of getting them from the fragment list.\n  //\n  //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n  //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n  //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n  //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n  this.snapping2DOverlay = function (intersectPoint, meshes, filter, detectRadius) {\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      var vbr = new VertexBufferReader(mesh.geometry);\n      vbr.enumGeoms(filter, gc);\n    }\n\n    this.finishSnapping2D(gc, intersectPoint);\n  };\n\n  // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n  // within in a given bbox in model-space.\n  //  @param {Vector3}                          intersectPoint (3D with z=0)\n  //  @param {function(minx, miny, maxx, maxy)} enumSegments\n  this.snapping2DWithSegmentEnum = function (intersectPoint, enumSegments) {\n\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.radius = this.setDetectRadius(intersectPoint);\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    // enum all segments within the snapRadius around intersectPoint\n    var minx = intersectPoint.x - _snapResult.radius;\n    var miny = intersectPoint.y - _snapResult.radius;\n    var maxx = intersectPoint.x + _snapResult.radius;\n    var maxy = intersectPoint.y + _snapResult.radius;\n    enumSegments(minx, miny, maxx, maxy, gc);\n\n    this.finishSnapping2D(gc, intersectPoint);\n  };\n\n  // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n  this.finishSnapping2D = function (gc, intersectPoint) {\n\n    // When restricting to a single viewport, exclude candidates of all other viewports\n    if (_forcedVpId !== null) {\n      var isSameViewport = function isSameViewport(c) {return c.viewportId === _forcedVpId;};\n      gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n    }\n\n    // Check if we can snap to an intersection of two close segments\n    var intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n    if (intersectSnap) {\n      _snapResult.viewportIndex2d = intersectSnap.viewportId;\n      _snapResult.snapPoint = intersectSnap.snapPoint;\n      _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n      _snapResult.geomVertex = intersectSnap.snapPoint;\n      _isSnapped = true;\n      return;\n    }\n\n    if (gc.circularArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n      _snapResult.snapPoint = gc.snapPoint;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.circularArc.vertices[0];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.circularArc);\n        _snapResult.geomEdge = gc.circularArc;\n        _snapResult.circularArcCenter = gc.circularArcCenter;\n        _snapResult.circularArcRadius = gc.circularArcRadius;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n\n    } else\n    if (gc.ellipticalArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.ellipticalArc.vertices[0];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _snapResult.radius) {\n\n        _snapResult.geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.ellipticalArc);\n        _snapResult.geomEdge = gc.ellipticalArc;\n        // Before we have measure design for elliptical arc, measure the center for now\n        _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n        _snapResult.circularArcRadius = null;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n    } else\n    if (gc.lineGeom.vertices.length) {\n\n      _snapResult.viewportIndex2d = gc.vpIdLine;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n      // This allows us to combine it with other snap constraints later - as done by Edit2D.\n      _snapResult.geomEdge = gc.lineGeom;\n\n      if (this.markupMode) {// Markup mode\n        var start = gc.lineGeom.vertices[0];\n        var end = gc.lineGeom.vertices[1];\n        var mid = new THREE.Vector3();\n        mid.addVectors(start, end);\n        mid.divideScalar(2);\n        var md = intersectPoint.distanceTo(mid);\n        var sd = intersectPoint.distanceTo(start);\n        var ed = intersectPoint.distanceTo(end);\n\n        // Store it for snapping to parallel/perpendicular of underlying vectors\n        _snapResult.geomEdge = gc.lineGeom;\n\n        if (md < _snapResult.radius) {\n          _snapResult.geomVertex = mid;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (sd < _snapResult.radius) {\n          _snapResult.geomVertex = start;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (ed < _snapResult.radius) {\n          _snapResult.geomVertex = end;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n        // Circle center\n        if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n          _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n        }\n      } else\n      {// Measure mode\n        if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _snapResult.radius) {\n\n          if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n            _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n          } else {\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n          }\n\n          _snapResult.geomVertex = gc.lineGeom.vertices[0];\n        } else\n        if (_options.forceSnapVertices || intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _snapResult.radius) {\n\n          _snapResult.geomVertex = gc.lineGeom.vertices[1];\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.snappingLeaflet = function (result) {\n    if (!result) {\n      return;\n    }\n\n    var intersectPoint = result.intersectPoint;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.hasTopology = false;\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    _snapResult.radius = this.setDetectRadius(intersectPoint);\n    _snapResult.geomType = SnapType.RASTER_PIXEL;\n    _snapResult.geomVertex = intersectPoint;\n    _isSnapped = true;\n  };\n\n  this.snapMidpoint = function () {\n    _snapResult.isMidpoint = false;\n\n    // Snap midpoint for edge\n    if (_isSnapped) {\n      if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n        var edge = _snapResult.geomEdge;\n        var p1 = edge.vertices[0];\n        var p2 = edge.vertices[1];\n\n        var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n        if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n          _snapResult.geomVertex = midpoint;\n          _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n        }\n      }\n    }\n  };\n\n  this.setPerpendicular = function (isPerpendicular) {\n    _snapResult.isPerpendicular = isPerpendicular;\n  };\n\n  this.lineStripToPieces = function (geom) {\n\n    var vertices = geom.vertices;\n    for (var i = vertices.length - 2; i > 0; i--) {\n      vertices.splice(i, 0, vertices[i]);\n    }\n  };\n\n  this.setDetectRadius = function (point) {\n\n    var navapi = _viewer.navigation;\n    var camera = navapi.getCamera();\n    var position = navapi.getPosition();\n\n    var p = point.clone();\n\n    var distance = camera.isPerspective ? p.sub(position).length() :\n    navapi.getEyeVector().length();\n\n    var fov = navapi.getVerticalFov();\n    var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n    var viewport = navapi.getScreenViewport();\n    var _window = this.getWindow();\n    var devicePixelRatio = _window.devicePixelRatio || 1;\n    var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n    return radius;\n  };\n\n  this.handleButtonDown = function (event, button) {\n    _isDragging = true;\n    return false;\n  };\n\n  this.handleButtonUp = function (event, button) {\n    _isDragging = false;\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n\n    if (_isDragging)\n    return false;\n\n    this.onMouseMove({\n      x: event.canvasX,\n      y: event.canvasY });\n\n\n    return false;\n  };\n\n  this.handleSingleTap = function (event) {\n\n    return this.handleMouseMove(event);\n  };\n\n  this.handlePressHold = function (event) {\n\n    if (isMobileDevice()) {\n      switch (event.type) {\n\n        case \"press\":\n          _isPressing = true;\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          break;\n\n        case \"pressup\":\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          _isPressing = false;\n          break;}\n\n    }\n    return false;\n\n  };\n\n  this.handleGesture = function (event)\n  {\n    if (isMobileDevice()) {\n      if (_isPressing) {\n        switch (event.type) {\n\n          case \"dragstart\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            break;\n\n          case \"dragmove\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            break;\n\n          case \"dragend\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            _isPressing = false;\n            break;\n\n          case \"pinchstart\":\n\n            break;\n\n          case \"pinchmove\":\n            break;\n\n          case \"pinchend\":\n            break;}\n\n      }\n    }\n\n    return false;\n  };\n\n  /**\n      * Handler to mouse move events, used to snap in markup edit mode.\n      * @private\n      */\n  this.onMouseDown = function (mousePosition) {\n    return this.onMouseMove(mousePosition);\n  };\n\n  /**\n      * Handler to mouse move events, used to snap in markup edit mode.\n      * @private\n      */\n  this.onMouseMove = function (mousePosition) {\n\n    this.clearSnapped();\n\n    var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n    if (!result && _snapToPixel) {\n      var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n      var point = _viewer.impl.intersectGroundViewport(vpVec);\n      result = { intersectPoint: point };\n    }\n\n    if (!result || !result.intersectPoint)\n    return false;\n\n    // 3D Snapping\n    if (result.face) {\n      this.snapping3D(result);\n    }\n    // 2D Snapping\n    else if (result.dbId || result.dbId === 0) {\n        this.snapping2D(result);\n      }\n      // PDF - Leaflet Snapping\n      else {\n          this.snappingLeaflet(result);\n        }\n\n    this.snapMidpoint();\n\n    return true;\n  };\n};\n\nav.GlobalManagerMixin.call(Snapper.prototype);","var MeasureCommon = Autodesk.Viewing.MeasureCommon;\nvar isEqualVectors = MeasureCommon.isEqualVectors;\nvar EPSILON = MeasureCommon.EPSILON;\nvar SnapType = MeasureCommon.SnapType;\n\nvar NO_OVERLAY = 0;\nvar FACE_OVERLAY = 1;\nvar EDGE_OVERLAY = 2;\nvar POINT_OVERLAY = 3;\n\nvar GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\nvar INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\nvar _geometryLineWidth = 0.3;\nvar _indicatorLineWidth = 0.2;\nvar _indicatorSize = 1.2;\nvar _point = null;\n\nvar _indicatorColor = 0xff7700;\nvar _geometryColor = 0x00CC00;\n\n// /** @constructor */\nexport function SnapperIndicator(viewer, snapper)\n{\n  this.viewer = viewer;\n  this.snapper = snapper;\n  this.overlayType = NO_OVERLAY;\n  this.previewsIntersectPoint = null;\n\n  this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n  this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n  this.geometryMaterial = new THREE.MeshPhongMaterial({\n    color: _geometryColor,\n    ambient: _geometryColor,\n    opacity: 0.5,\n    transparent: true,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n\n  this.indicatorMaterial = new THREE.MeshBasicMaterial({\n    color: _indicatorColor,\n    ambient: _indicatorColor,\n    opacity: 1,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false,\n    side: THREE.DoubleSide });\n\n}\n\nSnapperIndicator.prototype.constructor = SnapperIndicator;\nvar proto = SnapperIndicator.prototype;\n\n\nproto.render = function () {\n\n  var snapResult = this.snapper.getSnapResult();\n\n  if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n    this.clearOverlay(GEOMETRIES_OVERLAY);\n  }\n\n  this.clearOverlay(INDICATOR_OVERLAY);\n\n  if (snapResult.isEmpty())\n  return;\n\n  if (this.snapper.renderSnappedGeometry ||\n  snapResult.hasTopology && this.snapper.renderSnappedTopology) {\n    this.renderGeometry(snapResult);\n  }\n  this.renderIndicator(snapResult);\n\n  this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n};\n\nproto.removeOverlay = function (overlayName) {\n\n  this.viewer.impl.clearOverlay(overlayName);\n  this.viewer.impl.removeOverlayScene(overlayName);\n\n};\n\nproto.clearOverlay = function (overlayName) {\n\n  this.removeOverlay(overlayName);\n  this.viewer.impl.createOverlayScene(overlayName);\n\n};\n\nproto.clearOverlays = function () {\n\n  this.removeOverlay(GEOMETRIES_OVERLAY);\n  this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n  this.removeOverlay(INDICATOR_OVERLAY);\n  this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n  this.previewsIntersectPoint = null;\n\n};\n\nproto.addOverlay = function (overlayName, mesh) {\n\n  this.viewer.impl.addOverlay(overlayName, mesh);\n\n};\n\n/**\n    * Draw the planar face\n    * @param geom -Geometry which needs to be draw.\n    * @param mesh -Mesh which is loaded.\n    */\nproto.drawFace = function (geom, material, overlayName) {\n\n  var snapperPlane = new THREE.Mesh(geom, material, true);\n\n  if (overlayName === GEOMETRIES_OVERLAY) {\n    this.overlayType = FACE_OVERLAY;\n  }\n\n  this.addOverlay(overlayName, snapperPlane);\n\n};\n\nproto.cylinderMesh = function (pointX, pointY, material, width) {\n\n  var direction = new THREE.Vector3().subVectors(pointY, pointX);\n  var orientation = new THREE.Matrix4();\n  orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n  orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n  0, 0, 1, 0,\n  0, -direction.length(), 0, 0,\n  0, 0, 0, 1));\n\n  width = width || 0.5;\n  var cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n  var edge = new THREE.Mesh(cylinder, material);\n  cylinder = null;\n\n  edge.applyMatrix(orientation);\n  edge.position.x = (pointY.x + pointX.x) / 2;\n  edge.position.y = (pointY.y + pointX.y) / 2;\n  edge.position.z = (pointY.z + pointX.z) / 2;\n  return edge;\n\n};\n\nproto.renderGeometry = function (snapResult) {\n\n  if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n    return;\n  }\n\n  switch (snapResult.geomType) {\n    case SnapType.SNAP_VERTEX:\n      SnapType.RASTER_PIXEL;\n      this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n      break;\n\n    case SnapType.SNAP_EDGE:\n    case SnapType.SNAP_CURVEDEDGE:\n    case SnapType.SNAP_CIRCULARARC:\n    case SnapType.SNAP_MIDPOINT:\n      this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n      break;\n\n    case SnapType.SNAP_FACE:\n    case SnapType.SNAP_CURVEDFACE:\n      this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n      break;}\n\n};\n\nproto.renderVertexIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Upper line\n  p.addVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.addVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\nproto.renderMidpointIndicator = function (snapResult) {\n\n  var pos = snapResult.geomVertex;\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.addVectors(pos, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.addVectors(pos, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\nproto.renderEdgeIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  p.addVectors(pos, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\nproto.renderCircleIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n};\n\nproto.renderPerpendicular = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Upper line\n  geom.vertices[0] = pos.clone();\n  p.subVectors(pos, rightVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Right line\n  geom.vertices[0] = pos.clone();\n  p.subVectors(pos, upVec);\n  geom.vertices[1] = p.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n};\n\nproto.renderPixelIndicator = function (snapResult) {\n\n  var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n  var scale = this.setScale(pos);\n  var length = _indicatorSize * scale;\n\n  var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n  var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n  var geom = new THREE.Geometry();\n  var p = new THREE.Vector3();\n\n  // Top-left line\n  p.subVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Top-right line\n  p.addVectors(pos, rightVec);\n  p.addVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom-right line\n  p.addVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  // Bottom-left line\n  p.subVectors(pos, rightVec);\n  p.subVectors(p, upVec);\n  geom.vertices[0] = p.clone();\n  geom.vertices[1] = pos.clone();\n  this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n\n};\n\nproto.renderIndicator = function (snapResult) {\n\n  if (snapResult.isPerpendicular) {\n    this.renderPerpendicular(snapResult);\n    return;\n  }\n\n  switch (snapResult.geomType) {\n    case SnapType.SNAP_VERTEX:\n      this.renderVertexIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_INTERSECTION:\n      this.renderVertexIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_MIDPOINT:\n      this.renderMidpointIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_CIRCLE_CENTER:\n      this.renderCircleIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_EDGE:\n    case SnapType.SNAP_CURVEDEDGE:\n      this.renderEdgeIndicator(snapResult);\n      break;\n\n    case SnapType.SNAP_CIRCULARARC:\n      if (this.viewer.model.is2d()) {\n        this.renderVertexIndicator(snapResult);\n      } else {\n        this.renderCircleIndicator(snapResult);\n      }\n      break;\n\n    case SnapType.SNAP_FACE:\n    case SnapType.SNAP_CURVEDFACE:\n      this.renderVertexIndicator(snapResult);\n      break;\n\n    case SnapType.RASTER_PIXEL:\n      this.renderPixelIndicator(snapResult);\n      break;}\n\n};\n\nproto.drawLine = function (geom, material, width, overlayName) {\n\n  // Line Pieces\n  if (overlayName === GEOMETRIES_OVERLAY) {\n    this.overlayType = EDGE_OVERLAY;\n  }\n\n  for (var i = 0; i < geom.vertices.length; i += 2) {\n    var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n    this.setEdgeScale(cylinder);\n    this.addOverlay(overlayName, cylinder);\n  }\n};\n\nproto.drawPoint = function (point, material, overlayName) {\n\n  // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n  if (this.viewer.model.getData().isLeaflet) {\n    return;\n  }\n\n  if (!_point)\n  _point = new THREE.SphereGeometry(1.0);\n\n  var pointMesh = new THREE.Mesh(_point, material);\n  pointMesh.position.set(point.x, point.y, point.z);\n\n  this.setPointScale(pointMesh);\n\n  if (overlayName === GEOMETRIES_OVERLAY) {\n    this.overlayType = POINT_OVERLAY;\n  }\n\n  this.addOverlay(overlayName, pointMesh);\n\n};\n\nproto.drawCircle = function (point, material, overlayName) {\n\n  var torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n  var torusMesh = new THREE.Mesh(torus, material);\n  torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n  torus = null;\n\n  torusMesh.position.set(point.x, point.y, point.z);\n\n  this.setCircleScale(torusMesh);\n\n  this.addOverlay(overlayName, torusMesh);\n\n};\n\nproto.setScale = function (point) {\n\n  var pixelSize = 5;\n\n  var navapi = this.viewer.navigation;\n  var camera = navapi.getCamera();\n  var position = navapi.getPosition();\n\n  var p = point.clone();\n\n  var distance = camera.isPerspective ? p.sub(position).length() :\n  navapi.getEyeVector().length();\n\n  var fov = navapi.getVerticalFov();\n  var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n  var viewport = navapi.getScreenViewport();\n  var scale = pixelSize * worldHeight / viewport.height;\n\n  return scale;\n\n};\n\nproto.setPointScale = function (pointMesh) {\n\n  var scale = this.setScale(pointMesh.position);\n  pointMesh.scale.x = scale;\n  pointMesh.scale.y = scale;\n  pointMesh.scale.z = scale;\n\n};\n\nproto.setCircleScale = function (torusMesh) {\n\n  var scale = this.setScale(torusMesh.position);\n  torusMesh.scale.x = scale;\n  torusMesh.scale.y = scale;\n};\n\nproto.setEdgeScale = function (cylinderMesh) {\n\n  var scale = this.setScale(cylinderMesh.position);\n  cylinderMesh.scale.x = scale;\n  cylinderMesh.scale.z = scale;\n};\n\nproto.updatePointScale = function (overlayName) {\n\n  if (this.overlayType != POINT_OVERLAY)\n  return;\n\n  var overlay = this.viewer.impl.overlayScenes[overlayName];\n  if (overlay) {\n    var scene = overlay.scene;\n\n    for (var i = 0; i < scene.children.length; i++) {\n      var pointMesh = scene.children[i];\n      if (pointMesh) {\n\n        this.setPointScale(pointMesh);\n      }\n    }\n  }\n};\n\nproto.updateEdgeScale = function (overlayName) {\n\n  if (this.overlayType != EDGE_OVERLAY)\n  return;\n\n  var overlay = this.viewer.impl.overlayScenes[overlayName];\n  if (overlay) {\n    var scene = overlay.scene;\n\n    for (var i = 0; i < scene.children.length; i++) {\n      var cylinderMesh = scene.children[i];\n      if (cylinderMesh) {\n\n        this.setEdgeScale(cylinderMesh);\n      }\n    }\n  }\n};\n\nproto.onCameraChange = function () {\n\n  this.updatePointScale(GEOMETRIES_OVERLAY);\n  this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n  // if (!this.snapper.markupMode) {\n  this.render();\n  // }\n};\n\nproto.destroy = function () {\n\n  this.removeOverlay(GEOMETRIES_OVERLAY);\n  this.removeOverlay(INDICATOR_OVERLAY);\n\n  if (_point) {\n    _point.dispose();\n    _point = null;\n  }\n};","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}\nvar av = Autodesk.Viewing;\n\n/**\n                            * @namespace Autodesk.Viewing.Extensions.Snapping\n                            */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\nfunction _export(m, ns) {\n  for (var prop in m) {\n    if (m.hasOwnProperty(prop)) {\n      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n      module.exports[prop] = m[prop];\n\n      //Export into the desired viewer namespace\n      ns[prop] = m[prop];\n    }\n  }\n}\n\n_export(require(\"./SnapMath.js\"), namespace);\n_export(require(\"./Snapper.js\"), namespace);\n_export(require(\"./SnapperIndicator.js\"), namespace);\n\n\n/**\n                                                       * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n                                                       * \n                                                       * The extension id is: `Autodesk.Snapping`\n                                                       * \n                                                       * @example\n                                                       *   viewer.loadExtension('Autodesk.Snapping')\n                                                       *  \n                                                       * @memberof Autodesk.Viewing.Extensions\n                                                       * @alias Autodesk.Viewing.Extensions.SnappingExtension\n                                                       * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                                       * @class\n                                                      */var\nSnappingExtension = /*#__PURE__*/function (_av$Extension) {\"use strict\";_inherits(SnappingExtension, _av$Extension);\n\n  /**\n                                                                                                                      * @alias Autodesk.Viewing.Extensions.SnappingExtension\n                                                                                                                      * @constructor\n                                                                                                                      */\n  function SnappingExtension(viewer, options) {_classCallCheck(this, SnappingExtension);return _possibleConstructorReturn(this, _getPrototypeOf(SnappingExtension).call(this,\n    viewer, options));\n  }\n\n  /**\n     * Load the extension.\n     *\n     * @returns {Promise} that resolves when dependent extension finishes loading.\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n    */_createClass(SnappingExtension, [{ key: \"load\", value: function load()\n    {\n      // Load the required dependency (and return the pending load as the load completion Promise)\n      return this.viewer.loadExtension('Autodesk.CompGeom');\n    }\n\n    /**\n       * Unloads the extension.\n       * It does not unload dependent extensions.\n       *\n       * @returns {boolean} Always returns true\n       * \n       * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n      */ }, { key: \"unload\", value: function unload()\n    {return true;}\n\n\n    /**\n                    * Unused method.\n                    *\n                    * @returns {boolean} Always returns true\n                    * \n                    * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n                   */ }, { key: \"activate\", value: function activate()\n    {return true;}\n\n    /**\n                    * Unused method.\n                    *\n                    * @returns {boolean} Always returns false\n                    * \n                    * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n                   */ }, { key: \"deactivate\", value: function deactivate()\n    {return false;} }]);return SnappingExtension;}(av.Extension);\n\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","\nexport function getGlobal() {\n  return typeof window !== \"undefined\" && window !== null ?\n  window :\n  typeof self !== \"undefined\" && self !== null ?\n  self :\n  global;\n}\n\nvar _window = getGlobal();\nvar _document = _window && _window.document;\n\nexport var isBrowser = typeof navigator !== \"undefined\";\n\nexport var isNodeJS = function isNodeJS() {\n  return !isBrowser;\n};\n\nexport var isIE11 = isBrowser && !!navigator.userAgent.match(/Edge|Trident\\/7\\./);\n\n// fix IE events\nif (typeof window !== \"undefined\" && isIE11) {\n  (function () {\n    function CustomEvent(event, params) {\n      params = params || { bubbles: false, cancelable: false, detail: undefined };\n      var evt = _document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = _window.CustomEvent.prototype;\n\n    _window.CustomEvent = CustomEvent;\n  })();\n}\n\n// IE does not implement ArrayBuffer slice. Handy!\nif (!ArrayBuffer.prototype.slice) {\n  ArrayBuffer.prototype.slice = function (start, end) {\n    // Normalize start/end values\n    if (!end || end > this.byteLength) {\n      end = this.byteLength;\n    } else\n    if (end < 0) {\n      end = this.byteLength + end;\n      if (end < 0) end = 0;\n    }\n    if (start < 0) {\n      start = this.byteLength + start;\n      if (start < 0) start = 0;\n    }\n\n    if (end <= start) {\n      return new ArrayBuffer();\n    }\n\n    // Bytewise copy- this will not be fast, but what choice do we have?\n    var len = end - start;\n    var view = new Uint8Array(this, start, len);\n    var out = new Uint8Array(len);\n    for (var i = 0; i < len; i++) {\n      out[i] = view[i];\n    }\n    return out.buffer;\n  };\n}\n\n// IE doesn't implement Math.log2\n(function () {\n  Math.log2 = Math.log2 || function (x) {\n    return Math.log(x) / Math.LN2;\n  };\n})();\n\n//The BlobBuilder object\nif (typeof window !== \"undefined\")\n_window.BlobBuilder = _window.BlobBuilder || _window.WebKitBlobBuilder || _window.MozBlobBuilder || _window.MSBlobBuilder;\n\n\n// Launch full screen on the given element with the available method\nexport function launchFullscreen(element, options) {\n  if (element.requestFullscreen) {\n    element.requestFullscreen(options);\n  } else if (element.mozRequestFullScreen) {\n    element.mozRequestFullScreen(options);\n  } else if (element.webkitRequestFullscreen) {\n    element.webkitRequestFullscreen(options);\n  } else if (element.msRequestFullscreen) {\n    element.msRequestFullscreen(options);\n  }\n};\n\n// Exit full screen with the available method\nexport function exitFullscreen(_document) {\n  if (!inFullscreen(_document)) {\n    return;\n  }\n  if (_document.exitFullscreen) {\n    _document.exitFullscreen();\n  } else if (_document.mozCancelFullScreen) {\n    _document.mozCancelFullScreen();\n  } else if (_document.webkitExitFullscreen) {\n    _document.webkitExitFullscreen();\n  } else if (_document.msExitFullscreen) {\n    _document.msExitFullscreen();\n  }\n};\n\n// Determines if the browser is in full screen\nexport function inFullscreen(_document) {\n\n  // Special case for Ms-Edge that has webkitIsFullScreen with correct value\n  // and fullscreenEnabled with wrong value (thanks MS)\n\n  if (\"webkitIsFullScreen\" in _document) return !!_document.webkitIsFullScreen;\n  if (\"fullscreenElement\" in _document) return !!_document.fullscreenElement;\n  if (\"mozFullScreenElement\" in _document) return !!_document.mozFullScreenElement;\n  if (\"msFullscreenElement\" in _document) return !!_document.msFullscreenElement;\n\n  return !!_document.querySelector(\".viewer-fill-browser\"); // Fallback for iPad\n};\n\nexport function fullscreenElement(_document) {\n  return _document.fullscreenElement || _document.mozFullScreenElement || _document.webkitFullscreenElement || _document.msFullscreenElement;\n};\n\nexport function isFullscreenAvailable(element) {\n  return element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;\n};\n\n// Get the version of the android device through user agent.\n// Return the version string of android device, e.g. 4.4, 5.0...\nexport function getAndroidVersion(ua) {\n  ua = ua || navigator.userAgent;\n  var match = ua.match(/Android\\s([0-9\\.]*)/);\n  return match ? match[1] : false;\n};\n\n// Determine if this is a touch or notouch device.\nexport function isTouchDevice() {\n  /*\n                                 // Temporarily disable touch support through hammer on Android 5, to debug\n                                 // some specific gesture issue with Chromium WebView when loading viewer3D.js.\n                                 if (parseInt(getAndroidVersion()) == 5) {\n                                     return false;\n                                 }\n                                 */\n\n  return typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0);\n};\n\n// Since iOS 13, the iPad identifies itself as a desktop, so the only way to reliably detect is to search for multitouch capabilities\n// (insofar as no other Apple device implements it)\nvar _isIOSDevice = isBrowser && (/ip(ad|hone|od)/.test(navigator.userAgent.toLowerCase()) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\nexport function isIOSDevice() {\n  return _isIOSDevice;\n}\n\nvar _isAndroidDevice = isBrowser && navigator.userAgent.toLowerCase().indexOf('android') !== -1;\nexport function isAndroidDevice() {\n  return _isAndroidDevice;\n}\n\nexport function isMobileDevice() {\n  if (!isBrowser) return false;\n  return isIOSDevice() || isAndroidDevice();\n};\n\nexport function isSafari() {\n  if (!isBrowser) return false;\n  var _ua = navigator.userAgent.toLowerCase();\n  return _ua.indexOf(\"safari\") !== -1 && _ua.indexOf(\"chrome\") === -1;\n};\n\nexport function isFirefox() {\n  if (!isBrowser) return false;\n  var _ua = navigator.userAgent.toLowerCase();\n  return _ua.indexOf(\"firefox\") !== -1;\n};\n\nexport function isChrome() {\n  if (!isBrowser) return false;\n  var _ua = navigator.userAgent.toLowerCase();\n  return _ua.indexOf(\"chrome\") !== -1;\n};\n\nexport function isMac() {\n  if (!isBrowser) return false;\n  var _ua = navigator.userAgent.toLowerCase();\n  return _ua.indexOf(\"mac os\") !== -1;\n};\n\nexport function isWindows() {\n  if (!isBrowser) return false;\n  var _ua = navigator.userAgent.toLowerCase();\n  return _ua.indexOf(\"win32\") !== -1 || _ua.indexOf(\"windows\") !== -1;\n};\n\nexport function ObjectAssign(des, src) {\n  for (var key in src) {\n    if (src.hasOwnProperty(key))\n    des[key] = src[key];\n  }\n  return des;\n};\n\n\n// Hack to work around Safari's use of pinch and pan inside the viewer canvas.\nfunction disableTouchSafari(event) {\n  var xOff = _window.hasOwnProperty(\"pageXOffset\") ? _window.pageXOffset : _document.documentElement.scrollLeft;\n  var yOff = _window.hasOwnProperty(\"pageYOffset\") ? _window.pageYOffset : _document.documentElement.scrollTop;\n\n  // event.pageX and event.pageY returned undefined through Chrome console device mode\n  var pageX = typeof event.pageX === \"undefined\" ? event.changedTouches[0].pageX : event.pageX;\n  var pageY = typeof event.pageY === \"undefined\" ? event.changedTouches[0].pageY : event.pageY;\n\n  // If we aren't inside the canvas, then allow default propagation of the event\n  var element = _document.elementFromPoint(pageX - xOff, pageY - yOff);\n  if (!element || element.nodeName !== 'CANVAS')\n  return true;\n  // If it's a CANVAS, check that it's owned by us\n  if (element.getAttribute('data-viewer-canvas' !== 'true'))\n  return true;\n  // Inside the canvas, prevent the event from propagating to Safari'safely\n  // standard handlers, which will pan and zoom the page.\n  event.preventDefault();\n  return false;\n};\n\n// Hack to work around Safari's use of pinch and pan inside the viewer canvas.\nexport function disableDocumentTouchSafari() {\n  if (isMobileDevice() && isSafari()) {\n    // Safari mobile disable default touch handling inside viewer canvas\n    // Use capture to make sure Safari doesn't capture the touches and prevent\n    // us from disabling them.\n    _document.documentElement.addEventListener('touchstart', disableTouchSafari, true);\n    _document.documentElement.addEventListener('touchmove', disableTouchSafari, true);\n    _document.documentElement.addEventListener('touchcanceled', disableTouchSafari, true);\n    _document.documentElement.addEventListener('touchend', disableTouchSafari, true);\n  }\n};\n\n// Hack to work around Safari's use of pinch and pan inside the viewer canvas.\n// This method is not being invoked explicitly.\nexport function enableDocumentTouchSafari() {\n  if (isMobileDevice() && isSafari()) {\n    // Safari mobile disable default touch handling inside viewer canvas\n    // Use capture to make sure Safari doesn't capture the touches and prevent\n    // us from disabling them.\n    _document.documentElement.removeEventListener('touchstart', disableTouchSafari, true);\n    _document.documentElement.removeEventListener('touchmove', disableTouchSafari, true);\n    _document.documentElement.removeEventListener('touchcanceled', disableTouchSafari, true);\n    _document.documentElement.removeEventListener('touchend', disableTouchSafari, true);\n  }\n};\n\n\n// Convert touchstart event to click to remove the delay between the touch and\n// the click event which is sent after touchstart with about 300ms deley.\n// Should be used in UI elements on touch devices.\nexport function touchStartToClick(e) {\n  // Buttons that activate fullscreen are a special case. The HTML5 fullscreen spec\n  // requires the original user gesture signal to avoid a security issue.  See LMV-2396 and LMV-2326\n  if (e.target.className && (e.target.className.indexOf(\"fullscreen\") > -1 || e.target.className.indexOf(\"webvr\") > -1))\n  return;\n  e.preventDefault(); // Stops the firing of delayed click event.\n  e.stopPropagation();\n  e.target.click(); // Maps to immediate click.\n}\n\n//Safari doesn't have the Performance object\n//We only need the now() function, so that's easy to emulate.\n(function () {\n  var global = getGlobal();\n  if (!global.performance)\n  global.performance = Date;\n})();\n\n// Polyfill for IE and Safari\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function (value) {\n  return typeof value === \"number\" &&\n  isFinite(value) &&\n  Math.floor(value) === value;\n};\n\n// Polyfill for IE\nString.prototype.repeat = String.prototype.repeat || function (count) {\n  if (count < 1) return '';\n  var result = '',pattern = this.valueOf();\n  while (count > 1) {\n    if (count & 1) result += pattern;\n    count >>= 1, pattern += pattern;\n  }\n  return result + pattern;\n};\n\n// Polyfill for IE\n// It doesn't support negative values for start and end; it complicates the code using this function.\nif (!Array.prototype.fill) {\n  Object.defineProperty(Array.prototype, \"fill\", {\n    enumerable: false,\n    value: function value(_value, start, end) {\n      start = start === undefined ? 0 : start;\n      end = end === undefined ? this.length : end;\n      for (var i = start; i < end; ++i) {\n        this[i] = _value;}\n    } });\n\n}\n// Polyfill for IE\nInt32Array.prototype.lastIndexOf = Int32Array.prototype.lastIndexOf || function (searchElement, fromIndex) {\n  return Array.prototype.lastIndexOf.call(this, searchElement, fromIndex);\n};\n\n// Polyfill for IE\n// It doesn't support negative values for start and end; it complicates the code using this function.\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, \"find\", {\n    enumerable: false,\n    value: function value(callback, _this) {\n      var len = this.length;\n      for (var i = 0; i < len; ++i) {\n        var item = this[i];\n        if (callback.call(_this, item, i, this))\n        return item;\n      }\n      return undefined;\n    } });\n\n}\n\n// Polyfill for IE\nif (typeof Object.assign != 'function') {\n  // Must be writable: true, enumerable: false, configurable: true\n  Object.defineProperty(Object, \"assign\", {\n    value: function assign(target, varArgs) {// .length of function is 2\n      'use strict';\n      if (target == null) {// TypeError if undefined or null\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) {// Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    },\n    writable: true,\n    configurable: true });\n\n}\n\n// Polyfill for IE and iOS devices\nif (typeof window !== \"undefined\" && (isIE11 || isIOSDevice()) && !HTMLCanvasElement.prototype.toBlob) {\n  Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n    value: function value(callback, type, quality) {\n      var canvas = this;\n      setTimeout(function () {\n\n        var binStr = atob(canvas.toDataURL(type, quality).split(',')[1]),\n        len = binStr.length,\n        arr = new Uint8Array(len);\n\n        for (var i = 0; i < len; i++) {\n          arr[i] = binStr.charCodeAt(i);\n        }\n\n        callback(new Blob([arr], { type: type || 'image/png' }));\n\n      });\n    } });\n\n}\n\n// Polyfill for IE (LMV-3823)\nif (!Uint8Array.prototype.slice) {\n\n  // This will work for genuine arrays, array-like objects, \n  // NamedNodeMap (attributes, entities, notations),\n  // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),\n  // and will not fail on other DOM objects (as do DOM elements in IE < 9)\n  Uint8Array.prototype.slice = function (begin, end) {\n    // IE < 9 gets unhappy with an undefined end argument\n    end = typeof end !== 'undefined' ? end : this.length;\n\n    // For native Array objects, we use the native slice function\n    if (Object.prototype.toString.call(this) === '[object Array]') {\n      return _slice.call(this, begin, end);\n    }\n\n    // For array like object we handle it ourselves.\n    var i,cloned = [],\n    size,len = this.length;\n\n    // Handle negative value for \"begin\"\n    var start = begin || 0;\n    start = start >= 0 ? start : Math.max(0, len + start);\n\n    // Handle negative value for \"end\"\n    var upTo = typeof end == 'number' ? Math.min(end, len) : len;\n    if (end < 0) {\n      upTo = len + end;\n    }\n\n    // Actual expected size of the slice\n    size = upTo - start;\n\n    if (size > 0) {\n      cloned = new Array(size);\n      if (this.charAt) {\n        for (i = 0; i < size; i++) {\n          cloned[i] = this.charAt(start + i);\n        }\n      } else {\n        for (i = 0; i < size; i++) {\n          cloned[i] = this[start + i];\n        }\n      }\n    }\n\n    return cloned;\n  };\n}","\n\"use strict\";\n\nimport * as THREE from \"three\";\n\nvar TAU = Math.PI * 2;\n\n//Constants duplicated from src/lmvtk/VertexBufferBuilder.js\nvar VBB_GT_TRIANGLE_INDEXED = 0,\nVBB_GT_LINE_SEGMENT = 1,\nVBB_GT_ARC_CIRCULAR = 2,\nVBB_GT_ARC_ELLIPTICAL = 3,\nVBB_GT_TEX_QUAD = 4,\nVBB_GT_ONE_TRIANGLE = 5;\n\nvar VBB_INSTANCED_FLAG = 0, // this is intentionally 0 for the instancing case!\nVBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!\nVBB_SEG_START_LEFT = 1,\nVBB_SEG_END_RIGHT = 2,\nVBB_SEG_END_LEFT = 3;\n\nvar VBB_COLOR_OFFSET = 6,\nVBB_DBID_OFFSET = 7,\nVBB_FLAGS_OFFSET = 8,\nVBB_LAYER_VP_OFFSET = 9;\n\n/**\n                          * Initializes a \"view\" into a compacted interleaved vertex buffer array using our custom 2D vertex layout.\n                          * See src/lmvtk/VertexBufferBuilder.js for more details.\n                          */\nexport function VertexBufferReader(geometry)\n{\n  this.vb = geometry.vb.buffer;\n  this.vbf = new Float32Array(this.vb);\n  this.vbi = new Int32Array(this.vb);\n  this.vbs = new Uint16Array(this.vb);\n\n  this.ib = geometry.ib;\n\n  this.stride = geometry.vbstride;\n  this.vcount = this.vbf.length / this.stride;\n\n  this.useInstancing = geometry.numInstances > 0;\n  this.useCompactBuffers = geometry.unpackXform;\n  this.texData = this.useCompactBuffers && geometry.tIdColor && geometry.tIdColor.image && geometry.tIdColor.image.data && new Uint32Array(geometry.tIdColor.image.data.buffer);\n};\n\nVertexBufferReader.prototype.getDbIdAt = function (vindex) {\n  if (this.texData) {\n    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_DBID_OFFSET]];\n  }\n  return this.vbi[vindex * this.stride + VBB_DBID_OFFSET];\n};\n\nVertexBufferReader.prototype.getColorAt = function (vindex) {\n  if (this.texData) {\n    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_COLOR_OFFSET]];\n  }\n  return this.vbi[vindex * this.stride + VBB_COLOR_OFFSET];\n};\n\nVertexBufferReader.prototype.getVertexFlagsAt = function (vindex) {\n  if (this.texData) {\n    return this.vbi[vindex * this.stride + 4];\n  }\n  return this.vbi[vindex * this.stride + VBB_FLAGS_OFFSET];\n};\n\nVertexBufferReader.prototype.getLayerIndexAt = function (vindex) {\n  if (this.texData) {\n    return this.vbi[vindex * this.stride + 5] & 0xffff;\n  }\n  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] & 0xffff;\n};\n\nVertexBufferReader.prototype.getViewportIndexAt = function (vindex) {\n  if (this.texData) {\n    return this.vbi[vindex * this.stride + 5] >> 16 & 0xffff;\n  }\n  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] >> 16 & 0xffff;\n};\n\nVertexBufferReader.prototype.decodeLineAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onLineSegment) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var x0 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y0 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var angle = this.vbs[vertexOffset + 2] / 65535 * TAU - Math.PI;\n    var distAlong = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n    var lineWidth = this.vbs[vertexOffset + 4] / 32767 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y) * 2.0;\n  } else {\n    var baseOffset = this.stride * vindex;\n    var x0 = this.vbf[baseOffset];\n    var y0 = this.vbf[baseOffset + 1];\n    var angle = this.vbf[baseOffset + 2] * TAU - Math.PI; // decode angle: see VertexBufferBuilder.addVertexLine\n    var distAlong = this.vbf[baseOffset + 3];\n    var lineWidth = this.vbf[baseOffset + 4] * 2.0;\n  }\n\n  var x1 = x0 + distAlong * Math.cos(angle);\n  var y1 = y0 + distAlong * Math.sin(angle);\n\n  callback.onLineSegment(x0, y0, x1, y1, vpId, lineWidth);\n};\n\nVertexBufferReader.prototype.decodeCircularArcAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onCircularArc) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var cx = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var cy = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var start = this.vbs[vertexOffset + 2] / 65535 * TAU;\n    var end = this.vbs[vertexOffset + 3] / 65535 * TAU;\n    var radius = this.vbs[vertexOffset + 5] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n  } else {\n    var baseOffset = this.stride * vindex;\n    var cx = this.vbf[baseOffset];\n    var cy = this.vbf[baseOffset + 1];\n    var start = this.vbf[baseOffset + 2] * TAU;\n    var end = this.vbf[baseOffset + 3] * TAU;\n    var radius = this.vbf[baseOffset + 5];\n  }\n\n  callback.onCircularArc(cx, cy, start, end, radius, vpId);\n};\n\nVertexBufferReader.prototype.decodeEllipticalArcAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onEllipticalArc) {return;}\n\n  // Note: compaction will not happen for the VBB_GT_ARC_ELLIPTICAL\n  var baseOffset = this.stride * vindex;\n  var cx = this.vbf[baseOffset];\n  var cy = this.vbf[baseOffset + 1];\n  var start = this.vbf[baseOffset + 2] * TAU;\n  var end = this.vbf[baseOffset + 3] * TAU;\n  var major = this.vbf[baseOffset + 5];\n  var minor = this.vbf[baseOffset + 10];\n  var tilt = this.vbf[baseOffset + 11];\n\n  callback.onEllipticalArc(cx, cy, start, end, major, minor, tilt, vpId);\n};\n\nVertexBufferReader.prototype.decodeTexQuadAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onTexQuad) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var centerX = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var centerY = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var rotation = this.vbs[vertexOffset + 2] / 65535 * TAU;\n    var width = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n    var height = this.vbs[vertexOffset + 4] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n  } else {\n    var baseOffset = this.stride * vindex;\n    var centerX = this.vbf[baseOffset];\n    var centerY = this.vbf[baseOffset + 1];\n    // yes, this is in a different order than output, following VertexBufferBuilder's order\n    var rotation = this.vbf[baseOffset + 2] * TAU;\n    var width = this.vbf[baseOffset + 3];\n    var height = this.vbf[baseOffset + 4];\n  }\n\n  callback.onTexQuad(centerX, centerY, width, height, rotation, vpId);\n};\n\nVertexBufferReader.prototype.decodeOneTriangleAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onOneTriangle) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset + 2] / 65535 + this.useCompactBuffers.z;\n    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 3] / 65535 + this.useCompactBuffers.w;\n    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset + 4] / 65535 + this.useCompactBuffers.z;\n    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 5] / 65535 + this.useCompactBuffers.w;\n  } else {\n    var baseOffset = this.stride * vindex;\n    var x1 = this.vbf[baseOffset];\n    var y1 = this.vbf[baseOffset + 1];\n    var x2 = this.vbf[baseOffset + 2];\n    var y2 = this.vbf[baseOffset + 3];\n    var x3 = this.vbf[baseOffset + 4];\n    var y3 = this.vbf[baseOffset + 5];\n  }\n\n  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\n};\n\n\nVertexBufferReader.prototype.decodeTriangleIndexed = function (vi0, vi1, vi2, layer, vpId, callback)\n{\n  if (!callback.onOneTriangle) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vi0 * 2;\n    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n\n    vertexOffset = this.stride * vi1 * 2;\n    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n\n    vertexOffset = this.stride * vi2 * 2;\n    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n  } else {\n    var baseOffset = this.stride * vi0;\n    var x1 = this.vbf[baseOffset];\n    var y1 = this.vbf[baseOffset + 1];\n\n    baseOffset = this.stride * vi1;\n    var x2 = this.vbf[baseOffset];\n    var y2 = this.vbf[baseOffset + 1];\n\n    baseOffset = this.stride * vi2;\n    var x3 = this.vbf[baseOffset];\n    var y3 = this.vbf[baseOffset + 1];\n  }\n\n  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\n};\n\n\n// used by the snapper and by the bounds finder\nVertexBufferReader.prototype.enumGeomsForObject = function (dbId, callback)\n{\n  if (this.useInstancing) {\n\n    //When instancing is used, each geometry primitive is encoded into a single vertex\n    //and there is no index buffer.\n\n    var i = 0;\n    while (i < this.vcount) {\n      var flag = this.getVertexFlagsAt(i);\n\n      //var vertexId  = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;      //  8 bit\n      var layerId = this.getLayerIndexAt(i); // 16 bit\n      var vpId = this.getViewportIndexAt(i); // 16 bit     \n      var visible = this.getDbIdAt(i) === dbId;\n      if (visible) {\n        switch (geomType) {\n          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break; //  compaction is not performed\n          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;\n          default:break;}\n\n      }\n\n      //In the case of instancing, there is no vertex duplication and no index buffer, we just\n      //move to the next vertex\n      i += 1;\n    }\n  } else {\n\n    var i = 0;\n    while (i < this.ib.length) {\n      var vi = this.ib[i];\n      var flag = this.getVertexFlagsAt(vi);\n\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n      var layerId = this.getLayerIndexAt(vi); // 16 bit\n      var vpId = this.getViewportIndexAt(vi); // 16 bit\n\n      var visible = this.getDbIdAt(vi) === dbId;\n\n      if (geomType === VBB_GT_TRIANGLE_INDEXED) {\n\n        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\n\n        if (visible) {\n          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);\n        }\n\n        //Advance to the next primitive\n        i += 3;\n\n      } else {\n\n        if (visible) {\n          switch (geomType) {\n            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;\n            default:break;}\n\n        }\n\n        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\n        //each vertex is listed four times with a different vertexId flag\n        i += 6;\n      }\n\n\n    }\n  }\n\n};\n\n\n/**\n    * Used by the bounds finder.\n    * @param {array[number]} layerIdsVisible - list of layer ids that are visible\n    * @param {function} callback\n    * @private\n    */\nVertexBufferReader.prototype.enumGeomsForVisibleLayer = function (layerIdsVisible, callback)\n{\n  var filter = function filter(dbId, layerId, viewportId) {\n    return !layerIdsVisible || layerId !== 0 && layerIdsVisible.indexOf(layerId) !== -1;\n  };\n  this.enumGeoms(filter, callback);\n};\n\n\n/**\n    * Enumerate all geometric primitives that match the given filter.\n    * @param {function} [filter] - function(dbId, layerId, viewportId): Filter function to define a subset of primitives to include. By default, all geometry is included.\n    * @param {function} callback\n    * @private\n    */\nVertexBufferReader.prototype.enumGeoms = function (filter, callback)\n{\n  if (this.useInstancing) {\n\n    //When instancing is used, each geometry primitive is encoded into a single vertex\n    //and there is no index buffer.\n\n    var i = 0;\n    while (i < this.vcount) {\n      var flag = this.getVertexFlagsAt(i);\n\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n      var layerId = this.getLayerIndexAt(i); // 16 bit\n      var vpId = this.getViewportIndexAt(i); // 16 bit\n      var dbId = this.getDbIdAt(i);\n\n      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\n      // If layerId visibility is not set, consider the layer visible.\n      var visible = !filter || filter(dbId, layerId, vpId);\n      if (visible) {\n        switch (geomType) {\n          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break;\n          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;\n          default:break;}\n\n      }\n\n      //In the case of instancing, there is no vertex duplication and no index buffer, we just\n      //move to the next vertex\n      i += 1;\n    }\n  } else {\n\n    var i = 0;\n    while (i < this.ib.length) {\n      var vi = this.ib[i];\n      var flag = this.getVertexFlagsAt(vi);\n\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n      var layerId = this.getLayerIndexAt(vi); // 16 bit\n      var vpId = this.getViewportIndexAt(vi); // 16 bit\n      var dbId = this.getDbIdAt(vi);\n\n      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\n      // If layerId visibility is not set, consider the layer visible.\n      var visible = !filter || filter(dbId, layerId, vpId);\n\n      if (geomType === VBB_GT_TRIANGLE_INDEXED) {\n\n        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\n\n        if (visible) {\n          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);\n        }\n\n        //Advance to the next primitive\n        i += 3;\n\n      } else {\n\n        if (visible) {\n          switch (geomType) {\n            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;\n            default:break;}\n\n        }\n\n        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\n        //each vertex is listed four times with a different vertexId flag\n        i += 6;\n      }\n\n    }\n  }\n\n};\n\n\n\n/**\n    * Callback class for calculating bounds of 2D objects via VertexBufferReader\n    * @private\n    */\nexport function BoundsCallback(bounds) {\n  this.bounds = bounds;\n  // workspace, so we don't reallocate this each time\n  this.point = new THREE.Vector4();\n  this.point.z = 0.0;\n  this.point.w = 1.0; // it's a point, not a vector\n}\n\nBoundsCallback.prototype.onVertex = function (cx, cy, vpId) {\n  this.point.x = cx;\n  this.point.y = cy;\n  this.bounds.expandByPoint(this.point);\n};\n\nBoundsCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {\n  this.onVertex(x1, y1);\n  this.onVertex(x2, y2);\n};\n\nBoundsCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {\n  this.onEllipticalArc(cx, cy, start, end, radius, radius, 0.0, vpId);\n};\n\nBoundsCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {\n  if (tilt == 0.0) {\n    // does start and end make a full ellipse?\n    if (start <= 0 && end >= 2.0 * Math.PI - 0.00001) {\n      // full way around, simply treat it like a rectangle\n      this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);\n    } else {\n      // Not a full ellipse. We take the start and end points and also figure\n      // out the four \"compass rose\" points that are between these two locations.\n      // The start and end locations often exist as separate vertices so would\n      // already be included, but for some line types they may not exist, so we\n      // include them here.\n      this.point.x = cx + Math.cos(start) * major;\n      this.point.y = cy + Math.sin(start) * minor;\n      this.bounds.expandByPoint(this.point);\n      this.point.x = cx + Math.cos(end) * major;\n      this.point.y = cy + Math.sin(end) * minor;\n      this.bounds.expandByPoint(this.point);\n\n      // now check each NESW compass point, i.e., middle of each edge\n      if (start > end) {\n        // add right edge\n        this.point.x = cx + major;\n        this.point.y = cy;\n        this.bounds.expandByPoint(this.point);\n        // make start < end for the rest of the tests\n        start -= 2.0 * Math.PI;\n      }\n      if (start < 0.5 * Math.PI && end > 0.5 * Math.PI) {\n        // add top edge\n        this.point.x = cx;\n        this.point.y = cy + minor;\n        this.bounds.expandByPoint(this.point);\n      }\n      if (start < Math.PI && end > Math.PI) {\n        // add left edge\n        this.point.x = cx - major;\n        this.point.y = cy;\n        this.bounds.expandByPoint(this.point);\n      }\n      if (start < 1.5 * Math.PI && end > 1.5 * Math.PI) {\n        // add bottom edge\n        this.point.x = cx;\n        this.point.y = cy - minor;\n        this.bounds.expandByPoint(this.point);\n      }\n    }\n  } else {\n    // Has a tilt.\n    // From what we see, you should never reach here, as tilted ellipses are actually\n    // always tessellated. So, we do a fallback: call the onTexQuad with the rotation.\n    // This call will be a pretty good approximation, putting a rotated bounding box\n    // around the whole ellipse. For more accuracy you would need to tessellate the\n    // ellipse and get its points (especially if you don't have a full ellipse).\n    this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);\n\n    // does start and end make a full ellipse?\n    //if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {\n    //}\n  }\n};\n\n// Currently this case does not actually come up, as textured quads, i.e., images, are\n// not something that can be selected, from what data I have tried. So I have not spent\n// any time on the rotated case.\n// TODO: this code is only partially tested: I had problems getting a selectable raster\n// object in a DWG convert to an F2D.\nBoundsCallback.prototype.onTexQuad = function (centerX, centerY, width, height, rotation, vpId) {\n  var halfWidth = 0.5 * width;\n  var halfHeight = 0.5 * width;\n  if (rotation == 0.0) {\n    this.onVertex(centerX - halfWidth, centerY - halfHeight);\n    this.onVertex(centerX + halfWidth, centerY + halfHeight);\n  } else {\n    // A more complex rectangle, rotated. Take the four corners and rotate each\n    // around the center.\n    var rmtx = new THREE.Matrix4(); // Matrix3() does not have enough helper methods\n    var mtx = new THREE.Matrix4();\n    // Take a rectangle centered at the origin, rotate it, translate it to the final\n    // position. Each corner is added to the bounds.\n    rmtx.makeRotationZ(rotation);\n    // put it into the final position:\n    mtx.makeTranslation(centerX, centerY, 0.0);\n    mtx.multiply(rmtx);\n\n    for (var i = 0; i < 4; i++) {\n      this.point.x = i % 2 == 1 ? halfWidth : -halfWidth;\n      this.point.y = i >= 2 ? halfHeight : -halfHeight;\n      this.point.applyMatrix4(mtx);\n      this.bounds.expandByPoint(this.point);\n    }\n  }\n};\n\nBoundsCallback.prototype.onOneTriangle = function (x1, y1, x2, y2, x3, y3, vpId) {\n  this.onVertex(x1, y1);\n  this.onVertex(x2, y2);\n  this.onVertex(x3, y3);\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChyDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjbA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;A","sourceRoot":""}