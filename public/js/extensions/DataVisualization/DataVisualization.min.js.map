{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/external \"THREE\"","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/node_modules/q/q.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/heatmap/SurfaceShadingData.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/module.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/SpriteMeshBuilder.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/node_modules/heatmap.js/build/heatmap.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/Constants.js","webpack://Autodesk.Extensions.[name]/./node_modules/maxrects-packer/dist/maxrects-packer.mjs","webpack://Autodesk.Extensions.[name]/./node_modules/process/browser.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js","webpack://Autodesk.Extensions.[name]/./node_modules/timers-browserify/main.js","webpack://Autodesk.Extensions.[name]/./node_modules/setimmediate/setImmediate.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/SceneTool.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/SpriteAtlas.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/CustomViewables.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/ModelStructureInfo.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/heatmap/HeatmapMaterial.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/heatmap/SurfaceShading.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/heatmap/PlanarHeatmap.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/TextureUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/heatmap/IDWDataProcessor.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/streamline/StreamLine.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/streamline/StreamLineMaterial.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/streamline/StreamLineShaders.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/streamline/StreamLineBuilder.js","webpack://Autodesk.Extensions.[name]/./extensions/DataVisualization/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THREE","definition","bootstrap","define","hasStacks","Error","e","stack","qFileName","qStartingLine","captureLine","noop","nextTick","head","task","next","tail","flushing","requestTick","isNodeJS","laterQueue","flush","domain","enter","runSingle","length","pop","exit","setTimeout","process","toString","setImmediate","window","MessageChannel","channel","port1","onmessage","requestPortTick","port2","postMessage","runAfter","push","Function","uncurryThis","f","apply","arguments","QReturnValue","array_slice","Array","slice","array_reduce","reduce","callback","basis","index","this","TypeError","array_indexOf","indexOf","array_map","map","thisp","self","collect","undefined","object_create","Type","object_defineProperty","obj","prop","descriptor","object_hasOwnProperty","object_keys","keys","object_toString","isStopIteration","exception","ReturnValue","makeStackTraceLong","error","promise","stacks","source","__minimumStackCounter__","stackCounter","configurable","unshift","stackString","lines","split","desiredLines","line","isInternalFrame","stackLine","join","filterStackString","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qEndingLine","Q","Promise","isPromiseAlike","deferred","defer","then","resolve","reject","notify","coerce","fulfill","longStackSupport","longStackCounter","resolvedPromise","messages","progressListeners","promiseDispatch","op","operands","args","valueOf","nearerValue","nearer","isPromise","inspect","state","substring","become","newPromise","message","reason","progress","progressListener","resolver","race","answerPs","len","fallback","result","inspected","when","fulfilled","rejected","progressed","env","Q_DEBUG","makeNodeResolver","all","passByCopy","x","y","that","spread","makePromise","done","_fulfilled","newException","_rejected","newValue","threw","_progressed","onerror","tap","fcall","thenResolve","thenReject","isPending","isFulfilled","isRejected","alternative","unhandledReasons","unhandledRejections","reportedUnhandledRejections","trackUnhandledRejections","resetUnhandledRejections","rejection","at","emit","atReport","splice","untrackRejection","trackRejection","rhs","dispatch","promises","pendingCount","snapshot","any","prev","current","err","allResolved","getUnhandledReasons","stopUnhandledRejectionTracking","master","array","async","makeGenerator","continuer","verb","arg","StopIteration","generator","errback","spawn","promised","set","del","mapply","post","send","mcall","invoke","fapply","fbind","concat","console","warn","allSettled","regardless","fail","fin","onUnhandledError","timeout","ms","timeoutId","code","clearTimeout","delay","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","nodeify","nodeback","noConflict","SurfaceShadingPoint","id","position","types","contextData","dbId","model","it","getData","instanceTree","bounds","Box3","fragBounds","fragList","getFragmentList","enumNodeFragments","fragId","getWorldBounds","union","getCenter","SurfaceShadingNode","dbIds","shadingPoints","isLeaf","fragIds","point","hashSet","Set","forEach","has","SurfaceShadingGroup","_children","isGroup","child","children","update","results","getChildLeafs","getLeafsById","getNodeById","SurfaceShadingData","filterShadingPointsByType","sensorType","filter","includes","webpackPolyfill","deprecate","paths","require","SpriteMeshBuilder","meshCallback","reset","viewable","spriteAtlas","vcount","flushBuffer","ib","vb","z","idb","colorb","color","g","b","uv","spriteUV","style","url","w","h","scale","Uint16Array","Uint8Array","MAX_VCOUNT","Float32Array","geometry","BufferGeometry","idAttribute","BufferAttribute","bytesPerItem","normalize","positionAttribute","colorAttribute","indexAttribute","uvAttribute","scaleAttribute","setAttribute","isPoints","factory","rendererFn","HeatmapConfig","defaultRadius","defaultRenderer","defaultGradient","0.25","0.55","0.85","1","defaultMaxOpacity","defaultMinOpacity","defaultBlur","defaultXField","defaultYField","defaultValueField","plugins","Store","config","_coordinator","_data","_radi","_min","_max","_xField","_yField","_valueField","_cfgRadius","_organiseData","dataPoint","forceRender","radi","store","max","min","radius","storedVal","setDataMax","setDataMin","_unOrganizeData","unorganizedData","data","_onExtremaChange","addData","dataArr","dataLen","organisedEntry","setData","dataPoints","pointsLen","_getInternalData","removeData","setCoordinator","coordinator","Canvas2dRenderer","_getColorPalette","gradientConfig","gradient","paletteCanvas","document","createElement","paletteCtx","getContext","width","height","createLinearGradient","addColorStop","fillStyle","fillRect","getImageData","_getPointTemplate","blurFactor","tplCanvas","tplCtx","beginPath","arc","Math","PI","fill","createRadialGradient","container","shadowCanvas","canvas","computed","_renderBoundaries","getComputedStyle","className","_width","replace","_height","shadowCtx","ctx","cssText","appendChild","_palette","_templates","_setStyles","renderPartial","_drawAlpha","_colorize","renderAll","_clear","renderData","xValues","xValuesLen","xValue","yValues","yValuesLen","yValue","_prepareData","_updateGradient","updateConfig","setDimensions","clearRect","_blur","blur","backgroundColor","_opacity","opacity","_maxOpacity","maxOpacity","_minOpacity","minOpacity","_useGradientOpacity","useGradientOpacity","tpl","rectX","rectY","templateAlpha","globalAlpha","drawImage","maxWidth","maxHeight","img","imgData","palette","finalAlpha","alpha","offset","putImageData","getValueAt","abs","getDataURL","toDataURL","Renderer","Util","merged","argsLen","Heatmap","Coordinator","cStore","on","evtName","scope","_connect","renderer","_renderer","_store","_config","onExtremaChange","pluginToLoad","plugin","configure","repaint","register","pluginKey","MOUSE_HOVERING","MOUSE_CLICK","MOUSE_CLICK_OUT","Rectangle","rot","allowRotation","oversized","_rot","_allowRotation","_dirty","_x","_y","first","second","collide","contain","rect","tmp","Bin","rects","some","dirty","setDirty","MaxRectsBin","EDGE_MAX_VALUE","padding","options","super","freeRects","verticalExpand","smart","pot","square","tag","exclusiveTag","border","logic","PACKING_LOGIC","MAX_EDGE","assign","stage","place","unpacked","sort","a","hash","deepReset","resetOption","clonedBin","add","node","findNode","updateBinSize","numRectToProcess","splitNode","pruneFreeList","areaFit","bestNode","score","MAX_VALUE","MAX_AREA","freeRect","usedNode","newNode","j","tmpRect1","tmpRect2","tmpWidth","tmpHeight","rotWidth","rotHeight","pow","ceil","log","LOG2E","expandFreeRects","OversizedElementBin","MaxRectsPacker","_currentBinIndex","bins","find","bin","currentTag","aTag","bTag","currentIdx","testBin","clone","addArray","quick","unpack","up","repack","allRects","newBin","saveBins","saveBin","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","run","marker","runClearTimeout","Item","title","browser","argv","version","versions","addListener","once","off","removeListener","removeAllListeners","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","Timeout","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","global","clearImmediate","registerImmediate","html","messagePrefix","onGlobalMessage","nextHandle","tasksByHandle","currentlyRunningATask","doc","attachTo","getPrototypeOf","handle","runIfPresent","importScripts","postMessageIsAsynchronous","oldOnMessage","canUsePostMessage","event","documentElement","script","onreadystatechange","removeChild","random","addEventListener","attachEvent","av","Autodesk","Viewing","GlobalManagerMixin","SceneTool","viewer","names","setGlobalManager","globalManager","delegate","init","hoveringDbId","selectedDbId","viewerImpl","impl","activate","deactivate","clearMarkedObject","handleSingleClick","button","isEventHandled","vpVec","clientToViewport","canvasX","canvasY","overlayIdTarget","getOverlayIdTarget","idAtPixel","clickEvent","type","originalEvent","dispatchEvent","hasStopped","invalidate","clickedViewPoint","hitTestViewport","clickInfo","markObject","handleSingleTap","handleDoubleClick","handleButtonDown","buttonDown","handleButtonUp","handleMouseMove","targetDbId","hovering","hasViewables","geometries","mapDbIdsToGeometries","dbIdIndex","attributes","uvp","colors","ids","isHighlighted","viewableData","getViewableUV","getViewableColor","needsUpdate","markedFragments","fragments","invalidateViewablesDirect","meshes","dbIdSet","viewables","Map","v","sceneUpdated","updates","pointIndex","positions","getSpriteUV","msg","ToolInterface","avp","Private","SpriteAtlas","spritesMap","pending","images","logger","packer","hasContent","image","Image","crossOrigin","onload","src","canvasWidth","canvasHeight","ViewableType","SPRITE","GEOMETRY","ViewableStyle","Color","highlightedColor","highlightedUrl","animatedUrls","spriteUrls","spriteUrl","values","CustomViewable","_style","_position","_dbId","SpriteViewable","assert","ViewableData","_styleMap","_viewablesMap","_spriteAtlas","atlasWidth","atlasHeight","preloadedSprites","addSprite","highlighted","finish","Room","_name","_bounds","_devices","device","_info","LevelRoomsMap","levelName","room","onlyRoomsWithDevices","rooms","devices","ModelStructureInfo","parentId","getInstanceTree","childIds","getRootId","enumNodeChildren","getNodeName","keepRoomDetail","nodeName","levelRoomsMap","getRoomList","getLevel","info","addRoomToLevel","properties","attributeName","displayValue","roomNode","getImmediateChildNodesByName","roomsRootId","getRoomBounds","getProperties2","roomId","roomGeomContainsPoint","addDevice","dev","levels","getLevelRoomsMap","mapDevicesInRoom","shadingData","subGroup","styleId","deviceModel","addPoint","sensorTypes","addChild","initialize","containsPoint","HeatmapMaterial","ShaderMaterial","sensorVals","stops","confidence","powerParameter","uniforms","uPower","uAlpha","uConfidence","uSensors","uStops","uColors","colorCount","sensorCount","vertexShader","fragmentShader","side","DoubleSide","depthTest","depthWrite","isNaN","createColorStops","res","inc","SurfaceShading","activeShadingPoints","settings","registerSensorColors","removeOverlayScene","removeShading","_clearActiveShadingPoints","hatchMaterial","dispose","heatmapMaterial","setting","Vector4","Vector3","nodeId","sensorValueCallback","heatmapConfig","confidenceSize","nodes","viewerImp","createOverlayScene","_createHatchMaterial","settingsForSensorType","getSetting","bmax","bmin","sensorValues","shadingPoint","sensorValue","material","getGeometry","mesh","Mesh","Matrix4","getWorldMatrix","matrix","copy","matrixWorldNeedsUpdate","matrixAutoUpdate","frustumCulled","addOverlay","addMeshToOverlay","PlanarHeatmap","_handleLegacyOptions","texture","Texture","UVMapping","minFilter","LinearFilter","flipY","MeshBasicMaterial","transparent","gradientMap","validateValueRange","defaultValue","slicingEnabled","slicingPosition","placePosition","placementPosition","nodeIds","totalBounds","leafs","boundsMap","dst","pointDataMap","isLeafContainsSensor","leaf","getNodeBox","Infinity","x0","y0","w0","h0","heatmapInstance","h337","indices","cg","Extensions","CompGeom","frags","currentLeafNode","matchingShadingPoints","intersects","normal","zSlicing","zPlacement","plane","Plane","toPlaneCoords","makePlaneBasis","getVizmesh","is2d","isLines","cutplanes","xMeshPlane","bbox","convertToPlaneCoords","eset","EdgeSet","size","snapEdges","sanitizeEdges","stitchContours","cset","triangulate","triangulationFailed","bg","toPolygonMesh","indexStart","bgPosition","count","bgIndices","isEmpty","pData","round","currentSensorType","_setup","updateShading","toFixed","TextureUtility","_textures","_colors","_excluded","hideTextures","regen","showTextures","refresh","white","mats","matman","_materials","mat","col","IDWProcessMaterial","vertexTexture","dataTexture","dataCount","power","parseFloat","uDataCount","uDataTextureWidth","IDWDataProcessor","vertices","setColors","setVertices","setDataPoints","initializeRender","textureSize","sqrt","verticesData","DataTexture","RGBAFormat","FloatType","ClampToEdgeWrapping","NearestFilter","generateMipmaps","verticesLength","vertexValues","dataBuffer","delta","idwMaterial","planeGeometry","PlaneBufferGeometry","orthCamera","OrthographicCamera","targetSize","renderTarget","WebGLRenderTarget","magFilter","format","stencilBuffer","depthBuffer","planeMesh","scene","Scene","camera","_createColorStops","colorMapData","_mapValueToColor","mix","mixColor","c1","c2","outputTarget","setSize","glrenderer","render","readRenderTargetPixels","_getColorValues","outputValues","memcpy","srcOffset","dstOffset","subarray","buffer","StreamLine","_prev","_next","_side","_index","_widthCallback","_geometry","points","wcb","aa","ab","attribute","dataArray","isLoop","compareV3","copyFromIndex","copyV3","positionArray","prevArray","nextArray","sideArray","widthArray","indexArray","_attributes","updateAttribute","computeBoundingSphere","computeBoundingBox","visible","StreamLineMaterial","parameters","check","Material","lineColor","lineWidth","RawShaderMaterial","resolution","Vector2","sizeAttenuation","setValues","constructor","generateId","_lineColor","getHexString","_lineWidth","StreamLineBuilder","_viewer","_overlayCreated","_streamLines","_cachedMaterials","streamLine","_removeMeshFromScene","cachedMaterial","streamLineSpecs","setPoints","lineData","_getOrCreateMaterial","_addMeshToScene","findIndex","entry","removed","removeOverlay","extnName","AutodeskNamespace","CustomViewables","Constants","SurfaceShadingInfo","DataVisualization","textureUtility","pointMeshes","_streamLineBuilder","_onInstanceTreeReady","tool","toolController","registerTool","instanceTreeReadyPromise","instanceTreeReadyPromiseResolve","instanceTreeReadyPromiseReject","datavizDotOverlay","OBJECT_TREE_CREATED_EVENT","deviceDepthOcclusion","deregisterTool","removeEventListener","removeSurfaceShading","surfaceShading","activateTool","getName","deactivateTool","removeAllViewables","idToGeometryMap","dbId2Geometry","from","sprite","ImageUtils","loadTexture","maxFilter","PointCloudMaterial","spriteSize","getWindow","devicePixelRatio","vertexColors","VertexColors","alphaTest","occlusion","updateDepthUniforms","depthTarget","getDepthTarget","skipMrtNormals","defines","PARTICLE_FRAGMENT","USE_VERTEX_ID","DEPTH_OCCLUSION","PARTICLE_UV","PARTICLE_FLAGS","addMaterial","pointMaterial","VIEWER_RESIZE_EVENT","thisObject","builder","enable","program","changeOcclusion","createSetup","cleanUp","loadExtension","waitForInstanceTree","valueCallback","Extension","theExtensionManager","registerExtension"],"mappings":"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","file":"DataVisualization/DataVisualization.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 834);\n","module.exports = THREE;","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.toString()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n    return obj;\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                object_defineProperty(error, \"__minimumStackCounter__\", {value: p.stackCounter, configurable: true});\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        var stack = filterStackString(concatedStacks);\n        object_defineProperty(error, \"stack\", {value: stack, configurable: true});\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n/**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */\nvar longStackCounter = 1;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n            promise.stackCounter = longStackCounter++;\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n\n        if (Q.longStackSupport && hasStacks) {\n            // Only hold a reference to the new promise if long stacks\n            // are enabled to reduce memory usage\n            promise.source = newPromise;\n        }\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected(err) {\n            pendingCount--;\n            if (pendingCount === 0) {\n                var rejection = err || new Error(\"\" + err);\n\n                rejection.message = (\"Q can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected. Last error message: \" + rejection.message);\n\n                deferred.reject(rejection);\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    if (!callback || typeof callback.apply !== \"function\") {\n        throw new Error(\"Q can't apply finally callback\");\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    if (callback === undefined) {\n        throw new Error(\"Q can't wrap an undefined function\");\n    }\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n","/**\n * Generic Data Structure to enable the Heatmap/SurfaceShading\n *\n */\n\n/**\n * A `SurfaceShadingPoint` object is used to represent a real-world entity that\n * has a physical position within the model. A `SurfaceShadingPoint` contains\n * one or more properties. Surface shading (i.e. heatmap) mechanism queries\n * values of these properties in order to determine the color of the point where\n * this `SurfaceShadingPoint` object is located.\n *\n * For an example, consider an IoT scenario of a physical sensor device, one that\n * occupies a physical location and exposes multiple sensor properties (such as\n * \"temperature\" and \"humidity\"), each of which has its own numeric values.\n * In this scenario, a `SurfaceShadingPoint` can be used to represent the physical\n * sensor device, where properties such as \"temperature\" and \"humidity\" are `types`\n * defined in the `SurfaceShadingPoint` object.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.SurfaceShadingPoint\n */\nclass SurfaceShadingPoint {\n    /**\n     * Constructs an instance of `SurfaceShadingPoint` object.\n     *\n     * @param {string} id The identifier of this `SurfaceShadingPoint` object.\n     * @param {{x:number, y: number, z: number}} position The position of\n     *  this `SurfaceShadingPoint` object in the world space.\n     * @param {string[]} types The types (of sensors, or properties) that are\n     *  exposed by this `SurfaceShadingPoint` object.\n     * @param {string} [name]  Optional identifier associated with\n     *  this `SurfaceShadingPoint` object. Equivalent to `id` by default.\n     * @param {Object} [contextData] Optional object used to track any\n     *  additional information for this `SurfaceShadingPoint` object.\n     *\n     * @example\n     *  const sensorId = \"cafeteria-entrace-01\";\n     *  const position = { x: -159.2780, y: -50.4998, z: -16.9196 };\n     *  const types = [\"temperature\", \"humidity\"];\n     *\n     *  const shadingPoint = new Autodesk.DataVisualization.Core.SurfaceShadingPoint(\n     *      sensorId, position, types);\n     */\n    constructor(id, position, types, name = id, contextData = {}) {\n        this.id = id;\n        this.position = position;\n        this.types = types;\n        this.name = name;\n        this.contextData = contextData;\n\n        this.dbId = null;\n    }\n\n    /**\n     * Derives the position of a `SurfaceShadingPoint` from a given `DbId`.\n     * The position is calculated by taking the centroid of the union of all the\n     * geometry bounding boxes that this `DbId` corresponds to. This function is\n     * useful if a position is not supplied at the construction time.\n     *\n     * @param {Model} model The model that contains the given `DbId`.\n     * @param {number} dbId The `DbId` of the object to derive the center point from.\n     *\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingPoint#positionFromDBId\n     *\n     * @example\n     *  const sensorId = \"cafeteria-entrace-01\";\n     *  const types = [\"temperature\", \"humidity\"];\n     *\n     *  // Position of the shading point is unknown at construction time\n     *  const shadingPoint = new Autodesk.DataVisualization.Core.SurfaceShadingPoint(\n     *      sensorId, undefined, types);\n     *\n     *  shadingPoint.positionFromDBId(model, sensorDbId);\n     */\n    positionFromDBId(model, dbId) {\n        const it = model.getData().instanceTree;\n        const bounds = new THREE.Box3();\n        const fragBounds = new THREE.Box3();\n        const fragList = model.getFragmentList();\n        this.dbId = dbId;\n\n        it.enumNodeFragments(\n            dbId,\n            (fragId) => {\n                // get the center of this fragId\n                fragList.getWorldBounds(fragId, fragBounds);\n                bounds.union(fragBounds);\n            },\n            true\n        );\n\n        this.position = bounds.getCenter() || this.position;\n    }\n}\n\n/**\n * A basic rendering unit that represents one or more `DbId`, each corresponds\n * to a geometry.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.SurfaceShadingNode\n */\nclass SurfaceShadingNode {\n    /**\n     * Constructs an instance of `SurfaceShadingNode` object that represents a\n     * basic rendering unit. A `SurfaceShadingNode` contains one or more `DbId`,\n     * each corresponds a geometry.\n     *\n     * @param {string} id The identifier of this `SurfaceShadingNode` object.\n     * @param {(number|number[])} dbIds A `DbId` or an array of `DbIds`, each of\n     * which represents a geometry that will be rendered when the `SurfaceShadingNode`\n     * is included in calls to `renderSurfaceShading` or `updateSurfaceShading` APIs.\n     * @param {SurfaceShadingPoint[]} shadingPoints An optional array\n     * of `SurfaceShadingPoint` objects.\n     * @param {string} [name] Optional identifier associated with\n     * this `SurfaceShadingNode` object. Equivalent to `id` by default.\n     *\n     * @example\n     *  const id = \"engine-cylinder-02\";\n     *  const dbIds = [1060, 1062, 1064, 1065]; // Objects to be shaded together as one.\n     *  const shadingNode = new Autodesk.DataVisualization.Core.SurfaceShadingNode(id, dbIds);\n     *\n     *  const vibrationSensor02 = new Autodesk.DataVisualization.Core.SurfaceShadingPoint(...);\n     *  shadingNode.addPoint(vibrationSensor02); // Associate a sensor to the cylinder.\n     *\n     *  // User selects to visualize one cylinder from the UI\n     *  onEngineCylinderSelected(cylinderName) {\n     *      const sensorType = \"vibration\";\n     *      const confidenceSize = 300;\n     *\n     *      // 'cylinderName' can be \"engine-cylinder-02\"\n     *      dataVizExt.renderSurfaceShading([cylinderName],\n     *          sensorType, getSensorValue, confidenceSize);\n     *  }\n     */\n    constructor(id, dbIds, shadingPoints, name = id) {\n        if (typeof dbIds == \"number\") {\n            dbIds = [dbIds];\n        }\n\n        this.dbIds = dbIds;\n        this.shadingPoints = shadingPoints || [];\n        this.isLeaf = true;\n        this.fragIds = [];\n        this.id = id;\n        this.name = name;\n        this.bounds = new THREE.Box3();\n    }\n\n    /**\n     * Adds a `SurfaceShadingPoint` object to the `SurfaceShadingNode` object.\n     *\n     * @param {SurfaceShadingPoint} point The `SurfaceShadingPoint` object to be\n     * added to the `SurfaceShadingNode` object.\n     *\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingNode#addPoint\n     */\n    addPoint(point) {\n        this.shadingPoints.push(point);\n    }\n\n    /**\n     * @private\n     * Updates the `SurfaceShadingNode` object by storing the fragment IDs that\n     * are found for each of its dbIds list.\n     *\n     * @param {Model} model The model from which fragment IDs are to be obtained.\n     *\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingNode#update\n     */\n    update(model) {\n        const it = model.getData().instanceTree;\n        const hashSet = new Set(this.fragIds);\n        const fragBounds = new THREE.Box3();\n        const fragList = model.getFragmentList();\n\n        const recursive = true;\n        this.dbIds.forEach((dbId) => {\n            it.enumNodeFragments(dbId, (fragId) => {\n                if (!hashSet.has(fragId)) {\n                    this.fragIds.push(fragId);\n                    fragList.getWorldBounds(fragId, fragBounds);\n                    this.bounds.union(fragBounds);\n                }\n            }, recursive);\n        });\n    }\n}\n\n/**\n * A grouping data structure that allows rendering units to be\n * organized in a hierarchical manner. It can contain zero or more\n * sub-groups and/or `SurfaceShadingNode` leaf nodes as child.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.SurfaceShadingGroup\n */\nclass SurfaceShadingGroup {\n    /**\n     * Constructs an instance of `SurfaceShadingGroup` object.\n     *\n     * @param {string} id The identifier of the group.\n     * @param {string} [name]  Optional identifier associated with this `SurfaceShadingGroup` object. Equivalent to id by default.\n     * @example\n     *  const cylinders = [\n     *      new Autodesk.DataVisualization.Core.SurfaceShadingNode(\"engine-cylinder-00\", ...),\n     *      new Autodesk.DataVisualization.Core.SurfaceShadingNode(\"engine-cylinder-01\", ...),\n     *      new Autodesk.DataVisualization.Core.SurfaceShadingNode(\"engine-cylinder-02\", ...),\n     *      new Autodesk.DataVisualization.Core.SurfaceShadingNode(\"engine-cylinder-03\", ...),\n     *  ];\n     *\n     *  const groupName = \"front-cylinders\";\n     *  const frontCylinders = new Autodesk.DataVisualization.Core.SurfaceShadingGroup(groupName);\n     *  cylinders.forEach(cylinder => frontCylinders.addChild(cylinder));\n     *\n     *  // User selects to visualize a group of cylinders from the UI\n     *  onEngineCylinderGroupSelected(cylinderGroupName) {\n     *      const sensorType = \"vibration\";\n     *      const confidenceSize = 300;\n     *\n     *      // 'cylinderGroupName' can be \"front-cylinders\"\n     *      dataVizExt.renderSurfaceShading([cylinderGroupName],\n     *          sensorType, getSensorValue, confidenceSize);\n     *  }\n     */\n    constructor(id, name = id) {\n        this.id = id;\n        this._children = [];\n        this.isGroup = true;\n        this.name = name;\n    }\n\n    /**\n     * The child nodes, each of which is either another shading group, or a\n     * shading leaf node.\n     * @returns {SurfaceShadingGroup[]|SurfaceShadingNode[]} The child nodes,\n     * each of which is either another shading group, or a shading leaf node.\n     */\n    get children() {\n        return this._children;\n    }\n\n    /**\n     * Adds a child node to the shading group.\n     *\n     * @param {SurfaceShadingGroup|SurfaceShadingNode} child The\n     * child node to be added to the shading group. A child node can\n     * either be another `SurfaceShadingGroup`, or `SurfaceShadingNode`.\n     *\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingGroup#addChild\n     */\n    addChild(child) {\n        this.children.push(child);\n    }\n\n    /**\n     * @private\n     * Recursively updates all the leaf nodes.\n     * @param {Model} model The model from which fragment IDs are to be obtained.\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingGroup#update\n     */\n    update(model) {\n        this.children.forEach((child) => child.update(model));\n    }\n\n    /**\n     * @private\n     * For internal use only. Retrieves all the leaf nodes of a shading group,\n     * or a particular leaf node with the given identifier.\n     *\n     * @param {string} id The identifier of the leaf node to retrieve.\n     * @param {SurfaceShadingNode[]} results The input/output result list of\n     * SurfaceShadingNode that matches the search criteria.\n     * @returns {SurfaceShadingNode[]} The resulting list of SurfaceShadingNode\n     * that matches the search criteria.\n     *\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingGroup#getLeafsById\n     */\n    getLeafsById(id, results) {\n        results = results || [];\n\n        for (let i = 0; i < this.children.length; i++) {\n            let child = this.children[i];\n            if (child.id === id) {\n                if (child.isLeaf) {\n                    results.push(child);\n                } else if (child.isGroup) {\n                    child.getChildLeafs(results);\n                }\n            } else if (child.isGroup) {\n                child.getLeafsById(id, results);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *\n     * Find a child node by matching the id\n     *\n     * @param {string} id node id\n     * @returns {SurfaceShadingGroup|SurfaceShadingNode}\n     */\n    getNodeById(id) {\n        for (let i = 0; i < this.children.length; i++) {\n            let child = this.children[i];\n            if (child.id === id) {\n                return child;\n            } else if (child.isGroup) {\n                let result = child.getNodeById(id);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n\n    /**\n     * @private\n     * For internal use only. Recursively retrieves all the leaf nodes\n     * of this shading group.\n     *\n     * @param {SurfaceShadingNode[]} results The resulting list of all\n     * the leaf nodes. This call always appends leaf nodes into the\n     * parameter without first clearing any existing entries in results.\n     *\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingGroup#getChildLeafs\n     */\n    getChildLeafs(results) {\n        for (let i = 0; i < this.children.length; i++) {\n            let child = this.children[i];\n            if (child.isLeaf) {\n                results.push(child);\n            } else if (child.isGroup) {\n                child.getChildLeafs(results);\n            }\n        }\n    }\n}\n\n/**\n * Data that describes the hierarchical object relationship the surface shading is based on.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.SurfaceShadingData\n */\nclass SurfaceShadingData extends SurfaceShadingGroup {\n    /**\n     * Initialize the `SurfaceShadingData` object so that it can be used as an\n     * input to `setupSurfaceShading` API.\n     *\n     * @param {Model} model The model to initialize the surface shading for.\n     *\n     * @alias Autodesk.DataVisualization.Core.SurfaceShadingData#initialize\n     *\n     * @example\n     *  const id = \"engine-cylinder-02\";\n     *  const dbIds = [1060, 1062, 1064, 1065]; // Objects to be shaded together as one.\n     *  const shadingNode = new Autodesk.DataVisualization.Core.SurfaceShadingNode(id, dbIds);\n     *\n     *  const vibrationSensor02 = new Autodesk.DataVisualization.Core.SurfaceShadingPoint(...);\n     *  shadingNode.addPoint(vibrationSensor02); // Associate a sensor to the cylinder.\n     *\n     *  const shadingData = new Autodesk.DataVisualization.Core.SurfaceShadingData();\n     *  shadingData.addChild(shadingNode);\n     *  shadingData.initialize(model);\n     *\n     *  dataVizExt.setupSurfaceShading(model, shadingData);\n     */\n    initialize(model) {\n        this.update(model);\n    }\n}\n\n/**\n * Filters out shading points that expose the specified sensor type.\n *\n * @param {SurfaceShadingPoint[]} shadingPoints The shading points to filter from.\n * @param {string} sensorType The type of sensors to filter device with.\n * @returns {SurfaceShadingPoint[]} The shading points that expose the given sensor type.\n */\nfunction filterShadingPointsByType(shadingPoints, sensorType) {\n    shadingPoints = shadingPoints || [];\n    return shadingPoints.filter((d) => d.types && d.types.includes(sensorType));\n}\n\nmodule.exports = {\n    SurfaceShadingData,\n    SurfaceShadingGroup,\n    SurfaceShadingNode,\n    SurfaceShadingPoint,\n    filterShadingPointsByType,\n};\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","// 64K\n\nconst THREE = require(\"three\");\n\nconst MAX_VCOUNT = 65535;\n\nclass SpriteMeshBuilder {\n\n    constructor(meshCallback) {\n        this.meshCallback = meshCallback;\n        this.dbIds = [];\n        this.reset();\n    }\n\n    addPoint(viewable, spriteAtlas) {\n        if (this.vcount + 1 > MAX_VCOUNT) {\n            this.flushBuffer();\n\n            this.reset();\n        }\n\n        let index = this.vcount;\n        this.ib[index] = index;\n\n        this.vb[index * 3] = viewable.position.x;\n        this.vb[index * 3 + 1] = viewable.position.y;\n        this.vb[index * 3 + 2] = viewable.position.z;\n\n        this.idb[index * 3] = viewable.dbId & 0xFF;\n        this.idb[index * 3 + 1] = (viewable.dbId >> 8) & 0xFF;\n        this.idb[index * 3 + 2] = (viewable.dbId >> 16) & 0xFF;\n\n        this.colorb[index * 3] = viewable.color.r * 255;\n        this.colorb[index * 3 + 1] = viewable.color.g * 255;\n        this.colorb[index * 3 + 2] = viewable.color.b * 255;\n\n        if (spriteAtlas) {\n            let uv = spriteAtlas.spriteUV(viewable.style.url);\n            if (uv) {\n                this.uv[index * 4] = uv.x;\n                this.uv[index * 4 + 1] = uv.y;\n                this.uv[index * 4 + 2] = uv.w;\n                this.uv[index * 4 + 3] = uv.h;\n            }\n        }\n\n        this.scale[index] = 1;\n        this.dbIds.push(viewable.dbId);\n        this.vcount++;\n    }\n\n    reset() {\n        this.vcount = 0;\n\n        this.ib = new Uint16Array(MAX_VCOUNT);\n        this.idb = new Uint8Array(MAX_VCOUNT * 3);\n        this.vb = new Float32Array(MAX_VCOUNT * 3);\n        this.colorb = new Uint8Array(MAX_VCOUNT * 3);\n        this.scale = new Float32Array(MAX_VCOUNT);\n        this.uv = new Float32Array(MAX_VCOUNT * 4);\n    }\n\n    flushBuffer() {\n        let geometry = new THREE.BufferGeometry();\n        let idAttribute = new THREE.BufferAttribute(new Uint8Array(this.idb.slice(0, this.vcount * 3)), 3);\n        idAttribute.bytesPerItem = 1;\n        idAttribute.normalize = true;\n\n        let positionAttribute = new THREE.BufferAttribute(new Float32Array(this.vb.slice(0, this.vcount * 3)), 3);\n        positionAttribute.bytesPerItem = 4;\n\n        let colorAttribute = new THREE.BufferAttribute(new Uint8Array(this.colorb.slice(0, this.vcount * 3)), 3);\n        colorAttribute.bytesPerItem = 1;\n        colorAttribute.normalize = true;\n\n        let indexAttribute = new THREE.BufferAttribute(new Uint16Array(this.ib.slice(0, this.vcount)), 1);\n\n        let uvAttribute = new THREE.BufferAttribute(new Float32Array(this.uv.slice(0, this.vcount * 4)), 4);\n\n        let scaleAttribute = new THREE.BufferAttribute(new Float32Array(this.scale.slice(0, this.vcount)), 1);\n\n        geometry.setAttribute(\"id\", idAttribute);\n        geometry.setAttribute(\"index\", indexAttribute);\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"color\", colorAttribute);\n        geometry.setAttribute(\"uvp\", uvAttribute);\n        geometry.setAttribute(\"pointScale\", scaleAttribute);\n\n        geometry.isPoints = true;\n        geometry.dbIds = this.dbIds.slice(0);\n        this.dbIds.length = 0;\n\n        if (this.meshCallback) {\n            this.meshCallback(geometry);\n        }\n        this.vcount = 0;\n    }\n}\n\nmodule.exports = {\n    SpriteMeshBuilder\n};\n\n","/*\n * heatmap.js v2.0.5 | JavaScript Heatmap Library\n *\n * Copyright 2008-2016 Patrick Wied <heatmapjs@patrick-wied.at> - All rights reserved.\n * Dual licensed under MIT and Beerware license \n *\n * :: 2016-09-05 01:16\n */\n;(function (name, context, factory) {\n\n  // Supports UMD. AMD, CommonJS/Node.js and browser context\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else {\n    context[name] = factory();\n  }\n\n})(\"h337\", this, function () {\n\n// Heatmap Config stores default values and will be merged with instance config\nvar HeatmapConfig = {\n  defaultRadius: 40,\n  defaultRenderer: 'canvas2d',\n  defaultGradient: { 0.25: \"rgb(0,0,255)\", 0.55: \"rgb(0,255,0)\", 0.85: \"yellow\", 1.0: \"rgb(255,0,0)\"},\n  defaultMaxOpacity: 1,\n  defaultMinOpacity: 0,\n  defaultBlur: .85,\n  defaultXField: 'x',\n  defaultYField: 'y',\n  defaultValueField: 'value', \n  plugins: {}\n};\nvar Store = (function StoreClosure() {\n\n  var Store = function Store(config) {\n    this._coordinator = {};\n    this._data = [];\n    this._radi = [];\n    this._min = 10;\n    this._max = 1;\n    this._xField = config['xField'] || config.defaultXField;\n    this._yField = config['yField'] || config.defaultYField;\n    this._valueField = config['valueField'] || config.defaultValueField;\n\n    if (config[\"radius\"]) {\n      this._cfgRadius = config[\"radius\"];\n    }\n  };\n\n  var defaultRadius = HeatmapConfig.defaultRadius;\n\n  Store.prototype = {\n    // when forceRender = false -> called from setData, omits renderall event\n    _organiseData: function(dataPoint, forceRender) {\n        var x = dataPoint[this._xField];\n        var y = dataPoint[this._yField];\n        var radi = this._radi;\n        var store = this._data;\n        var max = this._max;\n        var min = this._min;\n        var value = dataPoint[this._valueField] || 1;\n        var radius = dataPoint.radius || this._cfgRadius || defaultRadius;\n\n        if (!store[x]) {\n          store[x] = [];\n          radi[x] = [];\n        }\n\n        if (!store[x][y]) {\n          store[x][y] = value;\n          radi[x][y] = radius;\n        } else {\n          store[x][y] += value;\n        }\n        var storedVal = store[x][y];\n\n        if (storedVal > max) {\n          if (!forceRender) {\n            this._max = storedVal;\n          } else {\n            this.setDataMax(storedVal);\n          }\n          return false;\n        } else if (storedVal < min) {\n          if (!forceRender) {\n            this._min = storedVal;\n          } else {\n            this.setDataMin(storedVal);\n          }\n          return false;\n        } else {\n          return { \n            x: x, \n            y: y,\n            value: value, \n            radius: radius,\n            min: min,\n            max: max \n          };\n        }\n    },\n    _unOrganizeData: function() {\n      var unorganizedData = [];\n      var data = this._data;\n      var radi = this._radi;\n\n      for (var x in data) {\n        for (var y in data[x]) {\n\n          unorganizedData.push({\n            x: x,\n            y: y,\n            radius: radi[x][y],\n            value: data[x][y]\n          });\n\n        }\n      }\n      return {\n        min: this._min,\n        max: this._max,\n        data: unorganizedData\n      };\n    },\n    _onExtremaChange: function() {\n      this._coordinator.emit('extremachange', {\n        min: this._min,\n        max: this._max\n      });\n    },\n    addData: function() {\n      if (arguments[0].length > 0) {\n        var dataArr = arguments[0];\n        var dataLen = dataArr.length;\n        while (dataLen--) {\n          this.addData.call(this, dataArr[dataLen]);\n        }\n      } else {\n        // add to store  \n        var organisedEntry = this._organiseData(arguments[0], true);\n        if (organisedEntry) {\n          // if it's the first datapoint initialize the extremas with it\n          if (this._data.length === 0) {\n            this._min = this._max = organisedEntry.value;\n          }\n          this._coordinator.emit('renderpartial', {\n            min: this._min,\n            max: this._max,\n            data: [organisedEntry]\n          });\n        }\n      }\n      return this;\n    },\n    setData: function(data) {\n      var dataPoints = data.data;\n      var pointsLen = dataPoints.length;\n\n\n      // reset data arrays\n      this._data = [];\n      this._radi = [];\n\n      for(var i = 0; i < pointsLen; i++) {\n        this._organiseData(dataPoints[i], false);\n      }\n      this._max = data.max;\n      this._min = data.min || 0;\n      \n      this._onExtremaChange();\n      this._coordinator.emit('renderall', this._getInternalData());\n      return this;\n    },\n    removeData: function() {\n      // TODO: implement\n    },\n    setDataMax: function(max) {\n      this._max = max;\n      this._onExtremaChange();\n      this._coordinator.emit('renderall', this._getInternalData());\n      return this;\n    },\n    setDataMin: function(min) {\n      this._min = min;\n      this._onExtremaChange();\n      this._coordinator.emit('renderall', this._getInternalData());\n      return this;\n    },\n    setCoordinator: function(coordinator) {\n      this._coordinator = coordinator;\n    },\n    _getInternalData: function() {\n      return { \n        max: this._max,\n        min: this._min, \n        data: this._data,\n        radi: this._radi \n      };\n    },\n    getData: function() {\n      return this._unOrganizeData();\n    }/*,\n\n      TODO: rethink.\n\n    getValueAt: function(point) {\n      var value;\n      var radius = 100;\n      var x = point.x;\n      var y = point.y;\n      var data = this._data;\n\n      if (data[x] && data[x][y]) {\n        return data[x][y];\n      } else {\n        var values = [];\n        // radial search for datapoints based on default radius\n        for(var distance = 1; distance < radius; distance++) {\n          var neighbors = distance * 2 +1;\n          var startX = x - distance;\n          var startY = y - distance;\n\n          for(var i = 0; i < neighbors; i++) {\n            for (var o = 0; o < neighbors; o++) {\n              if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {\n                if (data[startY+i] && data[startY+i][startX+o]) {\n                  values.push(data[startY+i][startX+o]);\n                }\n              } else {\n                continue;\n              } \n            }\n          }\n        }\n        if (values.length > 0) {\n          return Math.max.apply(Math, values);\n        }\n      }\n      return false;\n    }*/\n  };\n\n\n  return Store;\n})();\n\nvar Canvas2dRenderer = (function Canvas2dRendererClosure() {\n\n  var _getColorPalette = function(config) {\n    var gradientConfig = config.gradient || config.defaultGradient;\n    var paletteCanvas = document.createElement('canvas');\n    var paletteCtx = paletteCanvas.getContext('2d');\n\n    paletteCanvas.width = 256;\n    paletteCanvas.height = 1;\n\n    var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\n    for (var key in gradientConfig) {\n      gradient.addColorStop(key, gradientConfig[key]);\n    }\n\n    paletteCtx.fillStyle = gradient;\n    paletteCtx.fillRect(0, 0, 256, 1);\n\n    return paletteCtx.getImageData(0, 0, 256, 1).data;\n  };\n\n  var _getPointTemplate = function(radius, blurFactor) {\n    var tplCanvas = document.createElement('canvas');\n    var tplCtx = tplCanvas.getContext('2d');\n    var x = radius;\n    var y = radius;\n    tplCanvas.width = tplCanvas.height = radius*2;\n\n    if (blurFactor == 1) {\n      tplCtx.beginPath();\n      tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);\n      tplCtx.fillStyle = 'rgba(0,0,0,1)';\n      tplCtx.fill();\n    } else {\n      var gradient = tplCtx.createRadialGradient(x, y, radius*blurFactor, x, y, radius);\n      gradient.addColorStop(0, 'rgba(0,0,0,1)');\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      tplCtx.fillStyle = gradient;\n      tplCtx.fillRect(0, 0, 2*radius, 2*radius);\n    }\n\n\n\n    return tplCanvas;\n  };\n\n  var _prepareData = function(data) {\n    var renderData = [];\n    var min = data.min;\n    var max = data.max;\n    var radi = data.radi;\n    var data = data.data;\n\n    var xValues = Object.keys(data);\n    var xValuesLen = xValues.length;\n\n    while(xValuesLen--) {\n      var xValue = xValues[xValuesLen];\n      var yValues = Object.keys(data[xValue]);\n      var yValuesLen = yValues.length;\n      while(yValuesLen--) {\n        var yValue = yValues[yValuesLen];\n        var value = data[xValue][yValue];\n        var radius = radi[xValue][yValue];\n        renderData.push({\n          x: xValue,\n          y: yValue,\n          value: value,\n          radius: radius\n        });\n      }\n    }\n\n    return {\n      min: min,\n      max: max,\n      data: renderData\n    };\n  };\n\n\n  function Canvas2dRenderer(config) {\n    var container = config.container;\n    var shadowCanvas = this.shadowCanvas = document.createElement('canvas');\n    var canvas = this.canvas = config.canvas || document.createElement('canvas');\n    var renderBoundaries = this._renderBoundaries = [10000, 10000, 0, 0];\n\n    var computed = getComputedStyle(config.container) || {};\n\n    canvas.className = 'heatmap-canvas';\n\n    this._width = canvas.width = shadowCanvas.width = config.width || +(computed.width.replace(/px/,''));\n    this._height = canvas.height = shadowCanvas.height = config.height || +(computed.height.replace(/px/,''));\n\n    this.shadowCtx = shadowCanvas.getContext('2d');\n    this.ctx = canvas.getContext('2d');\n\n    // @TODO:\n    // conditional wrapper\n\n    canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';\n\n    container.style.position = 'relative';\n    container.appendChild(canvas);\n\n    this._palette = _getColorPalette(config);\n    this._templates = {};\n\n    this._setStyles(config);\n  };\n\n  Canvas2dRenderer.prototype = {\n    renderPartial: function(data) {\n      if (data.data.length > 0) {\n        this._drawAlpha(data);\n        this._colorize();\n      }\n    },\n    renderAll: function(data) {\n      // reset render boundaries\n      this._clear();\n      if (data.data.length > 0) {\n        this._drawAlpha(_prepareData(data));\n        this._colorize();\n      }\n    },\n    _updateGradient: function(config) {\n      this._palette = _getColorPalette(config);\n    },\n    updateConfig: function(config) {\n      if (config['gradient']) {\n        this._updateGradient(config);\n      }\n      this._setStyles(config);\n    },\n    setDimensions: function(width, height) {\n      this._width = width;\n      this._height = height;\n      this.canvas.width = this.shadowCanvas.width = width;\n      this.canvas.height = this.shadowCanvas.height = height;\n    },\n    _clear: function() {\n      this.shadowCtx.clearRect(0, 0, this._width, this._height);\n      this.ctx.clearRect(0, 0, this._width, this._height);\n    },\n    _setStyles: function(config) {\n      this._blur = (config.blur == 0)?0:(config.blur || config.defaultBlur);\n\n      if (config.backgroundColor) {\n        this.canvas.style.backgroundColor = config.backgroundColor;\n      }\n\n      this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width;\n      this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height;\n\n\n      this._opacity = (config.opacity || 0) * 255;\n      this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;\n      this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;\n      this._useGradientOpacity = !!config.useGradientOpacity;\n    },\n    _drawAlpha: function(data) {\n      var min = this._min = data.min;\n      var max = this._max = data.max;\n      var data = data.data || [];\n      var dataLen = data.length;\n      // on a point basis?\n      var blur = 1 - this._blur;\n\n      while(dataLen--) {\n\n        var point = data[dataLen];\n\n        var x = point.x;\n        var y = point.y;\n        var radius = point.radius;\n        // if value is bigger than max\n        // use max as value\n        var value = Math.min(point.value, max);\n        var rectX = x - radius;\n        var rectY = y - radius;\n        var shadowCtx = this.shadowCtx;\n\n\n\n\n        var tpl;\n        if (!this._templates[radius]) {\n          this._templates[radius] = tpl = _getPointTemplate(radius, blur);\n        } else {\n          tpl = this._templates[radius];\n        }\n        // value from minimum / value range\n        // => [0, 1]\n        var templateAlpha = (value-min)/(max-min);\n        // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData\n        shadowCtx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;\n\n        shadowCtx.drawImage(tpl, rectX, rectY);\n\n        // update renderBoundaries\n        if (rectX < this._renderBoundaries[0]) {\n            this._renderBoundaries[0] = rectX;\n          }\n          if (rectY < this._renderBoundaries[1]) {\n            this._renderBoundaries[1] = rectY;\n          }\n          if (rectX + 2*radius > this._renderBoundaries[2]) {\n            this._renderBoundaries[2] = rectX + 2*radius;\n          }\n          if (rectY + 2*radius > this._renderBoundaries[3]) {\n            this._renderBoundaries[3] = rectY + 2*radius;\n          }\n\n      }\n    },\n    _colorize: function() {\n      var x = this._renderBoundaries[0];\n      var y = this._renderBoundaries[1];\n      var width = this._renderBoundaries[2] - x;\n      var height = this._renderBoundaries[3] - y;\n      var maxWidth = this._width;\n      var maxHeight = this._height;\n      var opacity = this._opacity;\n      var maxOpacity = this._maxOpacity;\n      var minOpacity = this._minOpacity;\n      var useGradientOpacity = this._useGradientOpacity;\n\n      if (x < 0) {\n        x = 0;\n      }\n      if (y < 0) {\n        y = 0;\n      }\n      if (x + width > maxWidth) {\n        width = maxWidth - x;\n      }\n      if (y + height > maxHeight) {\n        height = maxHeight - y;\n      }\n\n      var img = this.shadowCtx.getImageData(x, y, width, height);\n      var imgData = img.data;\n      var len = imgData.length;\n      var palette = this._palette;\n\n\n      for (var i = 3; i < len; i+= 4) {\n        var alpha = imgData[i];\n        var offset = alpha * 4;\n\n\n        if (!offset) {\n          continue;\n        }\n\n        var finalAlpha;\n        if (opacity > 0) {\n          finalAlpha = opacity;\n        } else {\n          if (alpha < maxOpacity) {\n            if (alpha < minOpacity) {\n              finalAlpha = minOpacity;\n            } else {\n              finalAlpha = alpha;\n            }\n          } else {\n            finalAlpha = maxOpacity;\n          }\n        }\n\n        imgData[i-3] = palette[offset];\n        imgData[i-2] = palette[offset + 1];\n        imgData[i-1] = palette[offset + 2];\n        imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;\n\n      }\n\n      img.data = imgData;\n      this.ctx.putImageData(img, x, y);\n\n      this._renderBoundaries = [1000, 1000, 0, 0];\n\n    },\n    getValueAt: function(point) {\n      var value;\n      var shadowCtx = this.shadowCtx;\n      var img = shadowCtx.getImageData(point.x, point.y, 1, 1);\n      var data = img.data[3];\n      var max = this._max;\n      var min = this._min;\n\n      value = (Math.abs(max-min) * (data/255)) >> 0;\n\n      return value;\n    },\n    getDataURL: function() {\n      return this.canvas.toDataURL();\n    }\n  };\n\n\n  return Canvas2dRenderer;\n})();\n\n\nvar Renderer = (function RendererClosure() {\n\n  var rendererFn = false;\n\n  if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {\n    rendererFn = Canvas2dRenderer;\n  }\n\n  return rendererFn;\n})();\n\n\nvar Util = {\n  merge: function() {\n    var merged = {};\n    var argsLen = arguments.length;\n    for (var i = 0; i < argsLen; i++) {\n      var obj = arguments[i]\n      for (var key in obj) {\n        merged[key] = obj[key];\n      }\n    }\n    return merged;\n  }\n};\n// Heatmap Constructor\nvar Heatmap = (function HeatmapClosure() {\n\n  var Coordinator = (function CoordinatorClosure() {\n\n    function Coordinator() {\n      this.cStore = {};\n    };\n\n    Coordinator.prototype = {\n      on: function(evtName, callback, scope) {\n        var cStore = this.cStore;\n\n        if (!cStore[evtName]) {\n          cStore[evtName] = [];\n        }\n        cStore[evtName].push((function(data) {\n            return callback.call(scope, data);\n        }));\n      },\n      emit: function(evtName, data) {\n        var cStore = this.cStore;\n        if (cStore[evtName]) {\n          var len = cStore[evtName].length;\n          for (var i=0; i<len; i++) {\n            var callback = cStore[evtName][i];\n            callback(data);\n          }\n        }\n      }\n    };\n\n    return Coordinator;\n  })();\n\n\n  var _connect = function(scope) {\n    var renderer = scope._renderer;\n    var coordinator = scope._coordinator;\n    var store = scope._store;\n\n    coordinator.on('renderpartial', renderer.renderPartial, renderer);\n    coordinator.on('renderall', renderer.renderAll, renderer);\n    coordinator.on('extremachange', function(data) {\n      scope._config.onExtremaChange &&\n      scope._config.onExtremaChange({\n        min: data.min,\n        max: data.max,\n        gradient: scope._config['gradient'] || scope._config['defaultGradient']\n      });\n    });\n    store.setCoordinator(coordinator);\n  };\n\n\n  function Heatmap() {\n    var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});\n    this._coordinator = new Coordinator();\n    if (config['plugin']) {\n      var pluginToLoad = config['plugin'];\n      if (!HeatmapConfig.plugins[pluginToLoad]) {\n        throw new Error('Plugin \\''+ pluginToLoad + '\\' not found. Maybe it was not registered.');\n      } else {\n        var plugin = HeatmapConfig.plugins[pluginToLoad];\n        // set plugin renderer and store\n        this._renderer = new plugin.renderer(config);\n        this._store = new plugin.store(config);\n      }\n    } else {\n      this._renderer = new Renderer(config);\n      this._store = new Store(config);\n    }\n    _connect(this);\n  };\n\n  // @TODO:\n  // add API documentation\n  Heatmap.prototype = {\n    addData: function() {\n      this._store.addData.apply(this._store, arguments);\n      return this;\n    },\n    removeData: function() {\n      this._store.removeData && this._store.removeData.apply(this._store, arguments);\n      return this;\n    },\n    setData: function() {\n      this._store.setData.apply(this._store, arguments);\n      return this;\n    },\n    setDataMax: function() {\n      this._store.setDataMax.apply(this._store, arguments);\n      return this;\n    },\n    setDataMin: function() {\n      this._store.setDataMin.apply(this._store, arguments);\n      return this;\n    },\n    configure: function(config) {\n      this._config = Util.merge(this._config, config);\n      this._renderer.updateConfig(this._config);\n      this._coordinator.emit('renderall', this._store._getInternalData());\n      return this;\n    },\n    repaint: function() {\n      this._coordinator.emit('renderall', this._store._getInternalData());\n      return this;\n    },\n    getData: function() {\n      return this._store.getData();\n    },\n    getDataURL: function() {\n      return this._renderer.getDataURL();\n    },\n    getValueAt: function(point) {\n\n      if (this._store.getValueAt) {\n        return this._store.getValueAt(point);\n      } else  if (this._renderer.getValueAt) {\n        return this._renderer.getValueAt(point);\n      } else {\n        return null;\n      }\n    }\n  };\n\n  return Heatmap;\n\n})();\n\n\n// core\nvar heatmapFactory = {\n  create: function(config) {\n    return new Heatmap(config);\n  },\n  register: function(pluginKey, plugin) {\n    HeatmapConfig.plugins[pluginKey] = plugin;\n  }\n};\n\nreturn heatmapFactory;\n\n\n});","module.exports = {\n    MOUSE_HOVERING: \"DATAVIZ_OBJECT_HOVERING\",\n    MOUSE_CLICK: \"DATAVIZ_OBJECT_CLICK\",\n    MOUSE_CLICK_OUT: \"DATAVIZ_CLICK_OUT\",\n};\n","class Rectangle {\n    /**\n     * Creates an instance of Rectangle.\n     *\n     * @param {number} [width=0]\n     * @param {number} [height=0]\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {boolean} [rot=false]\n     * @param {boolean} [allowRotation=false]\n     * @memberof Rectangle\n     */\n    constructor(width = 0, height = 0, x = 0, y = 0, rot = false, allowRotation = undefined) {\n        /**\n         * Oversized tag on rectangle which is bigger than packer itself.\n         *\n         * @type {boolean}\n         * @memberof Rectangle\n         */\n        this.oversized = false;\n        this._rot = false;\n        this._allowRotation = undefined;\n        this._dirty = 0;\n        this._width = width;\n        this._height = height;\n        this._x = x;\n        this._y = y;\n        this._data = {};\n        this._rot = rot;\n        this._allowRotation = allowRotation;\n    }\n    /**\n     * Test if two given rectangle collide each other\n     *\n     * @static\n     * @param {IRectangle} first\n     * @param {IRectangle} second\n     * @returns\n     * @memberof Rectangle\n     */\n    static Collide(first, second) { return first.collide(second); }\n    /**\n     * Test if the first rectangle contains the second one\n     *\n     * @static\n     * @param {IRectangle} first\n     * @param {IRectangle} second\n     * @returns\n     * @memberof Rectangle\n     */\n    static Contain(first, second) { return first.contain(second); }\n    /**\n     * Get the area (w * h) of the rectangle\n     *\n     * @returns {number}\n     * @memberof Rectangle\n     */\n    area() { return this.width * this.height; }\n    /**\n     * Test if the given rectangle collide with this rectangle.\n     *\n     * @param {IRectangle} rect\n     * @returns {boolean}\n     * @memberof Rectangle\n     */\n    collide(rect) {\n        return (rect.x < this.x + this.width &&\n            rect.x + rect.width > this.x &&\n            rect.y < this.y + this.height &&\n            rect.y + rect.height > this.y);\n    }\n    /**\n     * Test if this rectangle contains the given rectangle.\n     *\n     * @param {IRectangle} rect\n     * @returns {boolean}\n     * @memberof Rectangle\n     */\n    contain(rect) {\n        return (rect.x >= this.x && rect.y >= this.y &&\n            rect.x + rect.width <= this.x + this.width && rect.y + rect.height <= this.y + this.height);\n    }\n    get width() { return this._width; }\n    set width(value) {\n        if (value === this._width)\n            return;\n        this._width = value;\n        this._dirty++;\n    }\n    get height() { return this._height; }\n    set height(value) {\n        if (value === this._height)\n            return;\n        this._height = value;\n        this._dirty++;\n    }\n    get x() { return this._x; }\n    set x(value) {\n        if (value === this._x)\n            return;\n        this._x = value;\n        this._dirty++;\n    }\n    get y() { return this._y; }\n    set y(value) {\n        if (value === this._y)\n            return;\n        this._y = value;\n        this._dirty++;\n    }\n    /**\n     * If the rectangle is rotated\n     *\n     * @type {boolean}\n     * @memberof Rectangle\n     */\n    get rot() { return this._rot; }\n    /**\n     * Set the rotate tag of the rectangle.\n     *\n     * note: after `rot` is set, `width/height` of this rectangle is swaped.\n     *\n     * @memberof Rectangle\n     */\n    set rot(value) {\n        if (this._allowRotation === false)\n            return;\n        if (this._rot !== value) {\n            const tmp = this.width;\n            this.width = this.height;\n            this.height = tmp;\n            this._rot = value;\n            this._dirty++;\n        }\n    }\n    /**\n     * If the rectangle allow rotation\n     *\n     * @type {boolean}\n     * @memberof Rectangle\n     */\n    get allowRotation() { return this._allowRotation; }\n    /**\n     * Set the allowRotation tag of the rectangle.\n     *\n     * @memberof Rectangle\n     */\n    set allowRotation(value) {\n        if (this._allowRotation !== value) {\n            this._allowRotation = value;\n            this._dirty++;\n        }\n    }\n    get data() { return this._data; }\n    set data(value) {\n        if (value === null || value === this._data)\n            return;\n        this._data = value;\n        // extract allowRotation settings\n        if (typeof value === \"object\" && value.hasOwnProperty(\"allowRotation\")) {\n            this._allowRotation = value.allowRotation;\n        }\n        this._dirty++;\n    }\n    get dirty() { return this._dirty > 0; }\n    setDirty(value = true) { this._dirty = value ? this._dirty + 1 : 0; }\n}\n\nclass Bin {\n    constructor() {\n        this._dirty = 0;\n    }\n    get dirty() { return this._dirty > 0 || this.rects.some(rect => rect.dirty); }\n    /**\n     * Set bin dirty status\n     *\n     * @memberof Bin\n     */\n    setDirty(value = true) {\n        this._dirty = value ? this._dirty + 1 : 0;\n        if (!value) {\n            for (let rect of this.rects) {\n                if (rect.setDirty)\n                    rect.setDirty(false);\n            }\n        }\n    }\n}\n\nclass MaxRectsBin extends Bin {\n    constructor(maxWidth = EDGE_MAX_VALUE, maxHeight = EDGE_MAX_VALUE, padding = 0, options = {}) {\n        super();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this.padding = padding;\n        this.freeRects = [];\n        this.rects = [];\n        this.verticalExpand = false;\n        this.options = {\n            smart: true,\n            pot: true,\n            square: true,\n            allowRotation: false,\n            tag: false,\n            exclusiveTag: true,\n            border: 0,\n            logic: PACKING_LOGIC.MAX_EDGE\n        };\n        this.options = Object.assign(Object.assign({}, this.options), options);\n        this.width = this.options.smart ? 0 : maxWidth;\n        this.height = this.options.smart ? 0 : maxHeight;\n        this.border = this.options.border ? this.options.border : 0;\n        this.freeRects.push(new Rectangle(this.maxWidth + this.padding - this.border * 2, this.maxHeight + this.padding - this.border * 2, this.border, this.border));\n        this.stage = new Rectangle(this.width, this.height);\n    }\n    add(...args) {\n        let data;\n        let rect;\n        if (args.length === 1) {\n            if (typeof args[0] !== 'object')\n                throw new Error(\"MacrectsBin.add(): Wrong parameters\");\n            rect = args[0];\n            // Check if rect.tag match bin.tag, if bin.tag not defined, it will accept any rect\n            let tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n            if (this.options.tag && this.options.exclusiveTag && this.tag !== tag)\n                return undefined;\n        }\n        else {\n            data = args.length > 2 ? args[2] : null;\n            // Check if data.tag match bin.tag, if bin.tag not defined, it will accept any rect\n            if (this.options.tag && this.options.exclusiveTag) {\n                if (data && this.tag !== data.tag)\n                    return undefined;\n                if (!data && this.tag)\n                    return undefined;\n            }\n            rect = new Rectangle(args[0], args[1]);\n            rect.data = data;\n            rect.setDirty(false);\n        }\n        const result = this.place(rect);\n        if (result)\n            this.rects.push(result);\n        return result;\n    }\n    repack() {\n        let unpacked = [];\n        this.reset();\n        // re-sort rects from big to small\n        this.rects.sort((a, b) => {\n            const result = Math.max(b.width, b.height) - Math.max(a.width, a.height);\n            if (result === 0 && a.hash && b.hash) {\n                return a.hash > b.hash ? -1 : 1;\n            }\n            else\n                return result;\n        });\n        for (let rect of this.rects) {\n            if (!this.place(rect)) {\n                unpacked.push(rect);\n            }\n        }\n        for (let rect of unpacked)\n            this.rects.splice(this.rects.indexOf(rect), 1);\n        return unpacked.length > 0 ? unpacked : undefined;\n    }\n    reset(deepReset = false, resetOption = false) {\n        if (deepReset) {\n            if (this.data)\n                delete this.data;\n            if (this.tag)\n                delete this.tag;\n            this.rects = [];\n            if (resetOption) {\n                this.options = {\n                    smart: true,\n                    pot: true,\n                    square: true,\n                    allowRotation: false,\n                    tag: false,\n                    border: 0\n                };\n            }\n        }\n        this.width = this.options.smart ? 0 : this.maxWidth;\n        this.height = this.options.smart ? 0 : this.maxHeight;\n        this.border = this.options.border ? this.options.border : 0;\n        this.freeRects = [new Rectangle(this.maxWidth + this.padding - this.border * 2, this.maxHeight + this.padding - this.border * 2, this.border, this.border)];\n        this.stage = new Rectangle(this.width, this.height);\n        this._dirty = 0;\n    }\n    clone() {\n        let clonedBin = new MaxRectsBin(this.maxWidth, this.maxHeight, this.padding, this.options);\n        for (let rect of this.rects) {\n            clonedBin.add(rect);\n        }\n        return clonedBin;\n    }\n    place(rect) {\n        // recheck if tag matched\n        let tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n        if (this.options.tag && this.options.exclusiveTag && this.tag !== tag)\n            return undefined;\n        let node;\n        let allowRotation;\n        // getter/setter do not support hasOwnProperty()\n        if (rect.hasOwnProperty(\"_allowRotation\") && rect.allowRotation !== undefined) {\n            allowRotation = rect.allowRotation; // Per Rectangle allowRotation override packer settings\n        }\n        else {\n            allowRotation = this.options.allowRotation;\n        }\n        node = this.findNode(rect.width + this.padding, rect.height + this.padding, allowRotation);\n        if (node) {\n            this.updateBinSize(node);\n            let numRectToProcess = this.freeRects.length;\n            let i = 0;\n            while (i < numRectToProcess) {\n                if (this.splitNode(this.freeRects[i], node)) {\n                    this.freeRects.splice(i, 1);\n                    numRectToProcess--;\n                    i--;\n                }\n                i++;\n            }\n            this.pruneFreeList();\n            this.verticalExpand = this.width > this.height ? true : false;\n            rect.x = node.x;\n            rect.y = node.y;\n            if (rect.rot === undefined)\n                rect.rot = false;\n            rect.rot = node.rot ? !rect.rot : rect.rot;\n            this._dirty++;\n            return rect;\n        }\n        else if (!this.verticalExpand) {\n            if (this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.width + this.padding - this.border, this.border)) || this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.border, this.height + this.padding - this.border))) {\n                return this.place(rect);\n            }\n        }\n        else {\n            if (this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.border, this.height + this.padding - this.border)) || this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.width + this.padding - this.border, this.border))) {\n                return this.place(rect);\n            }\n        }\n        return undefined;\n    }\n    findNode(width, height, allowRotation) {\n        let score = Number.MAX_VALUE;\n        let areaFit;\n        let r;\n        let bestNode;\n        for (let i in this.freeRects) {\n            r = this.freeRects[i];\n            if (r.width >= width && r.height >= height) {\n                areaFit = (this.options.logic === PACKING_LOGIC.MAX_AREA) ?\n                    r.width * r.height - width * height :\n                    Math.min(r.width - width, r.height - height);\n                if (areaFit < score) {\n                    bestNode = new Rectangle(width, height, r.x, r.y);\n                    score = areaFit;\n                }\n            }\n            if (!allowRotation)\n                continue;\n            // Continue to test 90-degree rotated rectangle\n            if (r.width >= height && r.height >= width) {\n                areaFit = (this.options.logic === PACKING_LOGIC.MAX_AREA) ?\n                    r.width * r.height - height * width :\n                    Math.min(r.height - width, r.width - height);\n                if (areaFit < score) {\n                    bestNode = new Rectangle(height, width, r.x, r.y, true); // Rotated node\n                    score = areaFit;\n                }\n            }\n        }\n        return bestNode;\n    }\n    splitNode(freeRect, usedNode) {\n        // Test if usedNode intersect with freeRect\n        if (!freeRect.collide(usedNode))\n            return false;\n        // Do vertical split\n        if (usedNode.x < freeRect.x + freeRect.width && usedNode.x + usedNode.width > freeRect.x) {\n            // New node at the top side of the used node\n            if (usedNode.y > freeRect.y && usedNode.y < freeRect.y + freeRect.height) {\n                let newNode = new Rectangle(freeRect.width, usedNode.y - freeRect.y, freeRect.x, freeRect.y);\n                this.freeRects.push(newNode);\n            }\n            // New node at the bottom side of the used node\n            if (usedNode.y + usedNode.height < freeRect.y + freeRect.height) {\n                let newNode = new Rectangle(freeRect.width, freeRect.y + freeRect.height - (usedNode.y + usedNode.height), freeRect.x, usedNode.y + usedNode.height);\n                this.freeRects.push(newNode);\n            }\n        }\n        // Do Horizontal split\n        if (usedNode.y < freeRect.y + freeRect.height &&\n            usedNode.y + usedNode.height > freeRect.y) {\n            // New node at the left side of the used node.\n            if (usedNode.x > freeRect.x && usedNode.x < freeRect.x + freeRect.width) {\n                let newNode = new Rectangle(usedNode.x - freeRect.x, freeRect.height, freeRect.x, freeRect.y);\n                this.freeRects.push(newNode);\n            }\n            // New node at the right side of the used node.\n            if (usedNode.x + usedNode.width < freeRect.x + freeRect.width) {\n                let newNode = new Rectangle(freeRect.x + freeRect.width - (usedNode.x + usedNode.width), freeRect.height, usedNode.x + usedNode.width, freeRect.y);\n                this.freeRects.push(newNode);\n            }\n        }\n        return true;\n    }\n    pruneFreeList() {\n        // Go through each pair of freeRects and remove any rects that is redundant\n        let i = 0;\n        let j = 0;\n        let len = this.freeRects.length;\n        while (i < len) {\n            j = i + 1;\n            let tmpRect1 = this.freeRects[i];\n            while (j < len) {\n                let tmpRect2 = this.freeRects[j];\n                if (tmpRect2.contain(tmpRect1)) {\n                    this.freeRects.splice(i, 1);\n                    i--;\n                    len--;\n                    break;\n                }\n                if (tmpRect1.contain(tmpRect2)) {\n                    this.freeRects.splice(j, 1);\n                    j--;\n                    len--;\n                }\n                j++;\n            }\n            i++;\n        }\n    }\n    updateBinSize(node) {\n        if (!this.options.smart)\n            return false;\n        if (this.stage.contain(node))\n            return false;\n        let tmpWidth = Math.max(this.width, node.x + node.width - this.padding + this.border);\n        let tmpHeight = Math.max(this.height, node.y + node.height - this.padding + this.border);\n        if (this.options.allowRotation) {\n            // do extra test on rotated node whether it's a better choice\n            const rotWidth = Math.max(this.width, node.x + node.height - this.padding + this.border);\n            const rotHeight = Math.max(this.height, node.y + node.width - this.padding + this.border);\n            if (rotWidth * rotHeight < tmpWidth * tmpHeight) {\n                tmpWidth = rotWidth;\n                tmpHeight = rotHeight;\n            }\n        }\n        if (this.options.pot) {\n            tmpWidth = Math.pow(2, Math.ceil(Math.log(tmpWidth) * Math.LOG2E));\n            tmpHeight = Math.pow(2, Math.ceil(Math.log(tmpHeight) * Math.LOG2E));\n        }\n        if (this.options.square) {\n            tmpWidth = tmpHeight = Math.max(tmpWidth, tmpHeight);\n        }\n        if (tmpWidth > this.maxWidth + this.padding || tmpHeight > this.maxHeight + this.padding) {\n            return false;\n        }\n        this.expandFreeRects(tmpWidth + this.padding, tmpHeight + this.padding);\n        this.width = this.stage.width = tmpWidth;\n        this.height = this.stage.height = tmpHeight;\n        return true;\n    }\n    expandFreeRects(width, height) {\n        this.freeRects.forEach((freeRect, index) => {\n            if (freeRect.x + freeRect.width >= Math.min(this.width + this.padding - this.border, width)) {\n                freeRect.width = width - freeRect.x - this.border;\n            }\n            if (freeRect.y + freeRect.height >= Math.min(this.height + this.padding - this.border, height)) {\n                freeRect.height = height - freeRect.y - this.border;\n            }\n        }, this);\n        this.freeRects.push(new Rectangle(width - this.width - this.padding, height - this.border * 2, this.width + this.padding - this.border, this.border));\n        this.freeRects.push(new Rectangle(width - this.border * 2, height - this.height - this.padding, this.border, this.height + this.padding - this.border));\n        this.freeRects = this.freeRects.filter(freeRect => {\n            return !(freeRect.width <= 0 || freeRect.height <= 0 || freeRect.x < this.border || freeRect.y < this.border);\n        });\n        this.pruneFreeList();\n    }\n}\n\nclass OversizedElementBin extends Bin {\n    constructor(...args) {\n        super();\n        this.rects = [];\n        if (args.length === 1) {\n            if (typeof args[0] !== 'object')\n                throw new Error(\"OversizedElementBin: Wrong parameters\");\n            const rect = args[0];\n            this.rects = [rect];\n            this.width = rect.width;\n            this.height = rect.height;\n            this.data = rect.data;\n            rect.oversized = true;\n        }\n        else {\n            this.width = args[0];\n            this.height = args[1];\n            this.data = args.length > 2 ? args[2] : null;\n            const rect = new Rectangle(this.width, this.height);\n            rect.oversized = true;\n            rect.data = this.data;\n            this.rects.push(rect);\n        }\n        this.freeRects = [];\n        this.maxWidth = this.width;\n        this.maxHeight = this.height;\n        this.options = { smart: false, pot: false, square: false };\n    }\n    add() { return undefined; }\n    reset(deepReset = false) {\n        // nothing to do here\n    }\n    repack() { return undefined; }\n    clone() {\n        let clonedBin = new OversizedElementBin(this.rects[0]);\n        return clonedBin;\n    }\n}\n\nconst EDGE_MAX_VALUE = 4096;\nvar PACKING_LOGIC;\n(function (PACKING_LOGIC) {\n    PACKING_LOGIC[PACKING_LOGIC[\"MAX_AREA\"] = 0] = \"MAX_AREA\";\n    PACKING_LOGIC[PACKING_LOGIC[\"MAX_EDGE\"] = 1] = \"MAX_EDGE\";\n})(PACKING_LOGIC || (PACKING_LOGIC = {}));\nclass MaxRectsPacker {\n    /**\n     * Creates an instance of MaxRectsPacker.\n     * @param {number} width of the output atlas (default is 4096)\n     * @param {number} height of the output atlas (default is 4096)\n     * @param {number} padding between glyphs/images (default is 0)\n     * @param {IOption} [options={}] (Optional) packing options\n     * @memberof MaxRectsPacker\n     */\n    constructor(width = EDGE_MAX_VALUE, height = EDGE_MAX_VALUE, padding = 0, options = {}) {\n        this.width = width;\n        this.height = height;\n        this.padding = padding;\n        /**\n         * Options for MaxRect Packer\n         * @property {boolean} options.smart Smart sizing packer (default is true)\n         * @property {boolean} options.pot use power of 2 sizing (default is true)\n         * @property {boolean} options.square use square size (default is false)\n         * @property {boolean} options.allowRotation allow rotation packing (default is false)\n         * @property {boolean} options.tag allow auto grouping based on `rect.tag` (default is false)\n         * @property {boolean} options.exclusiveTag tagged rects will have dependent bin, if set to `false`, packer will try to put tag rects into the same bin (default is true)\n         * @property {boolean} options.border atlas edge spacing (default is 0)\n         * @property {PACKING_LOGIC} options.logic MAX_AREA or MAX_EDGE based sorting logic (default is MAX_EDGE)\n         * @export\n         * @interface Option\n         */\n        this.options = {\n            smart: true,\n            pot: true,\n            square: false,\n            allowRotation: false,\n            tag: false,\n            exclusiveTag: true,\n            border: 0,\n            logic: PACKING_LOGIC.MAX_EDGE\n        };\n        this._currentBinIndex = 0;\n        this.bins = [];\n        this.options = Object.assign(Object.assign({}, this.options), options);\n    }\n    add(...args) {\n        if (args.length === 1) {\n            if (typeof args[0] !== 'object')\n                throw new Error(\"MacrectsPacker.add(): Wrong parameters\");\n            const rect = args[0];\n            if (rect.width > this.width || rect.height > this.height) {\n                this.bins.push(new OversizedElementBin(rect));\n            }\n            else {\n                let added = this.bins.slice(this._currentBinIndex).find(bin => bin.add(rect) !== undefined);\n                if (!added) {\n                    let bin = new MaxRectsBin(this.width, this.height, this.padding, this.options);\n                    let tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n                    if (this.options.tag && tag)\n                        bin.tag = tag;\n                    bin.add(rect);\n                    this.bins.push(bin);\n                }\n            }\n            return rect;\n        }\n        else {\n            const rect = new Rectangle(args[0], args[1]);\n            if (args.length > 2)\n                rect.data = args[2];\n            if (rect.width > this.width || rect.height > this.height) {\n                this.bins.push(new OversizedElementBin(rect));\n            }\n            else {\n                let added = this.bins.slice(this._currentBinIndex).find(bin => bin.add(rect) !== undefined);\n                if (!added) {\n                    let bin = new MaxRectsBin(this.width, this.height, this.padding, this.options);\n                    if (this.options.tag && rect.data.tag)\n                        bin.tag = rect.data.tag;\n                    bin.add(rect);\n                    this.bins.push(bin);\n                }\n            }\n            return rect;\n        }\n    }\n    /**\n     * Add an Array of bins/rectangles to the packer.\n     *\n     * `Javascript`: Any object has property: { width, height, ... } is accepted.\n     *\n     * `Typescript`: object shall extends `MaxrectsPacker.IRectangle`.\n     *\n     * note: object has `hash` property will have more stable packing result\n     *\n     * @param {IRectangle[]} rects Array of bin/rectangles\n     * @memberof MaxRectsPacker\n     */\n    addArray(rects) {\n        if (!this.options.tag || this.options.exclusiveTag) {\n            // if not using tag or using exclusiveTag, old approach\n            this.sort(rects, this.options.logic).forEach(rect => this.add(rect));\n        }\n        else {\n            // sort rects by tags first\n            if (rects.length === 0)\n                return;\n            rects.sort((a, b) => {\n                const aTag = (a.data && a.data.tag) ? a.data.tag : a.tag ? a.tag : undefined;\n                const bTag = (b.data && b.data.tag) ? b.data.tag : b.tag ? b.tag : undefined;\n                return bTag === undefined ? -1 : aTag === undefined ? 1 : bTag > aTag ? -1 : 1;\n            });\n            // iterate all bins to find the first bin which can place rects with same tag\n            //\n            let currentTag;\n            let currentIdx = 0;\n            let targetBin = this.bins.slice(this._currentBinIndex).find(bin => {\n                let testBin = bin.clone();\n                for (let i = currentIdx; i < rects.length; i++) {\n                    const rect = rects[i];\n                    const tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n                    // initialize currentTag\n                    if (i === 0)\n                        currentTag = tag;\n                    if (tag !== currentTag) {\n                        // all current tag memeber tested successfully\n                        currentTag = tag;\n                        // do addArray()\n                        this.sort(rects.slice(currentIdx, i), this.options.logic).forEach(r => bin.add(r));\n                        currentIdx = i;\n                        // recrusively addArray() with remaining rects\n                        this.addArray(rects.slice(i));\n                        return true;\n                    }\n                    // remaining untagged rect will use normal addArray()\n                    if (tag === undefined) {\n                        // do addArray()\n                        this.sort(rects.slice(i), this.options.logic).forEach(r => this.add(r));\n                        currentIdx = rects.length;\n                        // end test\n                        return true;\n                    }\n                    // still in the same tag group\n                    if (testBin.add(rect) === undefined) {\n                        // current bin cannot contain all tag members\n                        // procceed to test next bin\n                        return false;\n                    }\n                }\n                // all rects tested\n                // do addArray() to the remaining tag group\n                this.sort(rects.slice(currentIdx), this.options.logic).forEach(r => bin.add(r));\n                return true;\n            });\n            // create a new bin if no current bin fit\n            if (!targetBin) {\n                const rect = rects[currentIdx];\n                const bin = new MaxRectsBin(this.width, this.height, this.padding, this.options);\n                const tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n                if (this.options.tag && this.options.exclusiveTag && tag)\n                    bin.tag = tag;\n                this.bins.push(bin);\n                this.addArray(rects.slice(currentIdx));\n            }\n        }\n    }\n    /**\n     * Reset entire packer to initial states, keep settings\n     *\n     * @memberof MaxRectsPacker\n     */\n    reset() {\n        this.bins = [];\n        this._currentBinIndex = 0;\n    }\n    /**\n     * Repack all elements inside bins\n     *\n     * @param {boolean} [quick=true] quick repack only dirty bins\n     * @returns {void}\n     * @memberof MaxRectsPacker\n     */\n    repack(quick = true) {\n        if (quick) {\n            let unpack = [];\n            for (let bin of this.bins) {\n                if (bin.dirty) {\n                    let up = bin.repack();\n                    if (up)\n                        unpack.push(...up);\n                }\n            }\n            this.addArray(unpack);\n            return;\n        }\n        if (!this.dirty)\n            return;\n        const allRects = this.rects;\n        this.reset();\n        this.addArray(allRects);\n    }\n    /**\n     * Stop adding new element to the current bin and return a new bin.\n     *\n     * note: After calling `next()` all elements will no longer added to previous bins.\n     *\n     * @returns {Bin}\n     * @memberof MaxRectsPacker\n     */\n    next() {\n        this._currentBinIndex = this.bins.length;\n        return this._currentBinIndex;\n    }\n    /**\n     * Load bins to the packer, overwrite exist bins\n     * @param {MaxRectsBin[]} bins MaxRectsBin objects\n     * @memberof MaxRectsPacker\n     */\n    load(bins) {\n        bins.forEach((bin, index) => {\n            if (bin.maxWidth > this.width || bin.maxHeight > this.height) {\n                this.bins.push(new OversizedElementBin(bin.width, bin.height, {}));\n            }\n            else {\n                let newBin = new MaxRectsBin(this.width, this.height, this.padding, bin.options);\n                newBin.freeRects.splice(0);\n                bin.freeRects.forEach((r, i) => {\n                    newBin.freeRects.push(new Rectangle(r.width, r.height, r.x, r.y));\n                });\n                newBin.width = bin.width;\n                newBin.height = bin.height;\n                if (bin.tag)\n                    newBin.tag = bin.tag;\n                this.bins[index] = newBin;\n            }\n        }, this);\n    }\n    /**\n     * Output current bins to save\n     * @memberof MaxRectsPacker\n     */\n    save() {\n        let saveBins = [];\n        this.bins.forEach((bin => {\n            let saveBin = {\n                width: bin.width,\n                height: bin.height,\n                maxWidth: bin.maxWidth,\n                maxHeight: bin.maxHeight,\n                freeRects: [],\n                rects: [],\n                options: bin.options\n            };\n            if (bin.tag)\n                saveBin = Object.assign(Object.assign({}, saveBin), { tag: bin.tag });\n            bin.freeRects.forEach(r => {\n                saveBin.freeRects.push({\n                    x: r.x,\n                    y: r.y,\n                    width: r.width,\n                    height: r.height\n                });\n            });\n            saveBins.push(saveBin);\n        }));\n        return saveBins;\n    }\n    /**\n     * Sort the given rects based on longest edge or surface area.\n     *\n     * If rects have the same sort value, will sort by second key `hash` if presented.\n     *\n     * @private\n     * @param {T[]} rects\n     * @param {PACKING_LOGIC} [logic=PACKING_LOGIC.MAX_EDGE] sorting logic, \"area\" or \"edge\"\n     * @returns\n     * @memberof MaxRectsPacker\n     */\n    sort(rects, logic = PACKING_LOGIC.MAX_EDGE) {\n        return rects.slice().sort((a, b) => {\n            const result = (logic === PACKING_LOGIC.MAX_EDGE) ?\n                Math.max(b.width, b.height) - Math.max(a.width, a.height) :\n                b.width * b.height - a.width * a.height;\n            if (result === 0 && a.hash && b.hash) {\n                return a.hash > b.hash ? -1 : 1;\n            }\n            else\n                return result;\n        });\n    }\n    /**\n     * Return current functioning bin index, perior to this wont accept any new elements\n     *\n     * @readonly\n     * @type {number}\n     * @memberof MaxRectsPacker\n     */\n    get currentBinIndex() { return this._currentBinIndex; }\n    /**\n     * Returns dirty status of all child bins\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof MaxRectsPacker\n     */\n    get dirty() { return this.bins.some(bin => bin.dirty); }\n    /**\n     * Return all rectangles in this packer\n     *\n     * @readonly\n     * @type {T[]}\n     * @memberof MaxRectsPacker\n     */\n    get rects() {\n        let allRects = [];\n        for (let bin of this.bins) {\n            allRects.push(...bin.rects);\n        }\n        return allRects;\n    }\n}\n\nexport { Bin, MaxRectsBin, MaxRectsPacker, OversizedElementBin, PACKING_LOGIC, Rectangle };\n//# sourceMappingURL=maxrects-packer.mjs.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","/**\n * Tool that will handle the selection/hightlight for the model created by the CustomModelScene\n */\n\nimport { MOUSE_CLICK, MOUSE_CLICK_OUT, MOUSE_HOVERING } from \"./Constants.js\";\n\nvar av = Autodesk.Viewing;\nconst GlobalManagerMixin = av.GlobalManagerMixin;\n\nexport class SceneTool extends av.ToolInterface {\n    constructor(viewer, options = {}) {\n        super();\n        this.names = [\"HyperionTool\"];\n\n        this.options = options;\n        this.setGlobalManager(viewer.globalManager);\n\n        this.viewer = viewer;\n        this.delegate = options.delegate;\n\n        this.init();\n\n        this.hoveringDbId = 0;\n        this.selectedDbId = 0;\n    }\n\n    init() {\n        let viewerImpl = this.viewer.impl;\n\n        this.activate = (name) => {\n            this.active = true;\n        };\n\n        this.deactivate = (name) => {\n            this.clearMarkedObject();\n            this.active = false;\n        };\n\n        this.handleSingleClick = (event, button) => {\n            let isEventHandled = false;\n\n            if (button === 0) {\n                const res = [];\n                const vpVec = viewerImpl.clientToViewport(event.canvasX, event.canvasY);\n\n                const renderer = viewerImpl.renderer();\n                const overlayIdTarget = renderer.getOverlayIdTarget();\n                if (!overlayIdTarget) {\n                    return false;\n                }\n\n                const dbId = renderer.idAtPixel(vpVec.x, vpVec.y, res, [overlayIdTarget]);\n\n                // This handles two scenarios: (1) there is a change in selection\n                // (i.e. going between with/without selection, or go from one selection to\n                // another selection); (2) user continues to click outside all the sprites.\n                //\n                if (this.selectedDbId != dbId || this.selectedDbId == 0) {\n                    // When `dbId === 0` user clicks on an empty spot with no sprite.\n                    // If there was a selected sprite, then we need to dispatch a\n                    // `MOUSE_CLICK_OUT` event so client code has the chance to clear\n                    // any changes that came with the previous click-selection event.\n                    //\n                    if (this.selectedDbId) {\n                        const clickEvent = {\n                            type: MOUSE_CLICK_OUT,\n                            dbId: this.selectedDbId,\n                            originalEvent: event,\n                        };\n\n                        this.viewer.dispatchEvent(clickEvent);\n                        if (!clickEvent.hasStopped) {\n                            this.clearMarkedObject();\n                            this.viewer.impl.invalidate(false, false, true);\n                        }\n                    }\n\n                    // Update selection to the new `dbId` (even if it is `0`)\n                    this.selectedDbId = dbId;\n                    const clickedViewPoint = viewerImpl.hitTestViewport(vpVec.clone(), false);\n\n                    // If there is a new selection, raise selection event.\n                    const clickEvent = {\n                        type: MOUSE_CLICK,\n                        dbId,\n                        clickInfo: clickedViewPoint,\n                        originalEvent: event,\n                    };\n\n                    this.viewer.dispatchEvent(clickEvent);\n                    if (!clickEvent.hasStopped) {\n                        this.markObject([dbId]);\n                        this.viewer.impl.invalidate(false, false, true);\n                    }\n\n                    // Setting 'isEventHandled = true' causes default viewer object selecction\n                    // to be turned off (i.e. no object that is clicked on will be selected).\n                    // We only want that when user clicks on any sprite, otherwise the default\n                    // viewer selection should be allowed to continue.\n                    //\n                    if (this.selectedDbId) {\n                        isEventHandled = true;\n                    }\n                }\n            }\n\n            return isEventHandled;\n        };\n\n        this.handleSingleTap = (event) => {\n            return this.handleSingleClick(event, 0);\n        };\n\n        this.handleDoubleClick = (event, button) => {\n            return false;\n        };\n\n        this.handleButtonDown = (event) => {\n            this.buttonDown = true;\n            return false;\n        };\n\n        this.handleButtonUp = (event) => {\n            this.buttonDown = false;\n            return false;\n        };\n\n        this.handleMouseMove = (event) => {\n            if (!this.buttonDown) {\n                const vpVec = viewerImpl.clientToViewport(event.canvasX, event.canvasY);\n                const overlayIdTarget = viewerImpl.renderer().getOverlayIdTarget();\n\n                if (!overlayIdTarget) {\n                    return false;\n                }\n\n                const res = [];\n                const dbId = viewerImpl\n                    .renderer()\n                    .idAtPixel(vpVec.x, vpVec.y, res, [overlayIdTarget]);\n\n                // There is a change in sprite that is hovered over\n                if (this.hoveringDbId != dbId) {\n                    // The mouse has either hovered over a new sprite, or hovered off\n                    // an existing sprite. When the mouse first hovers over a sprite,\n                    // the `targetDbId` should be the `dbId` of the sprite that the mouse\n                    // cursor just entered. When the mouse hovers off an existing sprite\n                    // it was on (i.e. when `dbId` becomes `0`), then the `targetDbId`\n                    // should be the `dbId` of that existing sprite (which in this case,\n                    // is the `hoveringDbId`).\n                    //\n                    const targetDbId = dbId != 0 ? dbId : this.hoveringDbId;\n                    this.hoveringDbId = dbId;\n\n                    const hovering = dbId != 0;\n                    this.viewer.dispatchEvent({\n                        type: MOUSE_HOVERING,\n                        dbId: targetDbId,\n                        hovering: hovering,\n                        originalEvent: event,\n                    });\n\n                    return true; // Dispatched the event.\n                }\n            }\n        };\n\n        this.markObject = (dbIds) => {\n            if (!(dbIds instanceof Array)) {\n                dbIds = [dbIds];\n            }\n\n            if (!this.delegate.hasViewables) {\n                return; // There's no viewable in the scene\n            }\n\n            let geometries = this.delegate.mapDbIdsToGeometries(dbIds);\n            let dbIdIndex = new Set(dbIds);\n\n            geometries.map((geometry) => {\n                // here we need to update the attribute of the geometry\n                if (geometry && geometry.attributes[\"id\"] && geometry.attributes[\"pointScale\"]) {\n                    let scale = geometry.attributes[\"pointScale\"].array;\n                    let uvp = geometry.attributes[\"uvp\"].array;\n                    let colors = geometry.attributes[\"color\"].array;\n                    let ids = geometry.attributes[\"id\"].array;\n\n                    for (let i = 0; i < ids.length; i += 3) {\n                        let id = ids[i] + (ids[i + 1] << 8) + (ids[i + 2] << 16);\n                        let index = i / 3;\n                        const isHighlighted = dbIdIndex.has(id);\n                        scale[index] = isHighlighted ? 1.5 : 1;\n                        let uv = this.delegate.viewableData.getViewableUV(id, isHighlighted);\n\n                        if (uv) {\n                            uvp[index * 4] = uv.x;\n                            uvp[index * 4 + 1] = uv.y;\n                            uvp[index * 4 + 2] = uv.w;\n                            uvp[index * 4 + 3] = uv.h;\n                        }\n\n                        let color = this.delegate.viewableData.getViewableColor(id, isHighlighted);\n\n                        if (color) {\n                            colors[index * 3] = color.r * 255;\n                            colors[index * 3 + 1] = color.g * 255;\n                            colors[index * 3 + 2] = color.b * 255;\n                        }\n                    }\n\n                    geometry.attributes[\"pointScale\"].needsUpdate = true;\n                    geometry.attributes[\"uvp\"].needsUpdate = true;\n                    geometry.attributes[\"color\"].needsUpdate = true;\n                }\n            });\n\n            this.markedFragments = geometries;\n        };\n\n        this.clearMarkedObject = () => {\n            if (!this.delegate.hasViewables) {\n                this.markedFragments = [];\n                return; // There's no viewable in the scene\n            }\n\n            const fragments = this.markedFragments || [];\n            this.markedFragments = []; // Clear internal references.\n\n            if (fragments) {\n                fragments.map((geometry) => {\n                    // here we need to update the attribute of the geometry\n                    if (geometry && geometry.attributes[\"pointScale\"]) {\n                        let scale = geometry.attributes[\"pointScale\"].array;\n                        let uvp = geometry.attributes[\"uvp\"].array;\n                        let colors = geometry.attributes[\"color\"].array;\n                        let ids = geometry.attributes[\"id\"].array;\n                        for (let i = 0; i < ids.length; i += 3) {\n                            let id = ids[i] + (ids[i + 1] << 8) + (ids[i + 2] << 16);\n                            let index = i / 3;\n                            scale[index] = 1;\n                            let uv = this.delegate.viewableData.getViewableUV(id, false);\n                            if (uv) {\n                                uvp[index * 4] = uv.x;\n                                uvp[index * 4 + 1] = uv.y;\n                                uvp[index * 4 + 2] = uv.w;\n                                uvp[index * 4 + 3] = uv.h;\n                            }\n                            let color = this.delegate.viewableData.getViewableColor(id, false);\n                            if (color) {\n                                colors[index * 3] = color.r * 255;\n                                colors[index * 3 + 1] = color.g * 255;\n                                colors[index * 3 + 2] = color.b * 255;\n                            }\n                        }\n                        geometry.attributes[\"pointScale\"].needsUpdate = true;\n                        geometry.attributes[\"uvp\"].needsUpdate = true;\n                        geometry.attributes[\"color\"].needsUpdate = true;\n                    }\n                });\n\n                this.viewer.impl.invalidate(false, false, true);\n            }\n        };\n\n        this.invalidateViewablesDirect = (dbIds, meshes, viewableData, callback) => {\n            if (!dbIds || !meshes || !callback) {\n                throw new Error(\"Parameters of 'invalidateViewables' are mandatory\");\n            }\n\n            if (!(dbIds instanceof Array)) {\n                dbIds = [dbIds];\n            }\n\n            const dbIdSet = new Set(dbIds);\n\n            /** @type {Map<number, CustomViewable>} */\n            const viewables = new Map();\n            viewableData.viewables.forEach((v) => viewables.set(v.dbId, v));\n\n            let sceneUpdated = false;\n\n            const mesh = meshes[0];\n            const geometry = mesh.geometry;\n            const ids = geometry.attributes[\"id\"].array;\n\n            for (let i = 0; i < ids.length; i += 3) {\n                const dbId = ids[i] + (ids[i + 1] << 8) + (ids[i + 2] << 16);\n                if (!dbIdSet.has(dbId)) {\n                    continue;\n                }\n\n                const updates = callback(viewables.get(dbId));\n                if (!updates) {\n                    continue;\n                }\n\n                const pointIndex = i / 3;\n                if (updates.position) {\n                    const positions = geometry.attributes[\"position\"].array;\n                    geometry.attributes[\"position\"].needsUpdate = true;\n                    positions[pointIndex * 3 + 0] = updates.position.x;\n                    positions[pointIndex * 3 + 1] = updates.position.y;\n                    positions[pointIndex * 3 + 2] = updates.position.z;\n\n                    sceneUpdated = true;\n                }\n\n                if (updates.url) {\n                    const uv = viewableData.getSpriteUV(updates.url);\n                    if (uv) {\n                        const uvp = geometry.attributes[\"uvp\"].array;\n                        geometry.attributes[\"uvp\"].needsUpdate = true;\n                        uvp[pointIndex * 4 + 0] = uv.x;\n                        uvp[pointIndex * 4 + 1] = uv.y;\n                        uvp[pointIndex * 4 + 2] = uv.w;\n                        uvp[pointIndex * 4 + 3] = uv.h;\n\n                        sceneUpdated = true;\n                    }\n                }\n\n                if (updates.color) {\n                    const colors = geometry.attributes[\"color\"].array;\n                    geometry.attributes[\"color\"].needsUpdate = true;\n                    colors[pointIndex * 3 + 0] = updates.color.r * 255;\n                    colors[pointIndex * 3 + 1] = updates.color.g * 255;\n                    colors[pointIndex * 3 + 2] = updates.color.b * 255;\n\n                    sceneUpdated = true;\n                }\n\n                if (updates.scale !== undefined) {\n                    if (updates.scale > 2.0 || updates.scale < 0) {\n                        const msg = `invalidateViewables: 'scale' of '${updates.scale}' out of range [0, 2]`;\n                        console.warn(msg);\n                    }\n                    const scale = geometry.attributes[\"pointScale\"].array;\n                    geometry.attributes[\"pointScale\"].needsUpdate = true;\n                    scale[pointIndex] = updates.scale;\n\n                    sceneUpdated = true;\n                }\n            }\n\n            if (sceneUpdated) {\n                this.viewer.impl.invalidate(false, false, true);\n            }\n        };\n    }\n}\n\nGlobalManagerMixin.call(SceneTool.prototype);\n","import { MaxRectsPacker } from \"maxrects-packer\";\nimport Q from \"q\";\n\nconst avp = Autodesk.Viewing.Private;\n\nclass SpriteAtlas {\n    constructor(width = 1920, height = 1080, padding = 2) {\n        this.width = width;\n        this.height = height;\n        this.padding = padding;\n\n        this.spritesMap = {};\n        this.pending = [];\n        this.images = [];\n\n        this.logger = avp.logger;\n        this.packer = new MaxRectsPacker(this.width, this.height, this.padding, {\n            smart: true,\n            pot: false,\n            square: false,\n            allowRotation: false,\n            tag: false,\n            border: 0\n        });\n        this.canvas = document.createElement(\"canvas\");\n        this.hasContent = false;\n    }\n\n    addSprite(url) {\n        if (this.spritesMap[url] == undefined) {\n            let defer = Q.defer();\n            let image = new Image();\n            image.crossOrigin = \"anonymous\";\n\n            image.onload = () => {\n                this.images.push({\n                    url,\n                    image,\n                    width: image.width,\n                    height: image.height\n                });\n                defer.resolve();\n            };\n\n            image.onerror = (error) => {\n                this.logger.error(error);\n                defer.resolve();\n            };\n\n            image.src = url;\n            this.spritesMap[url] = 1;\n            this.pending.push(defer.promise);\n        }\n    }\n\n    get canvasWidth() {\n        return this.canvas.width;\n    }\n\n    get canvasHeight() {\n        return this.canvas.height;\n    }\n\n    async finish() {\n        await Q.all(this.pending);\n        let canvas = this.canvas;\n\n        this.packer.addArray(this.images);\n\n        this.images.length = 0;\n        this.packer.bins.forEach((bin) => {\n            canvas.width = bin.width;\n            canvas.height = bin.height;\n\n            let ctx = canvas.getContext(\"2d\");\n\n            bin.rects.forEach((rect) => {\n                if (rect.image) {\n                    ctx.drawImage(rect.image, rect.x, rect.y);\n                    rect.image = undefined;\n\n                    this.spritesMap[rect.url] = rect;\n                    rect.url = undefined;\n                }\n            });\n        });\n    }\n\n    spriteUV(url) {\n        let item = this.spritesMap[url];\n        if (item) {\n            return {\n                x: item.x / this.canvasWidth,\n                y: item.y / this.canvasHeight,\n                w: (item.x + item.width) / this.canvasWidth,\n                h: (item.y + item.height) / this.canvasHeight\n            };\n        } else {\n            return {\n                x: 0,\n                y: 0,\n                w: 1,\n                h: 1\n            };\n        }\n    }\n}\n\nexport {\n    SpriteAtlas\n};\n","import { SpriteAtlas } from \"./SpriteAtlas\";\n\nconst ViewableType = {\n    SPRITE: 1,\n    GEOMETRY: 2,\n};\n\n/**\n * A visual style definition for a CustomViewable object.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.ViewableStyle\n */\nclass ViewableStyle {\n    /**\n     * Constructs an instance of `ViewableStyle` object that describes the style\n     * to be applied for any given `CustomViewable` object.\n     *\n     * @param {number} type The type of viewable. Possible values are listed\n     * in `ViewableType`.\n     * @param {THREE.Color} color The color of the viewable, default to white.\n     * @param {string} url The URL of the sprite to be used for the viewable.\n     * Image formats supported are the same as those of `HTMLImageElement`.\n     * @param {THREE.Color} highlightedColor The highlighted color of the viewable,\n     * default to white. This color will be used when a `CustomViewable` is\n     * highlighted with a call to `highlightViewables` API.\n     * @param {string} highlightedUrl The URL of the highlighted sprite to be used\n     * for the viewable. This sprite will be used when a `CustomViewable` is\n     * highlighted with a call to `highlightViewables` API. Image formats\n     * supported are the same as those of `HTMLImageElement`.\n     * @param {string[]} animatedUrls Array of sprite urls that can be used to \n     * animate the icon.\n     * \n     * @example\n     *  const white = 0xffffff;\n     *  const iconUrl = \"http://localhost:9081/images/device-type-01.svg\";\n     *\n     *  const style = new Autodesk.DataVisualization.Core.ViewableStyle(\n     *      \"DeviceType01\",\n     *      Autodesk.DataVisualization.Core.ViewableType.SPRITE,\n     *      new THREE.Color(white),\n     *      iconUrl\n     *  );\n     */\n    constructor(\n        type = ViewableType.SPRITE,\n        color = new THREE.Color(0xffffff),\n        url = \"\",\n        highlightedColor = new THREE.Color(0xffffff),\n        highlightedUrl = \"\",\n        animatedUrls = []\n    ) {\n        this.type = type;\n        this.color = color;\n        this.url = url;\n        this.highlightedColor = highlightedColor;\n        this.highlightedUrl = highlightedUrl;\n\n        /** @type {Set<string>} */\n        this.spriteUrls = new Set(animatedUrls);\n    }\n\n    /**\n     * An array of sprite URL strings to be preloaded.\n     * @returns {string[]} An array of sprite URL strings to be preloaded.\n     */\n    get preloadedSprites() {\n        return [...this.spriteUrls.values()];\n    }\n\n    /**\n     * Preloads a sprite into `ViewableStyle` object for later use.\n     *\n     * @param {string} spriteUrl The URL of the sprite image to be preloaded for\n     * subsequent use in `CustomViewable` objects. Image formats supported are\n     * the same as those of `HTMLImageElement`. Calling this method with the same\n     * URL will only preload the image once.\n     *\n     * @alias Autodesk.DataVisualization.Core.ViewableStyle#preloadSprite\n     */\n    preloadSprite(spriteUrl) {\n        this.spriteUrls.add(spriteUrl);\n    }\n}\n\n/**\n * The generic base class of custom viewable types.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.CustomViewable\n */\nclass CustomViewable {\n    /**\n     * Constructs an instance of `CustomViewable` object. This class is not meant to be\n     * used directly, use the `SpriteViewable` class instead.\n     *\n     * @param {THREE.Vector3} position The position of the viewable in world coordinates.\n     * @param {ViewableStyle} style The style definition of this custom viewable object.\n     * @param {number} dbId The `DbId` of this custom viewable object. This value is used\n     * to identify the viewable when user input events such as mouse clicks are handled.\n     */\n    constructor(position, style, dbId) {\n        this._style = style;\n        this._position = position;\n        this._dbId = dbId;\n    }\n\n    /**\n     * The style definition of this viewable object.\n     * @returns {ViewableStyle} The style definition of this viewable object.\n     */\n    get style() {\n        return this._style;\n    }\n\n    /**\n     * The position of the viewable object in world coordinates.\n     * @returns {THREE.Vector3} The position of the viewable object in world coordinates.\n     */\n    get position() {\n        return this._position;\n    }\n\n    /**\n     * The `DbId` of this viewable object. This value is used to identify the\n     * viewable when user input events such as mouse clicks are handled.\n     * @returns {number} The `DbId` of this viewable object. This value is used to\n     * identify the viewable when user input events such as mouse clicks are handled.\n     */\n    get dbId() {\n        return this._dbId;\n    }\n}\n\n/**\n * A sprite (image) based custom viewable object.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.SpriteViewable\n * @augments CustomViewable\n */\nclass SpriteViewable extends CustomViewable {\n    /**\n     * Constructs an instance of `SpriteViewable` object\n     *\n     * @param {THREE.Vector3} position The position of the viewable in world coordinates.\n     * @param {ViewableStyle} style The style definition of this custom viewable object.\n     * @param {number} dbId The `DbId` of this custom viewable object. This value is used\n     * to identify the viewable when user input events such as mouse clicks are handled.\n     *\n     * @example\n     *  const dbId = 100;\n     *  const positions = [\n     *      {\n     *          x: -97.94954550038506,\n     *          y: -50.21776820050724,\n     *          z: 12.444056161946492,\n     *      },\n     *      {\n     *          x: -12.59026829087645,\n     *          y: -50.20446526068116,\n     *          z: 14.35526278705748,\n     *      },\n     *  ];\n     *\n     *  const viewables = [];\n     *\n     *  // Create multiple SpriteViewable that share the same 'style'.\n     *  positions.forEach((pos) => {\n     *      const viewable = new Autodesk.DataVisualization.Core.SpriteViewable(\n     *          pos, style, dbId);\n     *\n     *      dbId++; // Assign each viewable a unique identifier\n     *      viewables.push(viewable);\n     *  });\n     */\n    constructor(position, style, dbId) {\n        // eslint-disable-next-line no-console\n        console.assert(style.type == ViewableType.SPRITE);\n        super(position, style, dbId);\n    }\n\n    /**\n     * The type of this `SpriteViewable` object. This value will always\n     * be equal to `ViewableType.SPRITE`.\n     * @returns {number} The type of this `SpriteViewable` object.\n     * This value will always be equal to `ViewableType.SPRITE`.\n     */\n    get type() {\n        return ViewableType.SPRITE;\n    }\n\n    /**\n     * The color of this `SpriteViewable` object. The color is multiplied with\n     * the sprite pixel colors in shader prior to display.\n     * @returns {THREE.Color} The color of this `SpriteViewable` object. The color\n     * is multiplied with the sprite pixel colors in shader prior to display.\n     */\n    get color() {\n        return this.style.color;\n    }\n\n    /**\n     * The color of this sprite viewable object. The color is multiplied with the\n     * highlighted sprite pixel colors in shader for display.\n     * @returns {THREE.Color} The color of this sprite viewable object. The color is\n     * multiplied with the highlighted sprite pixel colors in shader for display.\n     */\n    get highlightedColor() {\n        return this.style.highlightedColor;\n    }\n}\n\n/**\n * An object that manages a collection of `CustomViewable` object. A `ViewableData`\n * object is added for display through `DataVisualization.addViewables` API before\n * any of its `CustomViewable` can be displayed.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.ViewableData\n */\nclass ViewableData {\n    /**\n     * Constructs an instance of `ViewableData` object\n     *\n     * @param {Object} options The options to configure `ViewableData` object with.\n     * @param {number} options.atlasWidth The initial sprite atlas width in\n     * pixels, to accommodate subsequent `CustomViewable` object that are added.\n     * If not specified, the atlas width of `1920` pixels is used.\n     * @param {number} options.atlasHeight The initial sprite atlas height in\n     * pixels, to accommodate subsequent `CustomViewable` object that are added.\n     * If not specified, the atlas height of `1080` pixels is used.\n     *\n     * @example\n     *  const viewableData = new Autodesk.DataVisualization.Core.ViewableData({\n     *    atlasWidth: 512,\n     *    atlasHeight: 512\n     *  });\n     */\n    constructor(options = {}) {\n        this._styleMap = new Map();\n        this._viewablesMap = new Map();\n        this._spriteAtlas = new SpriteAtlas(\n            options.atlasWidth || 1920,\n            options.atlasHeight || 1080,\n            2\n        );\n    }\n\n    /**\n     * All the `CustomViewable` that are added to this `ViewableData` object.\n     * @returns {CustomViewable[]} All the `CustomViewable` that are added to\n     * this `ViewableData` object.\n     */\n    get viewables() {\n        return [...this._viewablesMap.values()];\n    }\n\n    /**\n     * @private\n     * @returns {SpriteAtlas} For internal use only.\n     */\n    get spriteAtlas() {\n        return this._spriteAtlas;\n    }\n\n    /**\n     * Adds a custom viewable object to the `ViewableData`.\n     *\n     * @param {CustomViewable} viewable The custom viewable to be added\n     * to the `ViewableData` object.\n     */\n    addViewable(viewable) {\n        if (viewable.type == ViewableType.SPRITE) {\n            /** @type {Set<string>} */\n            let spriteUrls = new Set();\n            spriteUrls.add(viewable.style.url);\n\n            if (viewable.style.highlightedUrl) {\n                spriteUrls.add(viewable.style.highlightedUrl);\n            }\n\n            viewable.style.preloadedSprites.forEach((url) => spriteUrls.add(url));\n            spriteUrls.forEach((url) => this.spriteAtlas.addSprite(url));\n        }\n\n        this._viewablesMap.set(viewable.dbId, viewable);\n    }\n\n    /**\n     * @private\n     * Gets the texture coordinates corresponding to a given sprite URL.\n     *\n     * @param {string} url A URL of sprite for which UV texture coordinates is\n     * to be obtained. This URL should be one of the values specified through\n     * the constructor of `ViewableStyle` or `preloadSprite` API.\n     *\n     * @returns {{ x: number, y: number, w: number, h: number}} The texture\n     * coordinates of the top-left and bottom-right corner of the sprite. Note\n     * that `w` and `h` represent the actual texture coordinates of the\n     * bottom-right corner of the sprite, not its width or height.\n     */\n    getSpriteUV(url) {\n        return this._spriteAtlas.spriteUV(url);\n    }\n\n    /**\n     * Get the UV values of a viewable from the sprite atlas\n     *\n     * @param {String} dbId Id of the viewable to obtain the UV of.\n     * @param {boolean} highlighted Boolean value to obtain the normal sprite UV or the highlighted version\n     * @returns {Object} UV values of the requested viewable\n     */\n    getViewableUV(dbId, highlighted) {\n        let style = this._viewablesMap.get(dbId).style;\n        if (highlighted && style.highlightedUrl) {\n            return this._spriteAtlas.spriteUV(style.highlightedUrl);\n        } else {\n            return this._spriteAtlas.spriteUV(style.url);\n        }\n    }\n\n    /**\n     * Get the color values of a viewable\n     *\n     * @param {String} dbId Id of the viewable to obtain the UV of.\n     * @param {boolean} highlighted Boolean value to obtain the normal sprite UV or the highlighted version\n     * @returns {THREE.Color} Color of the requested viewable\n     */\n    getViewableColor(dbId, highlighted) {\n        let style = this._viewablesMap.get(dbId).style;\n        if (highlighted) {\n            return style.highlightedColor;\n        } else {\n            return style.color;\n        }\n    }\n\n    /**\n     * Marks the `ViewableData` as completed. The final sprite atlas will be\n     * generated based on all the `CustomViewable` objects added prior to this.\n     * This function must be called before the `ViewableData` is added for display\n     * through `DataVisualization.addViewables` API.\n     */\n    async finish() {\n        await this._spriteAtlas.finish();\n    }\n}\n\nexport {\n    ViewableStyle,\n    SpriteViewable,\n    CustomViewable,\n    ViewableData,\n    ViewableType\n};\n","import {\n    SurfaceShadingNode,\n    SurfaceShadingGroup,\n    SurfaceShadingData,\n    SurfaceShadingPoint,\n} from \"./heatmap/SurfaceShadingData\";\n\n/**\n * The object that defines the structure of a Device in a Room.\n *\n * @typedef {Object} RoomDevice\n * @property {string} id An ID to identify this device\n * @property {Object} position World coordinates of this device\n * @property {number} position.x X coordinates of this device\n * @property {number} position.y Y coordinates of this device\n * @property {number} position.z Z coordinates of this device\n * @property {Array.<string>} sensorTypes The types/properties this device exposes\n * @property {string} type A type identifier for this device. Ex: Thermometer\n * @property {string} [name] An optional name identifier for the device\n * @example\n *  {\n *      id: \"cafeteria-entrace-01\",\n *      position: { x: -159.2782, y: -50.4998, z: -16.9196 },\n *      sensorTypes: [\"temperature\", \"humidity\"],\n *      type: 'thermometer'\n *  },\n */\n\n/**\n * A class that represents a room found in the model. See\n * {@link Autodesk.DataVisualization.Core.LevelRoomsMap|LevelRoomsMap} for more details.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.Room\n */\nclass Room {\n    /**\n     * Constructs an instance of `Room` object. Client code should not construct\n     * rooms directly, but to obtain them from `LevelRoomsMap.getRoomsOnLevel` API.\n     *\n     * @param {number} id The `DbId` of the room\n     * @param {string} name The name of the room\n     * @param {THREE.Box3} bounds The bounding box of the room\n     */\n    constructor(id, name, bounds) {\n        this._id = id;\n        this._name = name;\n        this._bounds = bounds;\n\n        /**\n         * @private\n         * @type {RoomDevice[]}\n         */\n        this._devices = [];\n    }\n\n    /**\n     * @private\n     * @param {{properties: any[]}} value For internal use only\n     */\n    set info(value) {\n        this._info = value;\n    }\n\n    /**\n     * Returns the `DbId` of the room\n     * @returns {number} The `DbId` of the room\n     */\n    get id() {\n        return this._id;\n    }\n\n    /**\n     * Returns the name of the room\n     * @returns {string} The name of the room\n     */\n    get name() {\n        return this._name;\n    }\n\n    /**\n     * Returns the bounding box of the room\n     * @returns {THREE.Box3} The bounding box of the room\n     */\n    get bounds() {\n        return this._bounds;\n    }\n\n    /**\n     * Gets the list of all `Device` objects in the room. If the room does\n     * not contain any devices, an empty array will be returned.\n     * @returns {RoomDevice[]} The list of all `Device` objects in the room.\n     * If the room does not contain any devices, an empty array\n     * will be returned.\n     */\n    get devices() {\n        return this._devices;\n    }\n\n    /**\n     * @private\n     * @returns {{properties: any[]}} For internal use only\n     */\n    get info() {\n        return this._info;\n    }\n\n    /**\n     * Adds a {@link RoomDevice} to the {@link Room}\n     *\n     * @param {RoomDevice} device The `Device` to be added to the room\n     */\n    addDevice(device) {\n        this._devices.push(device);\n    }\n}\n\n/**\n * A class that maps level names to one or more `Room` objects that are found\n * on the corresponding levels. See\n * {@link Autodesk.DataVisualization.Core.Room|Room} for details\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.LevelRoomsMap\n *\n *\n * @example\n *  // Gets the level-to-rooms mapping from the structural model\n *  const info = new Autodesk.DataVisualization.Core.ModelStructureInfo(model);\n *  const levelRoomsMap = await info.getLevelRoomsMap();\n */\nclass LevelRoomsMap {\n    /**\n     * Adds a {@link Room} object to a named level.\n     *\n     * @param {string} levelName Name of the level to add the `Room` to.\n     * @param {Autodesk.DataVisualization.Core.Room} room The `Room`\n     * object to be added to the level.\n     *\n     * @alias Autodesk.DataVisualization.Core.LevelRoomsMap#addRoomToLevel\n     */\n    addRoomToLevel(levelName, room) {\n        if (!this[levelName]) {\n            this[levelName] = [];\n        }\n\n        this[levelName].push(room);\n    }\n\n    /**\n     * Gets all the rooms on a given level.\n     *\n     * @param {string} levelName Name of the level for which rooms\n     * are to be retrieved.\n     * @param {boolean} onlyRoomsWithDevices Set this to `true` to return only rooms\n     * with devices in them, or `false` to return all rooms on the level.\n     * @returns {Room[]} List of all the rooms found on the level, or an empty list\n     * if no room is found.\n     *\n     * @alias Autodesk.DataVisualization.Core.LevelRoomsMap#getRoomsOnLevel\n     *\n     * @example\n     *  // Get all Room objects on \"Level 1\", with or without devices\n     *  const roomsOnLevelOne = levelRoomsMap.getRoomsOnLevel(\"Level 1\", false);\n     *\n     *  // Get only Room objects on \"Level 1\" that contain devices\n     *  const roomsWithDevices = levelRoomsMap.getRoomsOnLevel(\"Level 1\", true);\n     */\n    getRoomsOnLevel(levelName, onlyRoomsWithDevices) {\n        /** @type {Room[]} */\n        const rooms = this[levelName] || [];\n\n        if (onlyRoomsWithDevices) {\n            return rooms.filter((room) => room.devices.length > 0);\n        } else {\n            return rooms;\n        }\n    }\n}\n\n/**\n * Data class to deal with the structural information of a model.\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.ModelStructureInfo\n */\nclass ModelStructureInfo {\n    /**\n     * Constructs an instance of `ModelStructureInfo` object.\n     *\n     * @param {Model} model The model from which structural information\n     * is to be generated.\n     *\n     * @example\n     *  function onModelLoaded(event) {\n     *    const model = event.model;\n     *    const info = new Autodesk.DataVisualization.Core.ModelStructureInfo(model);\n     *  }\n     *\n     *  // Register to be notified when the model is fully loaded\n     *  viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT,\n     *    onModelLoaded, { once: true });\n     */\n    constructor(model) {\n        this.model = model;\n\n        /**\n         * @private\n         * @type {Room[]}\n         */\n        this.rooms = null;\n    }\n\n    /**\n     * @private\n     * Given a parent node, gets the immediate child nodes by its name.\n     *\n     * @param {string} name Name to filter the child node with.\n     * @param {number} [parentId] An optional parent node `DbId` for which the\n     * immediate child nodes are to be searched. Root ID of the model will\n     * be used if this parameter is omitted.\n     *\n     * @returns {Array.<number>} A list of all child node `DbId`s that match\n     * the filter name.\n     * @memberof Autodesk.DataVisualization.Core\n     * @alias Autodesk.DataVisualization.Core.ModelStructureInfo#getImmediateChildNodesByName\n     */\n    getImmediateChildNodesByName(name, parentId) {\n        const model = this.model;\n        const it = model.getInstanceTree();\n        const childIds = [];\n\n        if (it) {\n            parentId = parentId == undefined ? it.getRootId() : parentId;\n\n            it.enumNodeChildren(\n                parentId,\n                (id) => {\n                    const n = it.getNodeName(id, true);\n\n                    // some time, the name is `Rooms (11)`\n                    if (n && n.indexOf && n.indexOf(name) >= 0) {\n                        childIds.push(id);\n                    }\n                },\n                false\n            );\n        }\n\n        return childIds;\n    }\n\n    /**\n     * Gets the structural info and build level-to-rooms map.\n     *\n     * @param {boolean} [keepRoomDetail=false] Whether to keep the room\n     * detailed properties after this call completes.\n     * @param {string} [nodeName] Optional. Name of the node whose immediate\n     * child nodes are to be retrieved. If this parameter is not supplied, or\n     * if it is an empty string, then the default value \"Rooms\" will be used.\n     *\n     * @returns {LevelRoomsMap} The level-to-rooms map\n     */\n    async getLevelRoomsMap(keepRoomDetail = false, nodeName) {\n        if (!this.levelRoomsMap) {\n            const levelRoomsMap = new LevelRoomsMap();\n            const rooms = await this.getRoomList(nodeName);\n            rooms.forEach((room) => {\n                const levelName = this.getLevel(room);\n                if (!keepRoomDetail) {\n                    room.info = undefined;\n                }\n\n                if (levelName != undefined) {\n                    levelRoomsMap.addRoomToLevel(levelName, room);\n                }\n            });\n\n            this.levelRoomsMap = levelRoomsMap;\n        }\n\n        return this.levelRoomsMap;\n    }\n\n    /**\n     * @private\n     * Gets the name of the level from the given room, if any is specified.\n     *\n     * @param {Room} room The room for which the level name is to be retrieved.\n     * @returns {string|undefined} The name of level if one is specified,\n     * or `undefined` otherwise.\n     */\n    getLevel(room) {\n        if (room && room.info && room.info.properties) {\n            const prop = room.info.properties.find((p) => {\n                return p.type == 20 && p.attributeName == \"Level\";\n            });\n\n            return prop ? prop.displayValue : undefined;\n        }\n    }\n\n    /**\n     * @private\n     * Gets a list of rooms found in the current model.\n     *\n     * @param {string} [nodeName] Optional. Name of the node whose immediate\n     * child nodes are to be retrieved. If this parameter is not supplied, or\n     * if it is an empty string, then the default value \"Rooms\" will be used.\n     *\n     * @returns {Room[]}\n     */\n    async getRoomList(nodeName) {\n        if (!this.rooms) {\n            // Default value for parameter does not prevent empty\n            // string from being passed in, so this check is necessary.\n            nodeName = nodeName ? nodeName : \"Rooms\";\n\n            const roomNode = this.getImmediateChildNodesByName(nodeName);\n            const model = this.model;\n\n            /** @type {Room[]} */\n            const rooms = [];\n\n            if (roomNode && roomNode.length > 0) {\n                const roomsRootId = roomNode[0];\n\n                const it = model.getInstanceTree();\n                if (it) {\n                    it.enumNodeChildren(\n                        roomsRootId,\n                        (id) => {\n                            const name = it.getNodeName(id, true);\n                            const bounds = this.getRoomBounds(id);\n                            rooms.push(new Room(id, name, bounds));\n                        },\n                        false\n                    );\n                }\n            }\n\n            // Extract detailed room properties.\n            const promises = rooms.map((room) => {\n                return new Promise((resolve, reject) => {\n                    model.getProperties2(\n                        room.id,\n                        (info) => {\n                            room.info = info;\n                            resolve(room);\n                        },\n                        (error) => {\n                            resolve(room);\n                        }\n                    );\n                });\n            });\n\n            await Promise.all(promises);\n            this.rooms = rooms;\n        }\n\n        return this.rooms;\n    }\n\n    /**\n     * @private\n     * Gets the bounding box of a room given its `DbId`. The bounding box is\n     * expanded to include bounding boxes of all the fragments that made up\n     * the room.\n     *\n     * @param {number} roomId The `DbId` of the room.\n     * @returns {THREE.Box3} The bounding box of the room with given `DbId`.\n     */\n    getRoomBounds(roomId) {\n        const bounds = new THREE.Box3();\n        const fragBounds = new THREE.Box3();\n        const it = this.model.getInstanceTree();\n        const fragList = this.model.getFragmentList();\n\n        if (it) {\n            it.enumNodeFragments(\n                roomId,\n                (fragId) => {\n                    fragList.getWorldBounds(fragId, fragBounds);\n                    bounds.union(fragBounds);\n                },\n                true\n            );\n        }\n\n        return bounds;\n    }\n\n    /**\n     * @private\n     * Assign cient-defined devices to rooms based on their 3D space positions\n     * and the bounding box of each room.\n     *\n     * @param {RoomDevice[]} [devices] The devices to be assigned to loaded rooms.\n     * @param {string} [nodeName] Optional. Name of the node whose immediate\n     * child nodes are to be retrieved. If this parameter is not supplied, or\n     * if it is an empty string, then the default value \"Rooms\" will be used.\n     */\n    async mapDevicesInRoom(devices = [], nodeName) {\n        // If we create space tree to determine whether a device is in a room\n        // we need to use that structure to detect all devices in a single round\n        // otherwise it will cause performance and memory issues\n        const rooms = await this.getRoomList(nodeName);\n        devices = devices.slice(0);\n\n        for (let i = 0; devices.length > 0 && i < rooms.length; i++) {\n            const room = rooms[i];\n\n            for (let j = 0; j < devices.length; j++) {\n                const device = devices[j];\n\n                if (this.roomGeomContainsPoint(room, device.position)) {\n                    // Build bi-directional references\n                    device.roomId = room.id;\n                    room.addDevice(device);\n\n                    // Remove the device from the list, to avoid future iteration\n                    devices.splice(j, 1);\n                    j--;\n                }\n            }\n        }\n\n        if (devices.length > 0) {\n            const names = devices.map((dev) => `${dev.id} (${dev.name})`);\n            console.warn(`Some devices did not map to a room: ${names.join(\", \")}`);\n        }\n    }\n\n    /**\n     * Assigns client-defined devices to rooms based on their 3D space positions\n     * and the bounding box of each room, then generate hierarchical shading data\n     * based on the assignment.\n     *\n     * @param {RoomDevice[]} devices The devices to be assigned to loaded rooms.\n     * @param {LevelRoomsMap} [levels] Optional. The level-to-rooms map. If none\n     * is supplied, one will be generated internally.\n     * @param {string} [nodeName] Optional. Name of the node whose immediate\n     * child nodes are to be retrieved. If this parameter is not supplied, or\n     * if it is an empty string, then the default value \"Rooms\" will be used.\n     * @returns {SurfaceShadingData} The resulting `SurfaceShadingData` object.\n     *\n     * @alias Autodesk.DataVisualization.Core.ModelStructureInfo#generateSurfaceShadingData\n     *\n     * @example\n     *  // 'devices' is a list of 'Device' objects in a 'Room'.\n     *  const info = new Autodesk.DataVisualization.Core.ModelStructureInfo(model);\n     *  const shadingData = await info.generateSurfaceShadingData(devices);\n     *  dataVizExtn.setupSurfaceShading(model, shadingData);\n     */\n    async generateSurfaceShadingData(devices = [], levels, nodeName) {\n        if (!levels) {\n            levels = await this.getLevelRoomsMap(false, nodeName);\n            await this.mapDevicesInRoom(devices, nodeName);\n        }\n\n        const shadingData = new SurfaceShadingData();\n        for (let levelName in levels) {\n            const rooms = levels[levelName];\n            const subGroup = new SurfaceShadingGroup(levelName);\n\n            rooms.forEach((room) => {\n                const node = new SurfaceShadingNode(room.name, room.id);\n                room.devices.forEach((device) => {\n                    let styleId = device.deviceModel ? device.deviceModel.id : device.type;\n                    node.addPoint(\n                        new SurfaceShadingPoint(\n                            device.id,\n                            device.position,\n                            device.sensorTypes,\n                            device.name,\n                            { styleId }\n                        )\n                    );\n                });\n\n                subGroup.addChild(node);\n            });\n\n            shadingData.addChild(subGroup);\n        }\n\n        shadingData.initialize(this.model);\n        return shadingData;\n    }\n\n    /**\n     * @private\n     * Checks if a given point is within the bounds of a room.\n     *\n     * @param {Room} room The room against which a point is checked.\n     * @param {{x: number, y: number, z: number}} point The point to be checked.\n     * @returns {boolean} `true` if the point is within the bounds of the\n     * room, or `false` otherwise.\n     */\n    roomGeomContainsPoint(room, point) {\n        return room.bounds && room.bounds.containsPoint(point);\n    }\n}\n\nexport { Room, LevelRoomsMap, ModelStructureInfo };\n","/**\n * A material for heatmap rendering.\n *\n * @param {Array.<THREE.Vector4>} sensorVals The value of sensors where\n * x, y, z components carry the position of a sensor, and w component\n * represents the normalized value of a sensor in the range of 0.0 to 1.0.\n * If the w component is a negative number, the sensor will not have any\n * influence towards the color of the material.\n * @param {Array.<THREE.Vector3>} colors An array of Vector3 each representing a\n * color value of a stop in the grandient. The length of this array must be the\n * same as stops parameter.\n * @param {Array.<number>} stops An array of normalized numbers each representing\n * a stop in the gradient. The numbers in this array must be in ascending order,\n * and the array length must be the same as colors parameter.\n * @property {number} confidence The distance from the sensor that its value will\n * affect the heatmap before dropping off. Measured in world coordinates of the\n * current model.\n * @param {number} [powerParameter] Optional. A positive real number. Greater\n * values of power parameter assign greater influence to values closest to the\n * interpolated point. This parameter is default to `2.0`.\n * @param {number} [alpha] Optional. The transparency level of the resulting\n * fragment on the heatmap, ranging from `0.0` (completely transparent) to `1.0`\n * (fully opaque). The default value is `1.0`.\n */\nclass HeatmapMaterial extends THREE.ShaderMaterial {\n    constructor(sensorVals, colors, stops, confidence, powerParameter = 2.0, alpha = 1.0) {\n        if (colors.length < 2 || colors.length != stops.length) {\n            throw new Error(\"Heatmap requires at least two colors to work\");\n        }\n        if (confidence < 0.0) {\n            throw new Error(\"Heatmap 'confidence' must be a positive number\");\n        }\n        if (powerParameter < 0.0) {\n            throw new Error(\"Heatmap 'powerParameter' must be a positive number\");\n        }\n        if (alpha < 0.0 || alpha > 1.0) {\n            throw new Error(\"Heatmap 'alpha' must range between 0.0 and 1.0\");\n        }\n\n        const uniforms = {\n            uPower: { type: \"f\", value: powerParameter },\n            uAlpha: { type: \"f\", value: alpha },\n            uConfidence: { type: \"f\", value: confidence },\n            uSensors: { type: \"v4v\", value: sensorVals.map((v) => v) },\n            uStops: { type: \"fv1\", value: stops },\n            uColors: { type: \"v3v\", value: colors },\n        };\n\n        const colorCount = colors.length;\n        const sensorCount = sensorVals.length;\n\n        const vertexShader = `\n            varying vec4 worldCoord;\n\n            void main()\n            {\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                worldCoord = modelMatrix * vec4(position, 1.0);\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        `;\n\n        const fragmentShader = `\n            varying vec4 worldCoord;\n            uniform float uPower;\n            uniform float uAlpha;\n            uniform float uConfidence;\n            uniform vec4 uSensors [${sensorCount}];\n            uniform float uStops[${colorCount}];\n            uniform vec3 uColors[${colorCount}];\n\n            const float dotSize = 6.0;\n            const float h_var1 = 0.4;\n            const float h_var2 = 0.25;\n            const float two_pi = 2.0 * 3.1415927;\n            \n            float lmap(float value, float inMin, float inMax, float outMin, float outMax)\n            {\n                return clamp(outMin + ((outMax - outMin) * (value - inMin)) / (inMax - inMin), outMin, outMax);\n            }\n\n            // Gradient with multiple colors in non-equal intervals\n            vec3 colormap(float x)\n            {\n                for (int i = 1; i < ${colorCount}; i++) {\n                    if (x <= uStops[i]) {\n                        float stopPct = lmap(x, uStops[i-1], uStops[i], 0.0, 1.0);\n                        return mix(uColors[i-1], uColors[i], stopPct);\n                    }\n                }\n            \n                // In case 'x' goes beyond upper bound.\n                return uColors[${colorCount} - 1];\n            }\n\n            vec2 get_pix(float angle) {\n                float rad = radians(angle);\n                float c = cos(rad);\n                float s = sin(rad);\n                mat2 R = mat2(vec2(c, -s), vec2(s, c));\n                return R * gl_FragCoord.xy;\n            }\n\n            vec3 halftone(float tone, vec3 dotColor, vec3 backgroundColor) {\n                vec2 u = get_pix(-45.0) / (dotSize);\n                float h = (h_var1 + h_var2 * cos(u.x*two_pi));\n                const float e = 0.05;\n                float gradient = smoothstep(-e, e, h - tone);\n                return mix(dotColor, backgroundColor, gradient);\n            }\n\n            void main(void) {\n                vec3 fragPos = vec3(worldCoord.x, worldCoord.y, worldCoord.z);\n                float result = 0.0;\n                float sum = 0.0;\n                float wsum = 0.000001;\n                float minDist = 999999999.0;\n                bool found = false; // at exact location of the sensor\n                int validSensors = 0;\n\n                for (int i=0; i < ${sensorCount}; i++) {\n                    float mydist = distance(fragPos, vec3(uSensors[i][0], uSensors[i][1], uSensors[i][2]));\n                    if (uSensors[i][3] >= 0.0) {\n                        if (mydist < 0.00001) {\n                            result = uSensors[i][3];\n                            found = true;\n                        } else {\n                            float w = (1.0 / (pow(mydist, uPower)));\n                            sum += (uSensors[i][3] * w);\n                            wsum += w;\n                        }\n                        validSensors += 1;\n                        if (mydist < minDist) {\n                            minDist = mydist;\n                        }\n                    }\n                }\n\n                if (validSensors == 0) {\n                    result = -1.0;\n                } else if (!found) {\n                    result = sum / wsum;\n                }\n\n                // Defaults without influence from any sensor\n                float confidence = 0.0;\n                vec3 sensorColor = vec3(0.5, 0.5, 0.5);\n\n                if (result >= 0.0) {\n                    result = clamp(result, 0.0, 1.0);\n                    confidence = 1.0 - clamp(minDist / uConfidence, 0.0, 1.0);\n                    sensorColor = colormap(result);\n                }\n\n                vec3 confidenceColor = halftone(clamp(confidence, 0.3, 0.9), vec3(0.7, 0.7, 0.7), vec3(1.0, 1.0, 1.0));\n                gl_FragColor = vec4(mix(confidenceColor, sensorColor, clamp(confidence, 0.0, 1.0)), uAlpha);\n            }\n        `;\n\n        super({\n            uniforms,\n            vertexShader,\n            fragmentShader,\n            side: THREE.DoubleSide,\n            depthTest: true,\n            depthWrite: false,\n        });\n    }\n\n    /**\n     * Update HeatmapMaterial with new sensor values, and optionally additional\n     * configuration.\n     *\n     * @param {Array.<THREE.Vector4>} sensorVals The value of sensors where x, y, z\n     * components carry the position of a sensor, and w component represents the\n     * normalized value of a sensor in the range of 0.0 to 1.0.\n     * If the w component is a negative number, the sensor will not have any\n     * influence towards the color of the material.\n     * @property {number} [confidence] Optional. The distance from the sensor that its\n     * value will affect the heatmap before dropping off. Measured in world coordinates\n     * of the current model. The default value is `160.0`.\n     * @property {number} [powerParameter] Optional. A positive real number. Greater\n     * values of power parameter assign greater influence to values closest to the\n     * interpolated point. This parameter is default to `2.0`.\n     * @property {number} [alpha] Optional. The transparency level of the resulting\n     * fragment on the heatmap, ranging from `0.0` (completely transparent) to `1.0`\n     * (fully opaque). The default value is `1.0`.\n     */\n    update(sensorVals, confidence, powerParameter, alpha) {\n        // Note: `isNaN(null) == false` so special handling.\n        if (!isNaN(confidence) && confidence !== null) {\n            this.uniforms.uConfidence.value = confidence;\n        }\n        if (!isNaN(powerParameter) && powerParameter !== null) {\n            this.uniforms.uPower.value = powerParameter;\n        }\n        if (!isNaN(alpha) && alpha !== null) {\n            this.uniforms.uAlpha.value = alpha;\n        }\n\n        this.uniforms.uSensors.value = sensorVals;\n    }\n}\n\nfunction createColorStops(n) {\n    const res = [];\n    const inc = 1 / (n - 1);\n    for (let i = 0; i < n; i++) {\n        res.push(inc * i);\n    }\n    return res;\n}\n\nexport { HeatmapMaterial, createColorStops };\n","import { createColorStops, HeatmapMaterial } from \"./HeatmapMaterial\";\nimport { filterShadingPointsByType } from \"./SurfaceShadingData\";\n\n\nconst surfaceShadingOverlay = \"DataVizSurfaceShading\";\nconst LARGE_FLOAT = 9999999.9;\nconst avp = Autodesk.Viewing.Private;\n\nclass SurfaceShading {\n    /**\n     * Constructs an instance of SurfaceShading object based on the given model\n     * and shading data.\n     *\n     * @param {GUIViewer3D} viewer The viewer in which SurfaceShading is created.\n     * @param {Model} model The model based on which SurfaceShading is created.\n     * @param {SurfaceShadingData} shadingData The data for SurfaceShading.\n     */\n    constructor(viewer, model, shadingData) {\n        this.viewer = viewer;\n        this.model = model;\n        this.shadingData = shadingData;\n\n        this.activeShadingPoints = [];\n        this.settings = {};\n\n        // TODO: These are to be defined by client code based on device/property combinations.\n        this.registerSensorColors(\"hatchPattern\", [0xffffff, 0xffffff], 0.7);\n        this.registerSensorColors(\"__defaultSensor__\", [0x0000ff, 0x00ff00, 0xffff00, 0xff0000], 0.7);\n    }\n\n    /**\n     * Removes any surface shading created by clearing the overlay which holds\n     * the meshes used as heatmap representation. Note that this call does not\n     * release other resources like materials created.\n     */\n    removeShading() {\n        this.viewer.impl.removeOverlayScene(surfaceShadingOverlay);\n        this.viewer.impl.invalidate(false, false, true);\n    }\n\n    /**\n     * Cleans up overlay used for the surface shading, as well as the materials\n     * created to render surface shading.\n     */\n    cleanUp() {\n        this.removeShading();\n        this._clearActiveShadingPoints();\n\n        if (this.hatchMaterial) {\n            this.hatchMaterial.dispose();\n            delete this.hatchMaterial;\n        }\n    }\n\n    _clearActiveShadingPoints() {\n        this.activeShadingPoints.forEach((s) => s.heatmapMaterial.dispose());\n        this.activeShadingPoints = [];\n    }\n\n    _createHatchMaterial() {\n        let setting = this.settings[\"hatchPattern\"];\n        let material = new HeatmapMaterial(\n            [new THREE.Vector4(LARGE_FLOAT, LARGE_FLOAT, LARGE_FLOAT, -1)],\n            setting.colors,\n            setting.stops,\n            60,\n            2.0,\n            setting.alpha\n        );\n\n        return material;\n    }\n\n    /**\n     *\n     * @param {string} sensorType\n     * @param {number[]} colors\n     * @param {number} alpha Alpha channel of the heatmap\n     */\n    registerSensorColors(sensorType, colors, alpha = 0.7) {\n        this.settings[sensorType] = {\n            stops: createColorStops(colors.length),\n            colors: colors\n                .map((c) => new THREE.Color(c))\n                .map((color) => new THREE.Vector3(color.r, color.g, color.b)),\n            alpha: alpha,\n        };\n    }\n\n    getSetting(sensorType) {\n        if (this.settings[sensorType]) {\n            return this.settings[sensorType];\n        } else {\n            return this.settings[\"__defaultSensor__\"];\n        }\n    }\n\n    /**\n     * Renders one or more nodes with the given identifiers. This call creates\n     * necessary resources like overlay scene and materials, therefore is by\n     * design to be called only when necessary (i.e., when surface shading needs\n     * to be updated due to geometry changes). For more light weight rendering,\n     * `updateShading` API should be used instead.\n     *\n     * @param {string|string[]} nodeId One or more identifiers of nodes\n     *  to render. These identifiers are among the ones provided through\n     *  SurfaceShadingData when the SurfaceShading object is constructed.\n     * @param {string} sensorType The type of sensor to render the shading for.\n     * @param {SensorValueCallback} sensorValueCallback The callback function that\n     *  will be invoked when SurfaceShading requires the sensor value to render.\n     * @param {HeatmapConfig} [heatmapConfig] Optional. The configuration of the\n     * heatmap. See documentation for `HeatmapConfig` for more details.\n     */\n    render(nodeId, sensorType, sensorValueCallback, heatmapConfig) {\n        // sanitize the input, make sure confidenceSize is positive number when it exists\n        let confidenceSize = heatmapConfig ? heatmapConfig.confidence : 0;\n        confidenceSize = !isNaN(confidenceSize) ? Math.abs(confidenceSize) : 0;\n\n        // Defaulting `powerParameter` to `2.0`\n        let powerParameter = 2.0;\n        if (heatmapConfig && typeof heatmapConfig.powerParameter === \"number\") {\n            powerParameter = heatmapConfig.powerParameter;\n        }\n\n        /** @type {SurfaceShadingNode[]} */\n        let nodes = [];\n        if (nodeId instanceof Array) {\n            nodeId.forEach((id) => this.shadingData.getLeafsById(id, nodes));\n        } else {\n            nodes = this.shadingData.getLeafsById(nodeId);\n        }\n\n        let it = this.model.getInstanceTree();\n        this._clearActiveShadingPoints();\n\n        const viewerImp = this.viewer.impl;\n        const activeShadingPoints = this.activeShadingPoints;\n\n        viewerImp.createOverlayScene(surfaceShadingOverlay);\n        if (!this.hatchMaterial) {\n            this.hatchMaterial = this._createHatchMaterial();\n        }\n\n        function addMeshToOverlay(fragId, material) {\n            // add geometry into the overlay\n            let geometry = it.fragList.getGeometry(fragId);\n            if (!geometry) {\n                avp.logger.error(\"Geometry for the fragment is empty, FragId:\", fragId);\n                return;\n            }\n            let mesh = new THREE.Mesh(geometry, material);\n            let m = new THREE.Matrix4();\n            it.fragList.getWorldMatrix(fragId, m);\n\n            mesh.matrix.copy(m);\n            mesh.matrixWorldNeedsUpdate = true;\n            mesh.matrixAutoUpdate = false;\n            mesh.frustumCulled = false;\n\n            viewerImp.addOverlay(surfaceShadingOverlay, mesh);\n        }\n\n        const settingsForSensorType = this.getSetting(sensorType);\n\n        for (let i = 0; nodes && i < nodes.length; i++) {\n            const node = nodes[i];\n            const shadingPoints = filterShadingPointsByType(node.shadingPoints, sensorType);\n\n            // Set default material to hatch material type which allows fragments\n            // without any shading point to render with a hatch pattern. If there\n            // are any associated shading points, then this material will be set\n            // to the newly created `HeatmapMaterial` with actual sensor values.\n            //\n            let heatmapMaterial = this.hatchMaterial;\n\n            if (shadingPoints.length > 0) {\n                let confidence = confidenceSize;\n\n                // Caculate the confidence value if node.bounds exists\n                if (node.bounds && !confidenceSize) {\n                    const bmax = node.bounds.max;\n                    const bmin = node.bounds.min;\n                    confidence = bmax.x - bmin.x + (bmax.y - bmin.y) + (bmax.z - bmin.z);\n                }\n\n                confidence = confidence || 160;\n\n                /** @type {THREE.Vector4[]} */\n                const sensorValues = [];\n\n                // render the sufaceMap with current sensor value\n                shadingPoints.forEach((shadingPoint) => {\n                    const p = shadingPoint.position;\n                    const value = sensorValueCallback(shadingPoint, sensorType);\n                    const sensorValue = new THREE.Vector4(p.x, p.y, p.z, value);\n\n                    sensorValues.push(sensorValue);\n                });\n\n                heatmapMaterial = new HeatmapMaterial(\n                    sensorValues,\n                    settingsForSensorType.colors,\n                    settingsForSensorType.stops,\n                    confidence,\n                    powerParameter,\n                    settingsForSensorType.alpha\n                );\n\n                activeShadingPoints.push({\n                    shadingPoints,\n                    sensorType,\n                    heatmapMaterial,\n                });\n            }\n\n            // Add a mesh per fragment for the current `SurfaceShadingNode`, with\n            // and without `SurfaceShadingPoint` (those nodes without valid shading \n            // points will simply be rendered as white colored, hatched volume).\n            // \n            node.fragIds.forEach((fragId) => addMeshToOverlay(fragId, heatmapMaterial));\n        }\n    }\n\n    /**\n     * This function is meant to update heatmap rapidly without recreation\n     * of the underlying materials. It is useful for scenarios where frequent\n     * redraw of the heatmap is necessary (e.g. playback of timeline control).\n     *\n     * @param {SensorValueCallback} sensorValueCallback Return a sensor value\n     * for the time context\n     * @param {HeatmapConfig} [heatmapConfig] Optional. The configuration of\n     * the heatmap. See documentation for `HeatmapConfig` for more details.\n     */\n    updateShading(sensorValueCallback, heatmapConfig) {\n        let confidence, powerParameter, alpha;\n        if (heatmapConfig) {\n            confidence = heatmapConfig.confidence;\n            powerParameter = heatmapConfig.powerParameter;\n            alpha = heatmapConfig.alpha;\n        }\n    \n        for (var i = 0; i < this.activeShadingPoints.length; i++) {\n            const { shadingPoints, sensorType, heatmapMaterial } = this.activeShadingPoints[i];\n            const sensorValue = [];\n\n            for (let shadingPoint of shadingPoints) {\n                const p = shadingPoint.position;\n                const value = sensorValueCallback(shadingPoint, sensorType);\n                sensorValue.push(new THREE.Vector4(p.x, p.y, p.z, value));\n            }\n\n            heatmapMaterial.update(sensorValue, confidence, powerParameter, alpha);\n        }\n\n        this.viewer.impl.invalidate(false, false, true);\n    }\n}\n\nexport { SurfaceShading };\n","import { filterShadingPointsByType } from \"./SurfaceShadingData\";\nimport h337 from \"heatmap.js\";\n\nconst surfaceShadingOverlay = \"DataVizPlanarHeatmap\";\nclass PlanarHeatmap {\n    constructor(viewer, model, shadingData, options = {}) {\n        options = this._handleLegacyOptions(options);\n\n        const { width, height, minOpacity, maxOpacity } = options;\n        this.options = options;\n\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n\n        this.config = {\n            canvas,\n            width,\n            height,\n            minOpacity,\n            maxOpacity,\n            radius: 20\n        };\n\n        this.model = model;\n        this.viewer = viewer;\n        this.shadingData = shadingData;\n\n        let texture = new THREE.Texture(canvas, THREE.UVMapping);\n        texture.minFilter = THREE.LinearFilter;\n        texture.flipY = false;\n\n        this.material = new THREE.MeshBasicMaterial({\n            map: texture,\n            // color: 0xFFFF00FF,\n            depthTest: true,\n            depthWrite: false,\n            transparent: true,\n            side: THREE.DoubleSide,\n        });\n\n        this.gradientMap = {};\n    }\n\n    /**\n     * @private\n     * \n     * For legacy client code, `slicingPosition` was provided as `position`,\n     * while `placementPosition` was provided as `placePosition`. We do not\n     * attempt to introduce the defaults for `position` and `placePosition`\n     * anymore here so if those values are specified, they will be converted\n     * to `slicingPosition` and `placementPosition` respectively.\n     */\n     _handleLegacyOptions(options) {\n        options = Object.assign(\n            {\n                width: 1024,\n                height: 1024,\n                slicingEnabled: true,\n            },\n            options\n        );\n\n        if (typeof options.position === \"string\") {\n            const values = { \"min\": 0.0, \"middle\": 0.5, \"max\": 1.0 };\n            options.slicingPosition = values[options.position];\n        }\n\n        if (typeof options.placePosition === \"string\") {\n            const values = { \"min\": 0.0, \"max\": 1.0 };\n            options.placementPosition = values[options.placePosition];\n        }\n\n        // Remove legacy options.\n        delete options.position;\n        delete options.placePosition;\n\n        function validateValueRange(value, defaultValue) {\n            if (value === undefined || value === null) {\n                return defaultValue;\n            }\n    \n            if (typeof value !== \"number\") return defaultValue;\n            if (value < 0.0) return 0.0; // Capped at minimum\n            if (value > 1.0) return 1.0; // Capped at maximum\n            return value; // Valid value stays unchanged\n        }\n\n        // If the above did not result in a valid `slicingPosition` or `placementPosition`,\n        // then it means the client code did not use any legacy option, and did not supply\n        // a value for these two options. We will use default values for them.\n        //\n        options.slicingPosition = validateValueRange(options.slicingPosition, 0.5);\n        options.placementPosition = validateValueRange(options.placementPosition, 0.0);\n\n        return options;\n    }\n\n    /**\n     * Internal function, setup the heatmap instance and geometry with UV\n     * @private\n     * @param {String|[String]} nodeId - Shading data group id\n     * @param {String} sensorType - Current Shading Sensor Type\n     * @param {number} radius\n     */\n    _setup(nodeIds, sensorType, radius = 200) {\n        // cacluate the bounds for the shading area\n        let { model, shadingData } = this;\n        let totalBounds = new THREE.Box3();\n        let instanceTree = model.getInstanceTree();\n\n        let leafs = [];\n        let boundsMap = {};\n        let dst = [];\n        let pointDataMap = {};\n\n        if (this.gradientMap[sensorType]) {\n            this.config.gradient = this.gradientMap[sensorType];\n        }\n        this.config.radius = radius;\n\n\n        function isLeafContainsSensor(leaf) {\n            if(leaf.shadingPoints == null || leaf.shadingPoints\n                && leaf.shadingPoints.length == 0) {\n                return false;\n            }\n\n            return !(leaf.shadingPoints.find((item) => item.types.find(t => t == sensorType)) == null);\n        }\n\n        nodeIds.forEach((nodeId) => shadingData.getLeafsById(nodeId, leafs));\n\n        // get the total bounds\n        for (let i = 0; i < leafs.length; i++) {\n            if (isLeafContainsSensor(leafs[i])) {\n                leafs[i].dbIds.forEach((dbId) => {\n                    instanceTree.getNodeBox(dbId, dst);\n\n                    if (dst[0] != Infinity) {\n                        let bound = new THREE.Box3(new THREE.Vector3(dst[0], dst[1], dst[2]), new THREE.Vector3(dst[3], dst[4], dst[5]));\n\n                        totalBounds.union(bound);\n                        boundsMap[dbId] = bound;\n                    }\n                });\n            }\n        }\n\n        const x0 = totalBounds.min.x;\n        const y0 = totalBounds.min.y;\n        const w0 = totalBounds.max.x - x0;\n        const h0 = totalBounds.max.y - y0;\n\n        // resize the canvas to keep the ratio constant\n        let { slicingEnabled, width, height } = this.options;\n\n        if (w0 > h0) {\n            height = width / w0 * h0;\n        } else {\n            width = height / h0 * w0;\n        }\n\n        this.config.canvas.width = width;\n        this.config.canvas.height = height;\n        this.config.width = width;\n        this.config.height = height;\n\n        if (!this.heatmapInstance) {\n\n             /** {@link https://www.patrick-wied.at/static/heatmapjs/docs.html} */\n            // 'HeatmapJS requires a 'container' to be passed in the config (from which\n            // computed styles are obtained by calling 'getComputedStyle' API). \n            // If it isn't passed in the library throws an exception. To satisfy that \n            // requirement, we create a dummy <div> element to avoid the crash.\n            \n            let container = document.createElement(\"div\"); // Container for heatmap.js instance\n            container.width = width;\n            container.height = height;\n\n            this.config.container = container;\n            this.heatmapInstance = h337.create(this.config);\n\n            // Another side effect of 'h337.create()' is that it adds 'config.canvas'\n            // as a child element of 'config.container'. That obviously is undesirable so \n            // here we remove the canvas from container, before removing the reference to \n            // 'config.container' to avoid resource leak.\n            // \n            container.removeChild(this.config.canvas);\n            delete this.config.container;\n        } else {\n            // Reuse the heatmap object so that it won't be disconnected\n            // from the corresponding graphics resources (e.g. textures).\n            this.heatmapInstance.configure(this.config);\n        }\n\n        // prepare for the geometry\n        // make assumption that the geometry is not that complex, means more than 65536 vertices\n        let positions = [];\n        let uv = [];\n        let indices = [];\n\n        const cg = Autodesk.Viewing.Extensions.CompGeom;\n        const slicingPosition = this.options.slicingPosition;\n        const placementPosition = this.options.placementPosition;\n        var frags = model.getFragmentList();\n\n        for (let i = 0; i < leafs.length; i++) {\n            let currentLeafNode = leafs[i];\n\n            // Only process shading points with the matching sensor types.\n            const matchingShadingPoints = filterShadingPointsByType(\n                currentLeafNode.shadingPoints,\n                sensorType\n            );\n\n            if (matchingShadingPoints.length <= 0) {\n                continue;\n            }\n\n            if (slicingEnabled) {\n                let normal = new THREE.Vector3(0, 0, 1);\n\n                // assume we are doing only for simple geometry section\n                // if we decide to support very complex geometry, we need put this process in Async style\n                // mark this as TODO, don't want to over engineer this part until we have the request or hit performance threshold\n                var intersects = [];\n\n                currentLeafNode.dbIds.forEach((dbId) => {\n                    const bounds = boundsMap[dbId];\n                    const { min, max } = bounds;\n\n                    const zSlicing = min.z + ((max.z - min.z) * slicingPosition);\n                    const zPlacement = min.z + ((max.z - min.z) * placementPosition);\n\n                    const plane = new THREE.Plane(normal, -zSlicing);\n\n                    var toPlaneCoords = cg.makePlaneBasis(plane);\n\n                    const recursive = true;\n                    instanceTree.enumNodeFragments(dbId, (fragId) => {\n                        var m = frags.getVizmesh(fragId);\n                        if (m.geometry && !m.geometry.is2d && !m.geometry.isLines && m.material.cutplanes) {\n                            cg.xMeshPlane(plane, m, intersects);\n                        }\n                    }, recursive);\n\n\n                    // now we have all the intersection points\n                    // Code Reference from SectionTool: updateCapMeshes\n                    var bbox = new THREE.Box3();\n                    cg.convertToPlaneCoords(toPlaneCoords, intersects, bbox);\n\n                    var eset = new cg.EdgeSet(intersects, bbox, bbox.size().length() * 1e-6);\n                    eset.snapEdges();\n                    eset.sanitizeEdges();\n                    eset.stitchContours();\n\n                    //Create the 3D mesh\n                    var cset = eset.triangulate();\n\n                    // TODO: if required in future, the triangulate is not robuts, and it failed very frequently\n                    // If we need more robust way of doing the triangulation, we can spend more time on it\n                    // For simple room geometry, this is good enough\n                    if (cset && !cset.triangulationFailed) {\n                        var bg = cset.toPolygonMesh();\n\n                        let indexStart = positions.length / 3;\n\n                        let bgPosition = bg.attributes[\"position\"].array;\n\n                        for (let j = 0, count = bgPosition.length; j < count; j += 3) {\n                            positions.push(\n                                bgPosition[j],\n                                bgPosition[j + 1],\n                                zPlacement\n                            );\n\n                            uv.push(\n                                (bgPosition[j] - x0) / w0,\n                                (bgPosition[j + 1] - y0) / h0\n                            );\n                        }\n\n                        let bgIndices = bg.attributes[\"index\"].array;\n                        for (let j = 0, count = bgIndices.length; j < count; j++) {\n                            indices.push(bgIndices[j] + indexStart);\n                        }\n                    }\n                });\n\n            } else {\n                currentLeafNode.dbIds.forEach((dbId) => {\n                    let bounds = boundsMap[dbId];\n\n                    if (!bounds.isEmpty()) {\n                        const { min, max } = bounds;\n                        const zPlacement = min.z + ((max.z - min.z) * placementPosition);\n\n                        let index = positions.length / 3;\n\n                        indices.push(index, index + 2, index + 1, index, index + 3, index + 2);\n                        positions.push(\n                            min.x, min.y, zPlacement,\n                            min.x, max.y, zPlacement,\n                            max.x, max.y, zPlacement,\n                            max.x, min.y, zPlacement\n                        );\n\n                        uv.push(\n                            (min.x - x0) / w0, (min.y - y0) / h0,\n                            (min.x - x0) / w0, (max.y - y0) / h0,\n                            (max.x - x0) / w0, (max.y - y0) / h0,\n                            (max.x - x0) / w0, (min.y - y0) / h0,\n                        );\n                    }\n                });\n            }\n\n            // Only add shading point that matches the specific sensor type.\n            for (let point of matchingShadingPoints) {\n                let pData = {\n                    x: Math.round((point.position.x - x0) / w0 * width),  // in texture space: X, integer please!\n                    y: Math.round((point.position.y - y0) / h0 * height), // in texture space: Y, integer please!\n                    value: 0\n                };\n\n                pointDataMap[point.id] = {\n                    data: pData,\n                    shadingPoint: point\n                };\n            }\n        }\n\n        positions = new Float32Array(positions);\n        uv = new Float32Array(uv);\n        indices = new Uint16Array(indices);\n\n        // create the buffer geometry\n        let geometry = new THREE.BufferGeometry();\n        let positionAttribute = new THREE.BufferAttribute(positions, 3);\n        positionAttribute.bytesPerItem = 4;\n\n        let uvAttribute = new THREE.BufferAttribute(uv, 2);\n        uvAttribute.bytesPerItem = 4;\n\n        let indexAttribute = new THREE.BufferAttribute(indices, 1);\n\n        geometry.setAttribute(\"index\", indexAttribute);\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"uv\", uvAttribute);\n\n\n\n        // \n        this.geometry = geometry;\n        let viewerImp = this.viewer.impl;\n        viewerImp.createOverlayScene(surfaceShadingOverlay);\n\n        let mesh = new THREE.Mesh(geometry, this.material);\n        viewerImp.addOverlay(surfaceShadingOverlay, mesh);\n\n        this.totalBounds = totalBounds;\n        this.pointDataMap = pointDataMap;\n        this.currentSensorType = sensorType;\n    }\n\n    /**\n     * Renders one or more nodes with the given identifiers. This call creates\n     * necessary resources like overlay scene and materials, therefore is by \n     * design to be called only when necessary (i.e., when surface shading needs\n     * to be updated due to geometry changes). For more light weight rendering,\n     * updateShading API should be used instead.\n     * \n     * @param {string|string[]} nodeId One or more identifiers of nodes\n     * to render. These identifiers are among the ones provided through\n     * SurfaceShadingData when the SurfaceShading object is constructed.\n     * @param {string} sensorType The type of sensor to render the shading for.\n     * @param {SensorValueCallback} sensorValueCallback The callback function that\n     * will be invoked when SurfaceShading requires the sensor value to render.\n     * @param {HeatmapConfig} [heatmapConfig] Optional. The configuration of the\n     * heatmap. See documentation for `HeatmapConfig` for more details.\n     */\n    render(nodeIds, sensorType, sensorValueCallback, heatmapConfig) {\n        // See `SurfaceShading.render()` function for more details on how \n        // backward compatibility is being maintained with the following checks.\n        //\n        let confidenceSize = 200.0;\n        if (typeof heatmapConfig === \"number\") {\n            confidenceSize = Math.abs(heatmapConfig);\n        } else if (typeof heatmapConfig === \"object\") {\n            if (heatmapConfig.confidence) {\n                confidenceSize = heatmapConfig.confidence;\n            }\n        }\n\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n\n        nodeIds = nodeIds instanceof Array ? nodeIds : [nodeIds];\n        this._setup(nodeIds, sensorType, confidenceSize);\n\n        this.updateShading(sensorValueCallback);\n    }\n\n    /**\n     * This function is useful when in timeline triggered replay scenario\n     *\n     * @param {SensorValueCallback} sensorValueCallback Return a sensor value for the time context\n     */\n     updateShading(sensorValueCallback) {\n        const dataPoints = [];\n\n        for (let key in this.pointDataMap) {\n            const point = this.pointDataMap[key];\n\n            // Pass the data in, in case user want to change the radius\n            const value = sensorValueCallback(\n                point.shadingPoint,\n                this.currentSensorType,\n                point.data\n            );\n\n            // Heatmap.js does not handle absolute `0.0` well (it treats it as\n            // max value), it needs to be bumped slightly above `0.0` for it to\n            // work correctly. Also, value of `NaN` will now be excluded from \n            // contributing to the heatmap.\n            // \n            point.data.value = value === 0.0 ? 0.0001 : value;\n            if (!isNaN(point.data.value)) {\n                dataPoints.push(point.data);\n            }\n        }\n\n        this.heatmapInstance.setData({ data: dataPoints, min: 0.0, max: 1.0 });\n\n        this.material.map.needsUpdate = true;\n        this.viewer.impl.invalidate(false, false, true);\n    }\n\n    /**\n     * Cleans up overlay used for the surface shading, as well as the materials\n     * created to render surface shading.\n     */\n    cleanUp() {\n        this.removeShading();\n\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n\n        if (this.material) {\n            this.material.dispose();\n            this.material = null;\n        }\n    }\n\n    /**\n     * Removes any surface shading created by clearing the overlay which holds\n     * the meshes used as heatmap representation. Note that this call does not\n     * release other resources like materials created.\n     */\n    removeShading() {\n        this.viewer.impl.removeOverlayScene(surfaceShadingOverlay);\n        this.viewer.impl.invalidate(false, false, true);\n    }\n\n\n    /**\n     *\n     * @param {string} sensorType\n     * @param {number[]} colors\n     */\n    registerSensorColors(sensorType, colors) {\n        let gradient = {};\n        let size = colors.length - 1;\n\n        function intToRGB(color) {\n            let b = color & 0xFF;\n            let g = (color >> 8) & 0xFF;\n            let r = (color >> 16) & 0xFF;\n\n            return `rgb(${r}, ${g}, ${b})`;\n        }\n\n        for (let i = 0; i < colors.length; i++) {\n            gradient[(i / size).toFixed(3)] = intToRGB(colors[i]);\n        }\n\n        this.gradientMap[sensorType] = gradient;\n    }\n}\n\nexport {\n    PlanarHeatmap\n};","export class TextureUtility {\n    constructor(viewer) {\n        this.viewer = viewer;\n        this._textures = {};\n        this._colors = {};\n        this._excluded = [\n            \"__defaultMaterial__\",\n            \"__fadeMaterial__\",\n            \"__highlightMaterial__\",\n            \"__dataVizSpriteMaterial__\",\n        ];\n    }\n\n    show() {\n        // this.viewer.setLightPreset(this._dataModel.dasherSettings.noTexturesLighting);\n        this.hideTextures();\n        this.regen();\n        return true;\n    }\n\n    hide() {\n        // this.viewer.setLightPreset(this._dataModel.dasherSettings.initialLighting);\n        this.showTextures();\n        this.regen();\n        return true;\n    }\n\n    regen() {\n        this.viewer.refresh(true);\n        // this.viewer.impl.invalidate(true, true, false);\n    }\n\n    hideTextures() {\n        const store = Object.keys(this._textures).length === 0;\n        const white = new THREE.Color(1, 1, 1);\n\n        const mats = this.viewer.impl.matman()._materials;\n        for (const p in mats) {\n            if (this._excluded.indexOf(p) === -1) {\n                const m = mats[p];\n                if (store) {\n                    this._textures[p] = m.map;\n                    this._colors[p] = m.color;\n                }\n                m.map = null;\n                m.color = white;\n                m.needsUpdate = true;\n            }\n        }\n        this.regen();\n    }\n\n    showTextures() {\n        if (Object.keys(this._textures).length > 0) {\n            const mats = this.viewer.impl.matman()._materials;\n            for (const p in mats) {\n                if (this._excluded.indexOf(p) === -1) {\n                    const m = mats[p];\n                    const mat = this._textures[p];\n                    if (mat) {\n                        m.map = mat;\n                    }\n                    const col = this._colors[p];\n                    if (col) {\n                        m.color = col;\n                    }\n                    m.needsUpdate = true;\n                }\n            }\n        }\n        this.regen();\n    }\n}\n","/**\n * The position of the vertex whose value is to be determined by influences\n * from scattered nearby data points. The interpolation is done by Inverse\n * distance weighting (IDW) method.\n *\n * IDW: Inverse distance weighting\n * https://en.wikipedia.org/wiki/Inverse_distance_weighting\n */\nclass IDWProcessMaterial extends THREE.ShaderMaterial {\n    constructor(vertexTexture, dataTexture, dataCount, power = 1) {\n        power = parseFloat(power).toFixed(3);\n\n        const uniforms = {\n            dataTexture: { type: \"t\", value: null },\n            vertexTexture: { type: \"t\", value: null },\n            uPower: { type: \"f\", value: power },\n            uDataCount: { type: \"i\", value: dataCount },\n            uDataTextureWidth: { type: \"i\", value: 1 },\n        };\n\n        const vertexShader = `\n            varying vec2 vUV;\n\n            void main()\n            {\n                vUV = uv;\n                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        `;\n\n        const fragmentShader = `\n            varying vec2 vUV;\n\n            uniform float uPower;\n            uniform int uDataCount;\n            uniform int uDataTextureWidth;\n            \n            uniform sampler2D dataTexture;\n            uniform sampler2D vertexTexture;\n            \n            void main(void) {\n                // The position of the vertex whose value is to be determined.\n                vec4 vertex = texture2D(vertexTexture, vUV);\n            \n                if (vertex.w < 0.) {\n                    // This is an invalid vertex, mark as transparent.\n                    gl_FragColor = vec4(0., 0., 0., 1.);\n                    return;\n                }\n            \n                float sum = 0.;\n                float wsum = 0.;\n                float factor = 1. / float(uDataTextureWidth);\n                float textureWidth = float(uDataTextureWidth);\n            \n                // Compute weighted influence from all the data points.\n                for (int index = 0; index < uDataCount; index++)\n                {\n                    float i = float(index);\n                    float y = floor(i / textureWidth);\n                    float x = mod(i, textureWidth);\n            \n                    vec2 dUV = vec2((x + 0.5) * factor, (y + 0.5) * factor);\n                    vec4 dataPoint = texture2D(dataTexture, dUV);\n            \n                    float dist = distance(vertex.xyz, dataPoint.xyz);\n            \n                    if (dist < 0.0001) {\n                        gl_FragColor = vec4(dataPoint.w, 0., 0., 1.);\n                        return;\n                    }\n            \n                    float w = 1. / dist;\n                    w = pow(w, uPower);\n            \n                    sum += dataPoint.w * w;\n                    wsum += w;\n                }\n            \n                gl_FragColor = vec4(sum/wsum , 0., 0., 1.);\n            }\n        `;\n\n        super({\n            uniforms,\n            vertexShader,\n            fragmentShader,\n            side: THREE.DoubleSide,\n            depthTest: true,\n            depthWrite: true,\n        });\n\n        this.vertexTexture = vertexTexture;\n        this.dataTexture = dataTexture;\n    }\n\n    /**\n     * Texture for vertice\n     */\n    set vertexTexture(value) {\n        if (value) {\n            this.uniforms.vertexTexture.value = value;\n        }\n    }\n\n    /**\n     * Texture for sensor locations\n     */\n    set dataTexture(value) {\n        if (value) {\n            this.uniforms.dataTexture.value = value;\n            this.uniforms.uDataTextureWidth.value = value.image.width;\n        }\n    }\n}\n\nclass IDWDataProcessor {\n    /**\n     * Constructs an instance of `IDWDataProcessor` object.\n     *\n     * @param {Viewer3D} viewer The viewer object.\n     * @param {number[]} vertices The input vertex positions in the form of `[x, y, z, ...]`\n     * @param {number[]} dataPoints The input data point positions and values in the form\n     * of `[x, y, z, w, ...]` where `w` represents the value of the corresponding data point.\n     * @param {Object} [options] The optional configuration for `IDWDataProcessor` object.\n     * @param {number} [min] Optional. The smallest `w` value found in `dataPoints` list.\n     * If this value is not specified, it is derived from the given `dataPoints` parameter.\n     * @param {number} [max] Optional. The largest `w` value found in `dataPoints` list.\n     * If this value is not specified, it is derived from the given `dataPoints` parameter.\n     * @param {number[]} [colors] Optional. An array of color values. See `setColors`\n     * function for more details.\n     */\n    constructor(viewer, vertices, dataPoints, options = {}) {\n        this.viewer = viewer;\n\n        this.min = options.min;\n        this.max = options.max;\n\n        let { colors } = options;\n        if (colors) {\n            this.setColors(colors);\n        } else {\n            this.setColors([0x0000ff, 0x00ffff, 0x00ff00, 0xffff00, 0xff0000]);\n        }\n\n        this.setVertices(vertices);\n        this.setDataPoints(dataPoints);\n\n        this.initializeRender();\n    }\n\n    /**\n     * Sets the list of mesh vertex positions.\n     *\n     * @param {number[]} vertices The input vertex positions in the form of `[x, y, z, ...]`\n     */\n    setVertices(vertices) {\n        if (this.vertexTexture) {\n            this.vertexTexture.dispose();\n            this.vertexTexture = null;\n        }\n\n        const textureSize = Math.ceil(Math.sqrt(vertices.length / 3));\n        const verticesData = new Float32Array(textureSize * textureSize * 4);\n        verticesData.fill(-1);\n\n        for (let i = 0, count = vertices.length / 3; i < count; i++) {\n            verticesData[i * 4] = vertices[i * 3];\n            verticesData[i * 4 + 1] = vertices[i * 3 + 1];\n            verticesData[i * 4 + 2] = vertices[i * 3 + 2];\n            verticesData[i * 4 + 3] = 1;\n        }\n\n        const vertexTexture = new THREE.DataTexture(\n            verticesData,\n            textureSize,\n            textureSize,\n            THREE.RGBAFormat,\n            THREE.FloatType,\n            THREE.UVMapping,\n            THREE.ClampToEdgeWrapping,\n            THREE.ClampToEdgeWrapping,\n            THREE.NearestFilter,\n            THREE.NearestFilter\n        );\n\n        vertexTexture.generateMipmaps = false;\n        vertexTexture.needsUpdate = true;\n        this.vertexTexture = vertexTexture;\n        this.verticesLength = vertices.length;\n\n        // Create a buffer to read computed vertex values.\n        this.vertexValues = new Uint8Array(textureSize * textureSize * 4);\n    }\n\n    /**\n     * Sets the list of data point positions and values.\n     *\n     * @param {number[]} dataPoints The input data point positions and values in the form\n     * of `[x, y, z, w, ...]` where `w` represents the value of the corresponding data point.\n     */\n    setDataPoints(dataPoints) {\n        if (this.dataTexture) {\n            this.dataTexture.dispose();\n            this.dataTexture = null;\n        }\n\n        const textureSize = Math.ceil(Math.sqrt(dataPoints.length / 4));\n        const dataBuffer = new Float32Array(textureSize * textureSize * 4);\n\n        let { min, max } = this;\n        if (min == undefined || max == undefined) {\n            (min = Infinity), (max = -Infinity);\n\n            for (let i = 0; i < dataPoints.length; i += 4) {\n                min = Math.min(min, dataPoints[i + 3]);\n                max = Math.max(max, dataPoints[i + 3]);\n            }\n        }\n\n        const delta = max - min || 1;\n        for (let i = 0; i < dataPoints.length; i += 4) {\n            dataBuffer[i] = dataPoints[i];\n            dataBuffer[i + 1] = dataPoints[i + 1];\n            dataBuffer[i + 2] = dataPoints[i + 2];\n            dataBuffer[i + 3] = (dataPoints[i + 3] - min) / delta;\n        }\n\n        const dataTexture = new THREE.DataTexture(\n            dataBuffer,\n            textureSize,\n            textureSize,\n            THREE.RGBAFormat,\n            THREE.FloatType,\n            THREE.UVMapping,\n            THREE.ClampToEdgeWrapping,\n            THREE.ClampToEdgeWrapping,\n            THREE.NearestFilter,\n            THREE.NearestFilter\n        );\n\n        dataTexture.generateMipmaps = false;\n        dataTexture.needsUpdate = true;\n        this.dataTexture = dataTexture;\n        this.dataCount = dataPoints.length / 4;\n    }\n\n    /**\n     * Setup rendering related code\n     */\n    initializeRender() {\n        const idwMaterial = new IDWProcessMaterial(\n            this.vertexTexture,\n            this.dataTexture,\n            this.dataCount\n        );\n\n        const planeGeometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);\n        const orthCamera = new THREE.OrthographicCamera(-1, 1, -1, 1, 0, 1);\n\n        const targetSize = this.vertexTexture.image.width;\n        const renderTarget = new THREE.WebGLRenderTarget(targetSize, targetSize, {\n            minFilter: THREE.NearestFilter,\n            magFilter: THREE.NearestFilter,\n            format: THREE.RGBAFormat,\n            // type: THREE.FloatType,\n            stencilBuffer: false,\n            depthBuffer: false,\n        });\n\n        const planeMesh = new THREE.Mesh(planeGeometry, idwMaterial);\n        planeMesh.frustumCulled = false;\n        this.scene = new THREE.Scene();\n        this.scene.add(planeMesh);\n\n        this.material = idwMaterial;\n        this.renderTarget = renderTarget;\n        this.planeGeometry = planeGeometry;\n        this.camera = orthCamera;\n    }\n\n    /**\n     * Registers color stops for use in color interpolation. The specified color\n     * stops evenly spread out across the spectrum that represents the normalized\n     * data values ranging between 0.0 and 1.0.\n     *\n     * Expose this API to help user to try differnt color theme\n     * @param {number[]} colors An array of color values, each expressed in a\n     * 3-byte (24-bit) numerical value. Note that it is possible to specify a\n     * 4-byte (32-bit) number as color, but only 3 lower bytes will be taken.\n     * Each of the three bytes represents the intensity value between `0` and `255`,\n     * of red, green, blue color component respectively. For example, `0xff0000`\n     * represents a red color with full intensity.\n     *\n     * @example\n     *  // Register 3 color stops to visualize normalized data.\n     *  dataProcessor.setColors([0x0f2027, 0x203a43, 0x2c5364]);\n     */\n    setColors(colors) {\n        if (colors) {\n            this.colors = colors.map((color) => new THREE.Color(color));\n            this.stops = this._createColorStops(colors.length);\n\n            // Pre-generate the lookup table will save lots of time and GC pressure\n            this.colorMapData = [];\n            for (let i = 0; i < 256; i++) {\n                this.colorMapData.push(this._mapValueToColor(i / 255));\n            }\n        }\n    }\n\n    /**\n     * @private\n     * @param {number} n\n     * @returns\n     */\n    _createColorStops(n) {\n        const res = [];\n        const inc = 1 / (n - 1);\n        for (let i = 0; i < n; i++) {\n            res.push(inc * i);\n        }\n        return res;\n    }\n\n    /**\n     * @private\n     * @param {number} value\n     * @returns {{r,g,b}} color\n     */\n    _mapValueToColor(value) {\n        let { colors, stops } = this;\n\n        function mix(l, r, p) {\n            return l * (1 - p) + r * p;\n        }\n\n        function mixColor(c1, c2, p) {\n            let result = new THREE.Color();\n            result.r = mix(c1.r, c2.r, p);\n            result.g = mix(c1.g, c2.g, p);\n            result.b = mix(c1.b, c2.b, p);\n\n            return result;\n        }\n\n        let result = colors[stops.length - 1];\n        for (let i = 1; i < stops.length; i++) {\n            if (value <= stops[i]) {\n                let p = (value - stops[i - 1]) / (stops[i] - stops[i - 1]);\n                result = mixColor(colors[i - 1], colors[i], p);\n                break;\n            }\n        }\n\n        let r = Math.round(255 * result.r);\n        let g = Math.round(255 * result.g);\n        let b = Math.round(255 * result.b);\n\n        return { r, g, b };\n    }\n\n    /**\n     * Process input vertex and data points to produce per-vertex color data.\n     *\n     * @param {{colors: number[], power: number, outputTarget}} [options] The\n     * optional configuration object for the processing.\n     */\n    process(options = {}) {\n        let { colors, power, outputTarget } = options;\n\n        if (colors) {\n            this.setColors(colors);\n        }\n\n        if (power === undefined || power === null) {\n            power = 1;\n        }\n\n        this.material.uniforms[\"uPower\"].value = power;\n\n        const targetSize = this.vertexTexture.image.width;\n        if (this.renderTarget.width != targetSize) {\n            this.renderTarget.setSize(targetSize, targetSize);\n        }\n\n        const renderer = this.viewer.impl.glrenderer();\n        renderer.render(this.scene, this.camera, this.renderTarget, true);\n\n        renderer.readRenderTargetPixels(\n            this.renderTarget,\n            0,\n            0,\n            targetSize,\n            targetSize,\n            this.vertexValues\n        );\n\n        return this._getColorValues(outputTarget);\n    }\n\n    /**\n     * @private\n     * Compute color values for each vertex processed by `IDWDataProcessor`.\n     *\n     * @param {Uint8Array} [outputTarget] The output `Uint8Array` where color\n     * data is to be written. The output content is in the form of `[r, g, b, ...]`\n     * where each color component is in the range of `[0, 255]`.\n     *\n     * @returns If a valid object was passed in as the `outputTarget` parameter,\n     * then the same object is returned. Otherwise this function returns a new\n     * `Uint8Array` that contains the color data. The output content is in the form\n     * of `[r, g, b, ...]` where each color component is in the range of `[0, 255]`.\n     */\n    _getColorValues(outputTarget) {\n        let colors;\n        if (outputTarget && outputTarget.length == this.verticesLength) {\n            colors = outputTarget;\n        } else {\n            colors = new Uint8Array(this.verticesLength);\n        }\n\n        const outputValues = this.vertexValues;\n        for (let i = 0, count = this.verticesLength / 3; i < count; i++) {\n            const index = i * 4;\n            const alpha = outputValues[index + 3];\n\n            if (alpha < 128) {\n                continue;\n            }\n\n            const value = outputValues[index];\n            const color = this.colorMapData[value];\n\n            colors[i * 3] = color.r;\n            colors[i * 3 + 1] = color.g;\n            colors[i * 3 + 2] = color.b;\n        }\n\n        return colors;\n    }\n\n    /**\n     * Release the resources to avoid OOM\n     */\n    cleanUp() {\n        // There is webgl warnings if immidiately dispose the resources\n        setTimeout(() => {\n            if (this.vertexTexture) {\n                this.vertexTexture.dispose();\n                this.vertexTexture = null;\n            }\n\n            if (this.dataTexture) {\n                this.dataTexture.dispose();\n                this.dataTexture = null;\n            }\n\n            if (this.renderTarget) {\n                this.renderTarget.dispose();\n                this.renderTarget = null;\n            }\n\n            if (this.material) {\n                this.material.dispose();\n                this.material = null;\n            }\n\n            if (this.planeGeometry) {\n                this.planeGeometry.dispose();\n                this.planeGeometry = null;\n            }\n        }, 32);\n    }\n}\n\nexport { IDWDataProcessor, IDWProcessMaterial };\n","function memcpy(src, srcOffset, dst, dstOffset, length) {\n    src = src.subarray || src.slice ? src : src.buffer;\n    dst = dst.subarray || dst.slice ? dst : dst.buffer;\n\n    src = srcOffset\n        ? src.subarray\n            ? src.subarray(srcOffset, length && srcOffset + length)\n            : src.slice(srcOffset, length && srcOffset + length)\n        : src;\n\n    if (dst.set) {\n        dst.set(src, dstOffset);\n    } else {\n        for (let i = 0; i < src.length; i++) {\n            dst[i + dstOffset] = src[i];\n        }\n    }\n\n    return dst;\n}\n\nclass StreamLine {\n    constructor() {\n        this._position = [];\n        this._prev = [];\n        this._next = [];\n        this._side = [];\n        this._width = [];\n        this._index = [];\n\n        this._widthCallback = null;\n        this._geometry = null; // THREE.BufferGeometry();\n    }\n\n    get geometry() {\n        return this._geometry;\n    }\n\n    dispose() {\n        if (this._geometry) {\n            this._geometry.dispose();\n            this._geometry = null;\n        }\n    }\n\n    setPoints(points, wcb) {\n        if (!(points instanceof Float32Array) || points.length === 0) {\n            throw new Error(\"Input points must be of Float32Array type\");\n        }\n\n        this._widthCallback = wcb;\n        this._position = [];\n\n        for (let j = 0; j < points.length; j += 3) {\n            this._position.push(points[j], points[j + 1], points[j + 2]);\n            this._position.push(points[j], points[j + 1], points[j + 2]);\n        }\n\n        this.process();\n    }\n\n    compareV3(a, b) {\n        const aa = a * 6;\n        const ab = b * 6;\n\n        return (\n            this._position[aa] === this._position[ab] &&\n            this._position[aa + 1] === this._position[ab + 1] &&\n            this._position[aa + 2] === this._position[ab + 2]\n        );\n    }\n\n    copyV3(a) {\n        const aa = a * 6;\n        return {\n            x: this._position[aa],\n            y: this._position[aa + 1],\n            z: this._position[aa + 2],\n        };\n    }\n\n    updateAttribute(attribute, dataArray) {\n        attribute.set(dataArray);\n        attribute.needsUpdate = true;\n    }\n\n    process() {\n        const l = this._position.length / 6;\n\n        this._prev = [];\n        this._next = [];\n        this._side = [];\n        this._width = [];\n        this._index = [];\n\n        const isLoop = this.compareV3(0, l - 1);\n\n        {\n            // Create a 'previous point' for the first point of line. This 'previous'\n            // point of the first point can either be the same as the first point itself\n            // (when the line does not form a loop), or the second last point (when the\n            // line is a loop).\n            //\n            const copyFromIndex = isLoop ? l - 2 : 0;\n            const { x, y, z } = this.copyV3(copyFromIndex);\n\n            this._prev.push(x, y, z);\n            this._prev.push(x, y, z);\n        }\n\n        for (var j = 0; j < l; j++) {\n            // sides\n            this._side.push(1);\n            this._side.push(-1);\n\n            // widths\n            let w = 1.0;\n            if (this._widthCallback) {\n                w = this._widthCallback(j / (l - 1));\n            }\n\n            this._width.push(w);\n            this._width.push(w);\n\n            if (j < l - 1) {\n                // points prev to poisitions\n                const { x, y, z } = this.copyV3(j);\n                this._prev.push(x, y, z);\n                this._prev.push(x, y, z);\n\n                // indices\n                var n = j * 2;\n                this._index.push(n, n + 1, n + 2);\n                this._index.push(n + 2, n + 1, n + 3);\n            }\n            if (j > 0) {\n                // points after poisitions\n                const { x, y, z } = this.copyV3(j);\n                this._next.push(x, y, z);\n                this._next.push(x, y, z);\n            }\n        }\n\n        {\n            // Create a 'next point' for the last point in the line. This 'next' point\n            // of the last point in line can either be the same as the last point itself\n            // (when the line does not form a loop), or the second point in line (when\n            // the line is a loop).\n            //\n            const copyFromIndex = isLoop ? 1 : l - 1;\n            const { x, y, z } = this.copyV3(copyFromIndex);\n\n            this._next.push(x, y, z);\n            this._next.push(x, y, z);\n        }\n\n        const positionArray = new Float32Array(this._position);\n        const prevArray = new Float32Array(this._prev);\n        const nextArray = new Float32Array(this._next);\n        const sideArray = new Float32Array(this._side);\n        const widthArray = new Float32Array(this._width);\n        const indexArray = new Uint16Array(this._index);\n\n        if (!this._attributes || this._attributes.position.length !== this._position.length) {\n            this._attributes = {\n                position: new THREE.BufferAttribute(positionArray, 3),\n                prev: new THREE.BufferAttribute(prevArray, 3),\n                next: new THREE.BufferAttribute(nextArray, 3),\n                side: new THREE.BufferAttribute(sideArray, 1),\n                width: new THREE.BufferAttribute(widthArray, 1),\n                index: new THREE.BufferAttribute(indexArray, 1),\n            };\n        } else {\n            this.updateAttribute(this._attributes.position, positionArray);\n            this.updateAttribute(this._attributes.prev, prevArray);\n            this.updateAttribute(this._attributes.next, nextArray);\n            this.updateAttribute(this._attributes.side, sideArray);\n            this.updateAttribute(this._attributes.width, widthArray);\n            this.updateAttribute(this._attributes.index, indexArray);\n        }\n\n        if (!this._geometry) {\n            this._geometry = new THREE.BufferGeometry();\n        }\n\n        this._geometry.setAttribute(\"position\", this._attributes.position);\n        this._geometry.setAttribute(\"prev\", this._attributes.prev);\n        this._geometry.setAttribute(\"next\", this._attributes.next);\n        this._geometry.setAttribute(\"side\", this._attributes.side);\n        this._geometry.setAttribute(\"width\", this._attributes.width);\n        this._geometry.setAttribute(\"index\", this._attributes.index);\n\n        this._geometry.computeBoundingSphere();\n        this._geometry.computeBoundingBox();\n        this._geometry.visible = true;\n    }\n\n    /**\n     * Fast method to advance the line by one position.  The oldest position is removed.\n     * @param position\n     */\n    advance(position) {\n        var positions = this._attributes.position.array;\n        var prev = this._attributes.prev.array;\n        var next = this._attributes.next.array;\n        var l = positions.length;\n\n        // PREV\n        memcpy(positions, 0, prev, 0, l);\n\n        // POSITIONS\n        memcpy(positions, 6, positions, 0, l - 6);\n\n        positions[l - 6] = position.x;\n        positions[l - 5] = position.y;\n        positions[l - 4] = position.z;\n        positions[l - 3] = position.x;\n        positions[l - 2] = position.y;\n        positions[l - 1] = position.z;\n\n        // NEXT\n        memcpy(positions, 6, next, 0, l - 6);\n\n        next[l - 6] = position.x;\n        next[l - 5] = position.y;\n        next[l - 4] = position.z;\n        next[l - 3] = position.x;\n        next[l - 2] = position.y;\n        next[l - 1] = position.z;\n\n        this._attributes.position.needsUpdate = true;\n        this._attributes.prev.needsUpdate = true;\n        this._attributes.next.needsUpdate = true;\n    }\n}\n\nexport { StreamLine };\n","import { StreamLineVert, StreamLineFrag } from \"./StreamLineShaders.js\";\n\nfunction StreamLineMaterial(parameters) {\n    function check(v, d) {\n        return v === undefined ? d : v;\n    }\n\n    THREE.Material.call(this);\n\n    parameters = parameters || {};\n    parameters = Object.assign(parameters, {\n        side: THREE.DoubleSide,\n        depthTest: true,\n        depthWrite: false,\n    });\n\n    this.lineColor = check(parameters.lineColor, new THREE.Color(0xffffff));\n    this.opacity = check(parameters.opacity, 1.0);\n    this.lineWidth = check(parameters.lineWidth, 6.0);\n\n    delete parameters.lineColor;\n    delete parameters.opacity;\n    delete parameters.lineWidth;\n\n    const vertexShader = StreamLineVert;\n    const fragmentShader = StreamLineFrag;\n\n    const material = new THREE.RawShaderMaterial({\n        uniforms: {\n            lineWidth: { type: \"f\", value: this.lineWidth },\n            color: { type: \"c\", value: this.lineColor },\n            opacity: { type: \"f\", value: this.opacity },\n            resolution: { type: \"v2\", value: new THREE.Vector2(1920, 1080) },\n            sizeAttenuation: { type: \"f\", value: 0.0 },\n        },\n        attributes: {\n            position: { type: \"v3\", value: new THREE.Vector3() },\n            prev: { type: \"v3\", value: new THREE.Vector3() },\n            next: { type: \"v3\", value: new THREE.Vector3() },\n            side: { type: \"f\", value: 0.0 },\n            width: { type: \"f\", value: 0.0 },\n        },\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n    });\n\n    material.type = \"StreamLineMaterial\";\n    material.setValues(parameters);\n    return material;\n}\n\nStreamLineMaterial.prototype = Object.create(THREE.Material.prototype);\nStreamLineMaterial.prototype.constructor = StreamLineMaterial;\n\nStreamLineMaterial.prototype.copy = function (source) {\n    THREE.Material.prototype.copy.call(this, source);\n    return this;\n};\n\nStreamLineMaterial.prototype.id = function () {\n    return StreamLineMaterial.generateId(this.lineColor, this.opacity, this.lineWidth);\n};\n\n// Static function on 'StreamLineMaterial' object.\nStreamLineMaterial.generateId = function (lineColor, opacity, lineWidth) {\n    const _lineColor = lineColor.getHexString();\n    const _opacity = opacity.toFixed(4);\n    const _lineWidth = lineWidth.toFixed(4);\n    return `${_lineColor}-${_opacity}-${_lineWidth}`;\n};\n\nexport { StreamLineMaterial };\n","const StreamLineVert = `\n    attribute vec3 position;\n    attribute vec3 prev;\n    attribute vec3 next;\n    attribute float side;\n    attribute float width;\n\n    uniform mat4 projectionMatrix;\n    uniform mat4 modelViewMatrix;\n    uniform vec2 resolution;\n    uniform float lineWidth;\n    uniform vec3 color;\n    uniform float opacity;\n    uniform float sizeAttenuation;\n\n    varying vec4 vColor;\n\n    vec2 fix( vec4 i, float aspect ) {\n\n        vec2 res = i.xy / i.w;\n        res.x *= aspect;\n        return res;\n    }\n\n    void main() {\n        float aspect = resolution.x / resolution.y;\n\n        vColor = vec4( color, opacity );\n\n        mat4 m = projectionMatrix * modelViewMatrix;\n        vec4 finalPosition = m * vec4( position, 1.0 );\n        vec4 prevPos = m * vec4( prev, 1.0 );\n        vec4 nextPos = m * vec4( next, 1.0 );\n\n        vec2 currP = fix( finalPosition, aspect );\n        vec2 prevP = fix( prevPos, aspect );\n        vec2 nextP = fix( nextPos, aspect );\n\n        float w = lineWidth * width;\n\n        vec2 dir;\n        if ( nextP == currP ) {\n            dir = normalize( currP - prevP );\n        }\n        else if( prevP == currP ) {\n            dir = normalize( nextP - currP );\n        }\n        else {\n            vec2 dir1 = normalize( currP - prevP );\n            vec2 dir2 = normalize( nextP - currP );\n            dir = normalize( dir1 + dir2 );\n\n            vec2 perp = vec2( -dir1.y, dir1.x );\n            vec2 miter = vec2( -dir.y, dir.x );\n            w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );\n        }\n\n        vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n        normal.xy *= .5 * w;\n        normal *= projectionMatrix;\n\n        if ( sizeAttenuation == 0. ) {\n            normal.xy *= finalPosition.w;\n            normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n        }\n\n        finalPosition.xy += normal.xy * side;\n        gl_Position = finalPosition;\n    }\n`;\n\nconst StreamLineFrag = `\n    varying vec4 vColor;\n\n    void main() {\n        gl_FragColor = vColor;\n    }\n`;\n\nexport { StreamLineVert, StreamLineFrag };\n","import { StreamLine } from \"./StreamLine.js\";\nimport { StreamLineMaterial } from \"./StreamLineMaterial.js\";\n\n/**\n * A callback function that will be invoked when `StreamLineBuilder` needs to determine the\n * line thickness for a given point along the `StreamLine`. This callback function can be\n * specified in a call to `StreamLineBuilder.createStreamLine` API.\n *\n * @callback GetLineWidthScaleFunc\n * @param {number} fraction The fraction number indicating the point this call is meant for.\n * For example, for point `200` in a line segment with `250` points, this value will be `0.8`.\n * @returns {number} The fraction of line thickness for this given point on the line. If this\n * value is `1.0`, the line thickness at this point will be equivalent to the thickness value\n * specified in `StreamLineSpecs.lineWidth`. If this value is `1.5` then the line thickness at\n * this point will be `1.5` times the value of `StreamLineSpecs.lineWidth`.\n */\n\n/**\n * An object which carries the coordinates and colors of points that made up the line.\n *\n * @typedef {Object} StreamLineData\n * @property {Float32Array} points The point array specified as `Float32Array`. It is a linear\n * array that carries the coordinates of the points forming the line `[x0, y0, z0, x1, ... ]`.\n * @property {Float32Array} [colors] The colors for each point specified in the `points`\n * array. This array is specified as a `Float32Array` and carries point colors in the form\n * of `[ r0, g0, b0, r1, g1, ... ]`. If this parameter is specified, it should contain as many\n * elements as there are in `points` parameter.\n * @property {GetLineWidthScaleFunc} [scaleCallback] The callback for line segment thickness.\n * See `GetLineWidthScaleFunc` for further details.\n */\n\n/**\n * An object representing the specifications of a stream line to be created. This object is\n * used in `StreamLineBuilder.createStreamLine` API.\n *\n * @typedef {Object} StreamLineSpecs\n * @property {number} lineWidth The width of the `StreamLine` object in terms of pixels.\n * Individual line segment widths can be specified as a fraction of this value through\n * `scaleCallback` function. See `GetLineWidthScaleFunc` for more details.\n * @property {THREE.Color} lineColor The global uniform line color. Individual segment colors\n * can be specified through `StreamLineData.colors` array. See `StreamLineData` for more\n * details.\n * @property {number} opacity The global uniform line opacity in the range of `[0.0, 1.0]`.\n * @property {StreamLineData} lineData The point data to initialize the `StreamLine` object\n * with. See `StreamLineData` for more details.\n */\n\nconst overlayName = \"StreamLineOverlay\";\n\n/**\n * An object that assists in building `StreamLine` objects.\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.StreamLineBuilder\n */\nclass StreamLineBuilder {\n    /**\n     * Constructs an instance of `StreamLineBuilder` object. For proper resource management\n     * it is recommended to obtain a `StreamLineBuilder` through `DataVisualization` class.\n     *\n     * @param {Viewer3D} viewer The instance a `Viewer3D` to associate this object with.\n     *\n     * @example\n     *  const dataVizExtn = await viewer.loadExtension(\"Autodesk.DataVisualization\");\n     *  const streamLineBuilder = dataVizExtn.streamLineBuilder;\n     */\n    constructor(viewer) {\n        this._viewer = viewer;\n        this._overlayCreated = false;\n        this._streamLines = [];\n        this._cachedMaterials = {};\n    }\n\n    /**\n     * Dispose of all the underlying `StreamLine` objects that are associated with this\n     * `StreamLineBuilder` object. This also releases their corresponding material and\n     * geometrical data.\n     * @alias Autodesk.DataVisualization.Core.StreamLineBuilder#dispose\n     */\n    dispose() {\n        // Dispose of all the 'Mesh' and 'StreamLine' objects first.\n        this._streamLines.forEach(({ streamLine, mesh }) => {\n            this._removeMeshFromScene(mesh);\n            streamLine.dispose();\n        });\n\n        this._streamLines = [];\n\n        // Dispose of all 'StreamLineMaterial' instances.\n        const materials = Object.values(this._cachedMaterials);\n        materials.forEach((cachedMaterial) => cachedMaterial.dispose());\n        this._cachedMaterials = {};\n\n        if (this._overlayCreated) {\n            this._overlayCreated = false;\n            this._viewer.impl.removeOverlayScene(overlayName);\n        }\n    }\n\n    /**\n     * Creates `StreamLine` objects using the {@link StreamLineSpecs} and associates them with the\n     * `StreamLineBuilder` object.\n     * @param {StreamLineSpecs} streamLineSpecs See `StreamLineSpecs` for more details.\n     * @returns {StreamLine}\n     * @alias Autodesk.DataVisualization.Core.StreamLineBuilder#createStreamLine\n     */\n    createStreamLine(streamLineSpecs) {\n        const streamLine = new StreamLine();\n        streamLine.setPoints(new Float32Array(streamLineSpecs.lineData.points));\n\n        const material = this._getOrCreateMaterial(streamLineSpecs);\n        const mesh = new THREE.Mesh(streamLine.geometry, material);\n        this._addMeshToScene(mesh);\n\n        this._streamLines.push({ streamLine, mesh });\n        return streamLine;\n    }\n\n    /**\n     * Removes the `StreamLine` object from the scene. This\n     * method releases the geometrical data associated with the `StreamLine` object.\n     * @alias Autodesk.DataVisualization.Core.StreamLineBuilder#destroyStreamLine\n     * @param {StreamLine} streamLine The `StreamLine` object to be disposed of.\n     * @alias Autodesk.DataVisualization.Core.StreamLineBuilder#destroyStreamLine\n     */\n    destroyStreamLine(streamLine) {\n        const index = this._streamLines.findIndex((entry) => {\n            return entry.streamLine === streamLine;\n        });\n\n        if (index >= 0) {\n            const removed = this._streamLines.splice(index, 1);\n            this._removeMeshFromScene(removed[0].mesh);\n            removed[0].streamLine.dispose();\n        }\n    }\n\n    /**\n     * @private\n     * @param {THREE.Mesh} mesh\n     */\n    _addMeshToScene(mesh) {\n        if (!this._overlayCreated) {\n            this._overlayCreated = true;\n            this._viewer.impl.createOverlayScene(overlayName);\n        }\n\n        this._viewer.impl.addOverlay(overlayName, mesh);\n    }\n\n    /**\n     * @private\n     * @param {THREE.Mesh} mesh\n     */\n    _removeMeshFromScene(mesh) {\n        if (this._overlayCreated) {\n            this._viewer.impl.removeOverlay(overlayName, mesh);\n        }\n    }\n\n    /**\n     * @private\n     * @param {StreamLineSpecs} streamLineSpecs\n     */\n    _getOrCreateMaterial(streamLineSpecs) {\n        const lineColor = streamLineSpecs.lineColor;\n        const opacity = streamLineSpecs.opacity;\n        const lineWidth = streamLineSpecs.lineWidth;\n\n        const id = StreamLineMaterial.generateId(lineColor, opacity, lineWidth);\n        let cachedMaterial = this._cachedMaterials[id];\n\n        if (!cachedMaterial) {\n            cachedMaterial = new StreamLineMaterial({ lineColor, opacity, lineWidth });\n            this._cachedMaterials[id] = cachedMaterial;\n        }\n\n        return cachedMaterial;\n    }\n}\n\nexport { StreamLineBuilder };\n","/**\n * Extension Entry file\n *\n * Examples about how to use this extension can be found:\n * https://git.autodesk.com/A360/hyperion/blob/develop/client/pages/Heatmap.jsx\n * https://git.autodesk.com/A360/hyperion/blob/develop/client/pages/Dot.jsx\n * https://git.autodesk.com/A360/hyperion/blob/develop/client/pages/EngineSimulation.jsx\n * https://git.autodesk.com/A360/hyperion/blob/develop/client/pages/ReferenceApp.jsx\n *\n */\n\nimport Constants from \"./Constants.js\";\nimport { SceneTool } from \"./SceneTool.js\";\nimport { SpriteMeshBuilder } from \"./SpriteMeshBuilder\";\nimport * as CustomViewables from \"./CustomViewables\";\nimport { Room, LevelRoomsMap, ModelStructureInfo } from \"./ModelStructureInfo\";\nimport { SurfaceShading } from \"./heatmap/SurfaceShading\";\nimport { PlanarHeatmap } from \"./heatmap/PlanarHeatmap\";\nimport { TextureUtility } from \"./TextureUtils\";\nimport { IDWDataProcessor, IDWProcessMaterial } from \"./heatmap/IDWDataProcessor\";\nimport * as SurfaceShadingInfo from \"./heatmap/SurfaceShadingData\";\nimport { StreamLineBuilder } from \"./streamline/StreamLineBuilder.js\";\n\nconst extnName = \"Autodesk.DataVisualization\";\nconst extNameSpace = extnName + \".Core\";\nvar ns = AutodeskNamespace(extNameSpace);\nns = Object.assign(ns, CustomViewables);\nns = Object.assign(ns, Constants);\nns = Object.assign(ns, SurfaceShadingInfo);\n\nns.Room = Room;\nns.LevelRoomsMap = LevelRoomsMap;\nns.ModelStructureInfo = ModelStructureInfo;\nns.SurfaceShading = SurfaceShading;\nns.PlanarHeatmap = PlanarHeatmap;\nns.IDWDataProcessor = IDWDataProcessor;\nns.IDWProcessMaterial = IDWProcessMaterial;\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\nconst datavizDotOverlay = \"DataVizDots\";\n\n/**\n * Callback function to retrieve the normalized value of a sensor given a\n * device identifier and sensor type. The callback function should return a\n * normalized value in the range of `[0.0, 1.0]`.\n *\n * @callback SensorValueCallback\n * @property {SurfaceShadingPoint} shadingPoint The generated SurfaceShadingPoint from\n * a prior call to `ModelStructureInfo.generateSurfaceShadingData` method or one from\n * a manually created {@link SurfaceShadingData}.\n * @property {string} sensorType An sensor type that was specified when\n * the `Device` was created.\n * @property {Object} data Previous data only defined when rendering or\n * updating {@link PlanarHeatmap}\n * @returns {number} A normalized sensor value in the range of `[0.0, 1.0]`.\n * If `NaN` (not a number) is returned, the sensor will have no influence in the\n * resulting heatmap color (it is as though the sensor did not exist).\n */\n\n/**\n * The object that includes the value for one or more `CustomViewable` properties\n * to be updated when the viewable is being invalidated. If a property is omitted,\n * its value in `CustomViewable` will remain unchanged.\n *\n * @typedef {Object} PropertyUpdates\n * @property {number} [scale] An optional property that updates the scale\n * of the `CustomViewable` must be in the range [0.0, 2.0].\n * @property {string} [url] An optional property that represents the sprite URL\n * to be used for the `CustomViewable` as part of its update. If provided, this\n * value should match one of the values added through `ViewableStyle.preloadSprite`\n * API.\n * @property {THREE.Color} [color] An optional property that represents the color\n * to be used for the `CustomViewable` as part of its update.\n * @property {THREE.Vector3} [position] An optional property that represents the\n * position to be used for the `CustomViewable` as part of its update.\n */\n\n/**\n * The configuration used in `renderSurfaceShading` and `updateSurfaceShading` APIs\n * to control the appearance of the resulting heatmap.\n *\n * @typedef {Object} HeatmapConfig\n * @property {number} [confidence] Optional. The distance from the sensor that its\n * value will affect the heatmap before dropping off. Measured in world coordinates\n * of the current model. The default value is `160.0`.\n * @property {number} [powerParameter] Optional. A positive real number. Greater\n * values of power parameter assign greater influence to values closest to the\n * interpolated point. This parameter is default to `2.0`.\n * @property {number} [alpha] Optional. The transparency level of the resulting\n * fragment on the heatmap, ranging from `0.0` (completely transparent) to `1.0`\n * (fully opaque). The default value is `1.0`.\n */\n\n/**\n * Callback function invoked when a `CustomViewable` is being invalidated through\n * a call to `invalidateViewable` API. Client code can optionally modify one or\n * more properties of `CustomViewable` during this call.\n *\n * @callback ViewableInvalidatedCallback\n * @param {CustomViewable} viewable The viewable object that is being invalidated.\n * @returns {PropertyUpdates} Object that specifies the properties to be updated.\n */\n\n/**\n * Data Visualization extension provides an API for building scenes with\n * custom sprites (dots) and heatmaps (surface shading) within model boundaries.\n *\n * The extension id is: `Autodesk.DataVisualization`\n *\n * @example\n *   const ext = await viewer.loadExtension(\"Autodesk.DataVisualization\")\n *\n * @class\n * @memberof Autodesk.DataVisualization.Core\n * @alias Autodesk.DataVisualization.Core.DataVisualization\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n */\nclass DataVisualization extends av.Extension {\n    /**\n     * @param {Viewer3D} viewer - Viewer instance\n     * @param {object} options - Configurations for the extension\n     * @class\n     */\n    constructor(viewer, options = {}) {\n        super(viewer, options);\n        this.textureUtility = new TextureUtility(viewer);\n        this.pointMeshes = [];\n        this._streamLineBuilder = null;\n        this._onInstanceTreeReady = this._onInstanceTreeReady.bind(this);\n    }\n\n    async load() {\n        this.tool = new SceneTool(this.viewer, {\n            delegate: this,\n        });\n\n        this.viewer.toolController.registerTool(this.tool);\n        this.activate();\n\n        this.instanceTreeReadyPromise = new Promise((resolve, reject) => {\n            this.instanceTreeReadyPromiseResolve = resolve;\n            this.instanceTreeReadyPromiseReject = reject;\n        });\n\n        this.datavizDotOverlay = this.viewer.impl.createOverlayScene(\n            datavizDotOverlay,\n            null,\n            null,\n            null,\n            true,\n            true\n        );\n\n        this.viewer.addEventListener(\n            Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT,\n            this._onInstanceTreeReady\n        );\n        this.deviceDepthOcclusion = false;\n        return true;\n    }\n\n    unload() {\n        this.viewer.toolController.deregisterTool(this.tool);\n        this.viewer.removeEventListener(\n            Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT,\n            this._onInstanceTreeReady\n        );\n\n        this.removeSurfaceShading();\n        this.surfaceShading = null;\n        this.deactivate();\n        return true;\n    }\n\n    activate() {\n        this.viewer.toolController.activateTool(this.tool.getName());\n        return true;\n    }\n\n    deactivate() {\n        if (this._streamLineBuilder) {\n            this._streamLineBuilder.dispose();\n            this._streamLineBuilder = null;\n        }\n\n        this.viewer.toolController.deactivateTool(this.tool.getName());\n        this.removeSurfaceShading();\n        this.showTextures();\n        this.removeAllViewables();\n        return true;\n    }\n\n    _onInstanceTreeReady(event) {\n        if (this.instanceTreeReadyPromiseResolve) {\n            this.instanceTreeReadyPromiseResolve();\n        }\n    }\n\n    async waitForInstanceTree(model) {\n        if (model.getInstanceTree()) {\n            this.instanceTreeReadyPromiseResolve();\n        } else {\n            await this.instanceTreeReadyPromise;\n        }\n    }\n\n    get hasViewables() {\n        return this.pointMeshes && this.pointMeshes.length > 0 && this.viewableData;\n    }\n\n    get streamLineBuilder() {\n        if (!this._streamLineBuilder) {\n            this._streamLineBuilder = new StreamLineBuilder(this.viewer);\n        }\n\n        return this._streamLineBuilder;\n    }\n\n    /**\n     * @private\n     *\n     * Obtains a list of corresponding geometries given a list of `DbId`.\n     * @param {number[]} dbIds An array of `DbId` whose corresponding geometries\n     * are to be obtained.\n     * @returns The array of geometries correspond to the input `DbId` list.\n     */\n    mapDbIdsToGeometries(dbIds) {\n        const idToGeometryMap = this.dbId2Geometry || {};\n\n        let geometries = new Set();\n        dbIds.map((id) => {\n            const geometry = idToGeometryMap[id];\n            if (geometry) geometries.add(geometry);\n        });\n\n        return Array.from(geometries);\n    }\n\n    /**\n     * Adds a collection of `CustomViewable` objects for display through\n     * the `ViewableData` object that contains them.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#addViewables\n     * @param {ViewableData} data The `ViewableData` that contains all\n     * the `CustomViewable` objects which are to be added for display.\n     */\n    addViewables(data) {\n        const sprite = THREE.ImageUtils.loadTexture(data.spriteAtlas.canvas.toDataURL());\n        sprite.minFilter = THREE.LinearFilter;\n        sprite.maxFilter = THREE.LinearFilter;\n        sprite.flipY = false;\n\n        const material = new THREE.PointCloudMaterial({\n            size: data.spriteSize * this.getWindow().devicePixelRatio,\n            map: sprite,\n            vertexColors: THREE.VertexColors,\n            alphaTest: 0.5,\n            transparent: true,\n            occlusion: 1,\n            depthTest: true,\n            depthWrite: true,\n        });\n\n        material.skipMrtNormals = true;\n\n        function updateDepthUniforms(viewer, mat) {\n            // When AmbientOclution is off, there is no depthTarget\n            const depthTarget = viewer.impl.renderer().getDepthTarget();\n\n            if (depthTarget) {\n                const res = new THREE.Vector2(1 / depthTarget.width, 1 / depthTarget.height);\n                mat.uniforms = Object.assign(mat.uniforms || {}, {\n                    \"tDepthTest\": { type: \"t\", value: depthTarget },\n                    \"tDepthResolution\": { type: \"v2\", value: res },\n                });\n            }\n        }\n\n        updateDepthUniforms(this.viewer, material);\n\n        material.defines = Object.assign(material.defines || {}, {\n            PARTICLE_FRAGMENT: 1,\n            USE_VERTEX_ID: 1,\n            DEPTH_OCCLUSION: this.deviceDepthOcclusion ? 1 : 0,\n            PARTICLE_UV: 1,\n            PARTICLE_FLAGS: \"\",\n        });\n\n        const viewerImpl = this.viewer.impl;\n        let matman = viewerImpl.matman();\n        matman.addMaterial(\"__dataVizSpriteMaterial__\", material, true);\n\n        this.pointMaterial = material;\n        this.viewableData = data;\n        this.dbId2Geometry = {};\n\n        this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, () => {\n            updateDepthUniforms(this.viewer, material);\n        });\n\n        const thisObject = this;\n        function geometryCallback(geometry) {\n            geometry.dbIds.forEach((dbId) => {\n                thisObject.dbId2Geometry[dbId] = geometry;\n            });\n\n            const mesh = new THREE.Mesh(geometry, material);\n            viewerImpl.addOverlay(datavizDotOverlay, mesh);\n            thisObject.pointMeshes.push(mesh);\n\n            setTimeout(() => {\n                viewerImpl.invalidate(false, false, true);\n            }, 16);\n        }\n\n        let builder = new SpriteMeshBuilder(geometryCallback);\n        let viewables = data.viewables;\n        viewables.map((item) => {\n            if (item.position) {\n                builder.addPoint(item, data.spriteAtlas);\n            }\n        });\n\n        builder.flushBuffer();\n    }\n\n    /**\n     * Removes all viewables from display.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#removeAllViewables\n     */\n    removeAllViewables() {\n        // remove all the drawable mesh from the overlay\n        if (this.pointMeshes && this.pointMeshes.length > 0) {\n            let viewerImpl = this.viewer.impl;\n            this.pointMeshes.forEach((mesh) => {\n                viewerImpl.removeOverlay(datavizDotOverlay, mesh);\n                mesh.geometry.dispose();\n                mesh.material.dispose();\n            });\n\n            viewerImpl.invalidate(false, false, true);\n        }\n\n        // Reset viewable variables.\n        this.pointMeshes = [];\n        delete this.dbId2Geometry;\n        delete this.viewableData;\n    }\n\n    /**\n     * @description Enables or disables depth testing for custom viewable objects.\n     * When depth testing is enabled for custom viewables, they will be occluded\n     * by objects in the scene that are nearer to the camera. If depth testing is\n     * disabled for custom viewables, they will always be visible regardless of\n     * other objects that may be blocking them.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#changeOcclusion\n     * @param {boolean} enable Indicates if occlusion should be enabled. Set\n     * this parameter to `true` to enable depth testing for custom viewables,\n     * or `false` otherwise.\n     */\n    changeOcclusion(enable) {\n        if (this.deviceDepthOcclusion != enable) {\n            this.deviceDepthOcclusion = enable;\n            let occlusion = enable ? 1 : 0;\n\n            if (this.pointMaterial && this.pointMaterial.program) {\n                this.pointMaterial.defines[\"DEPTH_OCCLUSION\"] = occlusion;\n                this.pointMaterial.needsUpdate = true;\n            }\n            this.viewer.impl.invalidate(false, false, true);\n        }\n    }\n\n    /**\n     * Sets the visibility and occlusion for these custom viewables.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#showHideViewables\n     * @param {boolean} visible Indicates if all custom viewables should be visible.\n     * Set this to `true` to display all custom viewables, or `false` otherwise.\n     * @param {boolean} occlusion Indicates if occlusion should be enabled. If\n     * this parameter is set to `true`, depth testing will be enabled for custom\n     * viewables, causing them to be occluded by objects that are nearer to the\n     * camera. Set this to `false` in order to always display custom viewables on\n     * top of the view and not be occluded by other objects in the scene.\n     */\n    showHideViewables(visible, occlusion) {\n        this.changeOcclusion(occlusion);\n\n        if (this.pointMaterial) {\n            this.pointMaterial.visible = visible;\n            this.pointMaterial.needsUpdate = true;\n        }\n\n        this.viewer.impl.invalidate(false, false, true);\n    }\n\n    /**\n     * Highlights one or more existing custom viewables in the scene.\n     * Highlighted viewables can be cleared with `clearHighlightedViewables` API.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#highlightViewables\n     * @param {number|number[]} dbIds The `DbId` of one or more custom viewables\n     * to highlight.\n     */\n    highlightViewables(dbIds) {\n        if (this.tool) {\n            this.tool.markObject(dbIds);\n        }\n    }\n\n    /**\n     * Clears any existing highlighted custom viewable that was highlighted\n     * with a prior call to `highlightViewables` API.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#clearHighlightedViewables\n     */\n    clearHighlightedViewables() {\n        if (this.tool) {\n            this.tool.clearMarkedObject();\n        }\n    }\n\n    /**\n     * Invalidates one or more `CustomViewable` objects, causing them to update\n     * with new properties (e.g. sprite image, position, etc.). Since this call\n     * updates all relevant viewable objects in a single batch, it is recommended\n     * that more viewables to be batched in less number of `invalidateViewables`\n     * calls.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#invalidateViewables\n     *\n     * @param {number|number[]} dbIds One or more `DbId` values of viewables to\n     * be updated in this call.\n     * @param {ViewableInvalidatedCallback} callback The client specified callback\n     * function to be invoked for each of the `CustomViewable` objects being\n     * invalidated. The callback function should return new property values that\n     * the `CustomViewable` object is to be updated with.\n     */\n    invalidateViewables(dbIds, callback) {\n        if (!dbIds || dbIds.length <= 0) {\n            console.warn(`All parameters of 'invalidateViewables' are mandatory`);\n            return;\n        }\n\n        if (!this.pointMeshes || this.pointMeshes.length <= 0 || !this.viewableData) {\n            console.warn(`'addViewables' must be called before 'invalidateViewables'`);\n            return;\n        }\n\n        if (this.tool) {\n            this.tool.invalidateViewablesDirect(\n                dbIds,\n                this.pointMeshes,\n                this.viewableData,\n                callback\n            );\n        }\n    }\n\n    /**\n     * Enables texture display in the current scene.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#showTextures\n     */\n    showTextures() {\n        this.textureUtility.showTextures();\n    }\n\n    /**\n     * Disables texture display in the current scene.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#hideTextures\n     */\n    hideTextures() {\n        this.textureUtility.hideTextures();\n    }\n\n    /**\n     * Sets up surface shading (heatmap display) for the model.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#setupSurfaceShading\n     * @param {Model} model The model to set up the shading for. It is used to\n     * establish connections between `DbId` and the corresponding fragments\n     * so that heatmap can be rendered. Note that this model may not always\n     * be the same one representing the main loaded model. If the shading is\n     * set up for models built by `SceneBuilder`, then this parameter should\n     * be the model within that same `SceneBuilder`. See example for more.\n     * @param {SurfaceShadingData} shadingData The surface shading data generated\n     * with a prior call to `ModelStructureInfo.generateSurfaceShadingData`.\n     * This value is used to set up the surface shading.\n     * @param {Object} [options] Extra configuration options for surface shading.\n     * The `options` parameter is only used for setting up `PlanarHeatmap` (i.e.\n     * when `options.type` is set to `PlanarHeatmap`).\n     * @param {string} options.type To create a planar heatmap, this must be set\n     * to `\"PlanarHeatmap\"`.\n     * @param {number} [options.width] Optional. The width in pixels of the\n     * underlying texture used for rendering the heatmap. If the bounding box of\n     * the geometry turns out to be portrait, then `width` value will be adjusted\n     * with respect to `height` value to retain the aspect ratio. If unspecified,\n     * the default value of `1024` pixels is used.\n     * @param {number} [options.height] Optional. The height in pixels of the\n     * underlying texture used for rendering the heatmap. If the bounding box of\n     * the geometry turns out to be landscape, then `height` value will be\n     * adjusted with respect to `width` value to retain the aspect ratio.\n     * If unspecified, the default value of `1024` pixels is used.\n     * @param {boolean} [options.slicingEnabled] Optional. Set this to `true` to\n     * enable geometry slicing through the use of `CompGeom` viewer extension.\n     * This allows edges to be built as boundaries for irregularly shaped geometries,\n     * but may fail for complex geometries. When set to `false`, the axis-aligned\n     * bounding boxes of relevant geometries will be used to display heatmap texture.\n     * If unspecified, this parameter will be set to `true`.\n     * @param {number} [options.slicingPosition] Optional. A number representing the\n     * point at which slicing should happen. Valid value range is `[0.0, 1.0]`. If\n     * unspecified, the default value of `0.5` will be used, slicing geometry through\n     * the vertical mid-point of the bounding box. This value will be used only\n     * if `options.slicingEnabled` is set to `true`.\n     * @param {number} [options.placementPosition] Optional. A number in the range\n     * of `[0.0, 1.0]`, indicating the placement position of the resulting plane.\n     * When set to `0.0`, the plane will be positioned at the lowest `z` coordinate\n     * of the bounding box. When set to `1.0`, the plane will be positioned at the\n     * highest point of the bounding box. If unspecified, the default value of `0.0`\n     * will be used.\n     * @param {number} [options.minOpacity] Optional. The minimum opacity the lowest\n     * value in the heatmap will have. This value is in the range of `[0.0, 1.0]`. If\n     * unspecified the default value of `0.0` will be used.\n     * @param {number} [options.maxOpacity] Optional. The maximal opacity the highest\n     * value in the heatmap will have. This value is in the range of `[0.0, 1.0]`. If\n     * unspecified the default value of `1.0` will be used.\n     *\n     * @example\n     *  // 'devices' is a list of 'Device' objects\n     *  const info = new Autodesk.DataVisualization.Core.ModelStructureInfo(model);\n     *  const shadingData = await info.generateSurfaceShadingData(devices);\n     *\n     *  // The call to 'generateSurfaceShadingData' above generates 'shadingData'\n     *  // based on 'model' that is passed to 'ModelStructureInfo', therefore the\n     *  // 'DbId' within 'shadingData' are all originated from the same 'model'.\n     *  // In this case, the first parameter is the same 'model' above.\n     *  //\n     *  dataVizExtn.setupSurfaceShading(model, shadingData);\n     *\n     *  // If the 'SurfaceShadingData' passed to 'setupSurfaceShading' is constructed\n     *  // with 'DbId' coming from a 'SceneBuilder', then the first parameter must be\n     *  // the same model that 'SurfaceShadingData' was created from:\n     *  //\n     *  // const anotherModel = sceneBuilder.modelBuilder.model;\n     *  // dataVizExtn.setupSurfaceShading(anotherModel, shadingData);\n     */\n    async setupSurfaceShading(model, shadingData, options = {}) {\n        var createSetup = async () => {\n            if (this.surfaceShading) {\n                this.surfaceShading.cleanUp();\n            }\n\n            if (options.type == \"PlanarHeatmap\") {\n                await this.viewer.loadExtension(\"Autodesk.CompGeom\");\n                this.surfaceShading = new PlanarHeatmap(this.viewer, model, shadingData, options);\n            } else {\n                this.surfaceShading = new SurfaceShading(this.viewer, model, shadingData);\n            }\n        };\n\n        await this.waitForInstanceTree(model);\n        return createSetup();\n    }\n\n    /**\n     * Renders one or more nodes with the given identifiers. This call creates\n     * necessary resources like overlay scene and materials, therefore is by\n     * design to be called only when necessary (i.e., when surface shading needs\n     * to be updated due to geometry changes). For more lightweight\n     * rendering, `updateSurfaceShading` API should be used instead.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#renderSurfaceShading\n     * @param {string|string[]} nodeIds One or more identifiers of nodes\n     * to render. These identifiers are among the ones provided\n     * through `SurfaceShadingData` in a prior call to `setupSurfaceShading` API.\n     * @param {string} sensorType The type of sensor to render the shading for.\n     * @param {SensorValueCallback} valueCallback The callback function that\n     * will be invoked when surface shading requires the sensor value to render.\n     * @param {HeatmapConfig} [heatmapConfig] Optional. The configuration of\n     * the heatmap. See documentation for `HeatmapConfig` for more details.\n     *\n     * @example\n     *  // This callback will be invoked multiple times for each call to\n     *  // 'renderSurfaceShading' below, once for each of the devices on\n     *  // the floor.\n     *  function getSensorValue(deviceInfo, sensorType) {\n     *      const deviceId = deviceInfo.id;\n     *      const sensorValue = readSensorValue(deviceId, sensorType);\n     *      return clamp(sensorValue, 0.0, 1.0); // Normalize sensor value\n     *  }\n     *\n     *  function onFloorSelectedOnUi(floorName) {\n     *      const sensorType = \"CO\";\n     *      dataVizExtn.renderSurfaceShading(floorName, sensorType, getSensorValue);\n     *  }\n     */\n    renderSurfaceShading(nodeIds, sensorType, valueCallback, heatmapConfig) {\n        // The following handles the API update without breaking existing client\n        // codes that can be in one of two categories: code that omits the 4th\n        // parameter (i.e. `confidenceSize`), and code that specifies a number as\n        // the 4th parameter. For the first category, `confidenceSize` defaults\n        // to `160.0` while for the second category, `confidenceSize` will be set\n        // to the number client code provides.\n        //\n        // For newer client code that provides `HeatmapConfig`, its value will be\n        // further validated in volumetric and planar heatmap, depending on the\n        // values that make sense of them.\n        //\n        if (heatmapConfig === null || typeof heatmapConfig === \"undefined\") {\n            heatmapConfig = { confidence: 160.0 };\n        } else if (typeof heatmapConfig === \"number\") {\n            heatmapConfig = { confidence: Math.abs(heatmapConfig) };\n        }\n\n        if (this.surfaceShading) {\n            this.surfaceShading.render(nodeIds, sensorType, valueCallback, heatmapConfig);\n        } else {\n            avp.logger.error(\"Please call setupSurfaceShading first\");\n        }\n    }\n\n    /**\n     * Updates the surface shading (heatmap) with the latest sensor values.\n     * This API simply updates the resources created in a prior call to\n     * the `renderSurfaceShading` without recreating them, therefore it is\n     * a more lightweight alternatives suited for high frequency calls.\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#updateSurfaceShading\n     * @param {SensorValueCallback} valueCallback The callback function that\n     * will be invoked when surface shading requires the sensor value to render.\n     * @param {HeatmapConfig} [heatmapConfig] Optional. The configuration of\n     * the heatmap. See documentation for `HeatmapConfig` for more details.\n     *\n     * @example\n     *  let seconds; // Selected time on the UI\n     *\n     *  // This callback will be invoked multiple times for each call to\n     *  // 'renderSurfaceShading' below, once for each of the devices on\n     *  // the floor.\n     *  function getSensorValue(deviceInfo, sensorType) {\n     *      const deviceId = deviceInfo.id;\n     *      const sensorValue = readSensorValue(deviceId, sensorType, seconds);\n     *      return clamp(sensorValue, 0.0, 1.0); // Normalize sensor value\n     *  }\n     *\n     *  // Handler for slider events that is triggered rapidly\n     *  function onTimeSliderValueChanged(timeInSeconds) {\n     *      seconds = timeInSeconds;\n     *      dataVizExtn.updateSurfaceShading(getSensorValue);\n     *  }\n     */\n    updateSurfaceShading(valueCallback, heatmapConfig) {\n        if (this.surfaceShading) {\n            this.surfaceShading.updateShading(valueCallback, heatmapConfig);\n        } else {\n            avp.logger.error(\"Please call setupSurfaceShading first\");\n        }\n    }\n\n    /**\n     * Registers color stops for use in heatmap colorization. The specified color\n     * stops evenly spread out across the spectrum that represents the normalized\n     * sensor values ranging between 0.0 and 1.0.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#registerSurfaceShadingColors\n     *\n     * @param {string} sensorType The sensor type to define the color stops for.\n     * @param {number[]} colors An array of color values, each expressed in a\n     * 3-byte (24-bit) numerical value. Note that it is possible to specify a\n     * 4-byte (32-bit) number as color, but only 3 lower bytes will be taken.\n     * Each of the three bytes represents the intensity value between `0` and `255`,\n     * of red, green, blue color component respectively. For example, `0xff0000`\n     * represents a red color with full intensity.\n     *\n     * @param {number} alpha The opacity of the heatmap for the specified sensorType\n     *\n     * @example\n     *  // Register 3 color stops for CO sensor values\n     *  const dataVizExt = await viewer.loadExtension(\"Autodesk.DataVisualization\");\n     *  dataVizExt.registerSurfaceShadingColors(\"CO\", [0x0f2027, 0x203a43, 0x2c5364]);\n     */\n    registerSurfaceShadingColors(sensorType, colors, alpha = 0.7) {\n        if (this.surfaceShading) {\n            this.surfaceShading.registerSensorColors(sensorType, colors, alpha);\n        } else {\n            avp.logger.error(\"Please call setupSurfaceShading first\");\n        }\n    }\n\n    /**\n     * Removes any surface shading created by clearing the overlay\n     * which holds the meshes used as heatmap representation.\n     *\n     * @alias Autodesk.DataVisualization.Core.DataVisualization#removeSurfaceShading\n     */\n    removeSurfaceShading() {\n        if (this.surfaceShading) {\n            this.surfaceShading.removeShading();\n        }\n    }\n}\n\nav.theExtensionManager.registerExtension(extnName, DataVisualization);\n"],"sourceRoot":""}